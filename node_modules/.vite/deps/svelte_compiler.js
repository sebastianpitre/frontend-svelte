import {
  boolean_attributes,
  is_html,
  is_svg,
  is_void
} from "./chunk-MWXYZPUI.js";
import {
  VERSION
} from "./chunk-GZA2YTNP.js";
import {
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-UV5CTPV7.js";

// node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var require_sourcemap_codec_umd = __commonJS({
  "node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.sourcemapCodec = {}));
    })(exports, function(exports2) {
      "use strict";
      const comma = ",".charCodeAt(0);
      const semicolon = ";".charCodeAt(0);
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      const intToChar = new Uint8Array(64);
      const charToInt = new Uint8Array(128);
      for (let i = 0; i < chars.length; i++) {
        const c2 = chars.charCodeAt(i);
        intToChar[i] = c2;
        charToInt[c2] = i;
      }
      const td = typeof TextDecoder !== "undefined" ? new TextDecoder() : typeof Buffer !== "undefined" ? {
        decode(buf) {
          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
          return out.toString();
        }
      } : {
        decode(buf) {
          let out = "";
          for (let i = 0; i < buf.length; i++) {
            out += String.fromCharCode(buf[i]);
          }
          return out;
        }
      };
      function decode4(mappings) {
        const state = new Int32Array(5);
        const decoded = [];
        let index = 0;
        do {
          const semi = indexOf(mappings, index);
          const line = [];
          let sorted = true;
          let lastCol = 0;
          state[0] = 0;
          for (let i = index; i < semi; i++) {
            let seg;
            i = decodeInteger(mappings, i, state, 0);
            const col = state[0];
            if (col < lastCol)
              sorted = false;
            lastCol = col;
            if (hasMoreVlq(mappings, i, semi)) {
              i = decodeInteger(mappings, i, state, 1);
              i = decodeInteger(mappings, i, state, 2);
              i = decodeInteger(mappings, i, state, 3);
              if (hasMoreVlq(mappings, i, semi)) {
                i = decodeInteger(mappings, i, state, 4);
                seg = [col, state[1], state[2], state[3], state[4]];
              } else {
                seg = [col, state[1], state[2], state[3]];
              }
            } else {
              seg = [col];
            }
            line.push(seg);
          }
          if (!sorted)
            sort(line);
          decoded.push(line);
          index = semi + 1;
        } while (index <= mappings.length);
        return decoded;
      }
      function indexOf(mappings, index) {
        const idx = mappings.indexOf(";", index);
        return idx === -1 ? mappings.length : idx;
      }
      function decodeInteger(mappings, pos, state, j) {
        let value = 0;
        let shift = 0;
        let integer2 = 0;
        do {
          const c2 = mappings.charCodeAt(pos++);
          integer2 = charToInt[c2];
          value |= (integer2 & 31) << shift;
          shift += 5;
        } while (integer2 & 32);
        const shouldNegate = value & 1;
        value >>>= 1;
        if (shouldNegate) {
          value = -2147483648 | -value;
        }
        state[j] += value;
        return pos;
      }
      function hasMoreVlq(mappings, i, length2) {
        if (i >= length2)
          return false;
        return mappings.charCodeAt(i) !== comma;
      }
      function sort(line) {
        line.sort(sortComparator);
      }
      function sortComparator(a, b2) {
        return a[0] - b2[0];
      }
      function encode6(decoded) {
        const state = new Int32Array(5);
        const bufLength = 1024 * 16;
        const subLength = bufLength - 36;
        const buf = new Uint8Array(bufLength);
        const sub = buf.subarray(0, subLength);
        let pos = 0;
        let out = "";
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          if (i > 0) {
            if (pos === bufLength) {
              out += td.decode(buf);
              pos = 0;
            }
            buf[pos++] = semicolon;
          }
          if (line.length === 0)
            continue;
          state[0] = 0;
          for (let j = 0; j < line.length; j++) {
            const segment = line[j];
            if (pos > subLength) {
              out += td.decode(sub);
              buf.copyWithin(0, subLength, pos);
              pos -= subLength;
            }
            if (j > 0)
              buf[pos++] = comma;
            pos = encodeInteger(buf, pos, state, segment, 0);
            if (segment.length === 1)
              continue;
            pos = encodeInteger(buf, pos, state, segment, 1);
            pos = encodeInteger(buf, pos, state, segment, 2);
            pos = encodeInteger(buf, pos, state, segment, 3);
            if (segment.length === 4)
              continue;
            pos = encodeInteger(buf, pos, state, segment, 4);
          }
        }
        return out + td.decode(buf.subarray(0, pos));
      }
      function encodeInteger(buf, pos, state, segment, j) {
        const next = segment[j];
        let num = next - state[j];
        state[j] = next;
        num = num < 0 ? -num << 1 | 1 : num << 1;
        do {
          let clamped = num & 31;
          num >>>= 5;
          if (num > 0)
            clamped |= 32;
          buf[pos++] = intToChar[clamped];
        } while (num > 0);
        return pos;
      }
      exports2.decode = decode4;
      exports2.encode = encode6;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/source-map-js/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map-js/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number2) {
      if (0 <= number2 && number2 < intToCharMap.length) {
        return intToCharMap[number2];
      }
      throw new TypeError("Must be between 0 and 63: " + number2);
    };
    exports.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero2 = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero2 <= charCode && charCode <= nine) {
        return charCode - zero2 + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map-js/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map-js/lib/base64-vlq.js"(exports) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map-js/lib/util.js
var require_util = __commonJS({
  "node_modules/source-map-js/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    var MAX_CACHED_INPUTS = 32;
    function lruMemoize(f) {
      var cache = [];
      return function(input) {
        for (var i = 0; i < cache.length; i++) {
          if (cache[i].input === input) {
            var temp = cache[0];
            cache[0] = cache[i];
            cache[i] = temp;
            return cache[0].result;
          }
        }
        var result = f(input);
        cache.unshift({
          input,
          result
        });
        if (cache.length > MAX_CACHED_INPUTS) {
          cache.pop();
        }
        return result;
      };
    }
    var normalize = lruMemoize(function normalize2(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = [];
      var start = 0;
      var i = 0;
      while (true) {
        start = i;
        i = path.indexOf("/", start);
        if (i === -1) {
          parts.push(path.slice(start));
          break;
        } else {
          parts.push(path.slice(start, i));
          while (i < path.length && path[i] === "/") {
            i++;
          }
        }
      }
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    });
    exports.normalize = normalize;
    function join3(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join3;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length2 = s.length;
      if (length2 < 9) {
        return false;
      }
      if (s.charCodeAt(length2 - 1) !== 95 || s.charCodeAt(length2 - 2) !== 95 || s.charCodeAt(length2 - 3) !== 111 || s.charCodeAt(length2 - 4) !== 116 || s.charCodeAt(length2 - 5) !== 111 || s.charCodeAt(length2 - 6) !== 114 || s.charCodeAt(length2 - 7) !== 112 || s.charCodeAt(length2 - 8) !== 95 || s.charCodeAt(length2 - 9) !== 95) {
        return false;
      }
      for (var i = length2 - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
      var cmp;
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join3(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map-js/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map-js/lib/array-set.js"(exports) {
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// node_modules/source-map-js/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map-js/lib/mapping-list.js"(exports) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports.MappingList = MappingList;
  }
});

// node_modules/source-map-js/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map-js/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator2(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._ignoreInvalidMapping = util.getArg(aArgs, "ignoreInvalidMapping", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator2.prototype._version = 3;
    SourceMapGenerator2.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator2(Object.assign(generatorOps || {}, {
        file: aSourceMapConsumer.file,
        sourceRoot
      }));
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator2.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name49 = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        if (this._validateMapping(generated, original, source, name49) === false) {
          return;
        }
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name49 != null) {
        name49 = String(name49);
        if (!this._names.has(name49)) {
          this._names.add(name49);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name: name49
      });
    };
    SourceMapGenerator2.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator2.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name49 = mapping.name;
        if (name49 != null && !newNames.has(name49)) {
          newNames.add(name49);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator2.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        var message = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
        if (this._ignoreInvalidMapping) {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(message);
          }
          return false;
        } else {
          throw new Error(message);
        }
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        var message = "Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        });
        if (this._ignoreInvalidMapping) {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(message);
          }
          return false;
        } else {
          throw new Error(message);
        }
      }
    };
    SourceMapGenerator2.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator2.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator2.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator2.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator2;
  }
});

// node_modules/aria-query/lib/util/iteratorProxy.js
var require_iteratorProxy = __commonJS({
  "node_modules/aria-query/lib/util/iteratorProxy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function iteratorProxy() {
      var values = this;
      var index = 0;
      var iter = {
        "@@iterator": function iterator() {
          return iter;
        },
        next: function next() {
          if (index < values.length) {
            var value = values[index];
            index = index + 1;
            return {
              done: false,
              value
            };
          } else {
            return {
              done: true
            };
          }
        }
      };
      return iter;
    }
    var _default = iteratorProxy;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/util/iterationDecorator.js
var require_iterationDecorator = __commonJS({
  "node_modules/aria-query/lib/util/iterationDecorator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = iterationDecorator;
    var _iteratorProxy = _interopRequireDefault(require_iteratorProxy());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function iterationDecorator(collection, entries) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
        Object.defineProperty(collection, Symbol.iterator, {
          value: _iteratorProxy.default.bind(entries)
        });
      }
      return collection;
    }
  }
});

// node_modules/aria-query/lib/ariaPropsMap.js
var require_ariaPropsMap = __commonJS({
  "node_modules/aria-query/lib/ariaPropsMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F4 = function F5() {
          };
          return { s: F4, n: function n2() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e2) {
            throw _e2;
          }, f: F4 };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var properties3 = [["aria-activedescendant", {
      "type": "id"
    }], ["aria-atomic", {
      "type": "boolean"
    }], ["aria-autocomplete", {
      "type": "token",
      "values": ["inline", "list", "both", "none"]
    }], ["aria-braillelabel", {
      "type": "string"
    }], ["aria-brailleroledescription", {
      "type": "string"
    }], ["aria-busy", {
      "type": "boolean"
    }], ["aria-checked", {
      "type": "tristate"
    }], ["aria-colcount", {
      type: "integer"
    }], ["aria-colindex", {
      type: "integer"
    }], ["aria-colspan", {
      type: "integer"
    }], ["aria-controls", {
      "type": "idlist"
    }], ["aria-current", {
      type: "token",
      values: ["page", "step", "location", "date", "time", true, false]
    }], ["aria-describedby", {
      "type": "idlist"
    }], ["aria-description", {
      "type": "string"
    }], ["aria-details", {
      "type": "id"
    }], ["aria-disabled", {
      "type": "boolean"
    }], ["aria-dropeffect", {
      "type": "tokenlist",
      "values": ["copy", "execute", "link", "move", "none", "popup"]
    }], ["aria-errormessage", {
      "type": "id"
    }], ["aria-expanded", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-flowto", {
      "type": "idlist"
    }], ["aria-grabbed", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-haspopup", {
      "type": "token",
      "values": [false, true, "menu", "listbox", "tree", "grid", "dialog"]
    }], ["aria-hidden", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-invalid", {
      "type": "token",
      "values": ["grammar", false, "spelling", true]
    }], ["aria-keyshortcuts", {
      type: "string"
    }], ["aria-label", {
      "type": "string"
    }], ["aria-labelledby", {
      "type": "idlist"
    }], ["aria-level", {
      "type": "integer"
    }], ["aria-live", {
      "type": "token",
      "values": ["assertive", "off", "polite"]
    }], ["aria-modal", {
      type: "boolean"
    }], ["aria-multiline", {
      "type": "boolean"
    }], ["aria-multiselectable", {
      "type": "boolean"
    }], ["aria-orientation", {
      "type": "token",
      "values": ["vertical", "undefined", "horizontal"]
    }], ["aria-owns", {
      "type": "idlist"
    }], ["aria-placeholder", {
      type: "string"
    }], ["aria-posinset", {
      "type": "integer"
    }], ["aria-pressed", {
      "type": "tristate"
    }], ["aria-readonly", {
      "type": "boolean"
    }], ["aria-relevant", {
      "type": "tokenlist",
      "values": ["additions", "all", "removals", "text"]
    }], ["aria-required", {
      "type": "boolean"
    }], ["aria-roledescription", {
      type: "string"
    }], ["aria-rowcount", {
      type: "integer"
    }], ["aria-rowindex", {
      type: "integer"
    }], ["aria-rowspan", {
      type: "integer"
    }], ["aria-selected", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-setsize", {
      "type": "integer"
    }], ["aria-sort", {
      "type": "token",
      "values": ["ascending", "descending", "none", "other"]
    }], ["aria-valuemax", {
      "type": "number"
    }], ["aria-valuemin", {
      "type": "number"
    }], ["aria-valuenow", {
      "type": "number"
    }], ["aria-valuetext", {
      "type": "string"
    }]];
    var ariaPropsMap = {
      entries: function entries() {
        return properties3;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator = _createForOfIteratorHelper(properties3), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], values = _step$value[1];
            fn.call(thisArg, values, key, properties3);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      },
      get: function get(key) {
        var item = properties3.find(function(tuple) {
          return tuple[0] === key ? true : false;
        });
        return item && item[1];
      },
      has: function has(key) {
        return !!ariaPropsMap.get(key);
      },
      keys: function keys() {
        return properties3.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
          return key;
        });
      },
      values: function values() {
        return properties3.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(ariaPropsMap, ariaPropsMap.entries());
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/domMap.js
var require_domMap = __commonJS({
  "node_modules/aria-query/lib/domMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F4 = function F5() {
          };
          return { s: F4, n: function n2() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e2) {
            throw _e2;
          }, f: F4 };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var dom2 = [["a", {
      reserved: false
    }], ["abbr", {
      reserved: false
    }], ["acronym", {
      reserved: false
    }], ["address", {
      reserved: false
    }], ["applet", {
      reserved: false
    }], ["area", {
      reserved: false
    }], ["article", {
      reserved: false
    }], ["aside", {
      reserved: false
    }], ["audio", {
      reserved: false
    }], ["b", {
      reserved: false
    }], ["base", {
      reserved: true
    }], ["bdi", {
      reserved: false
    }], ["bdo", {
      reserved: false
    }], ["big", {
      reserved: false
    }], ["blink", {
      reserved: false
    }], ["blockquote", {
      reserved: false
    }], ["body", {
      reserved: false
    }], ["br", {
      reserved: false
    }], ["button", {
      reserved: false
    }], ["canvas", {
      reserved: false
    }], ["caption", {
      reserved: false
    }], ["center", {
      reserved: false
    }], ["cite", {
      reserved: false
    }], ["code", {
      reserved: false
    }], ["col", {
      reserved: true
    }], ["colgroup", {
      reserved: true
    }], ["content", {
      reserved: false
    }], ["data", {
      reserved: false
    }], ["datalist", {
      reserved: false
    }], ["dd", {
      reserved: false
    }], ["del", {
      reserved: false
    }], ["details", {
      reserved: false
    }], ["dfn", {
      reserved: false
    }], ["dialog", {
      reserved: false
    }], ["dir", {
      reserved: false
    }], ["div", {
      reserved: false
    }], ["dl", {
      reserved: false
    }], ["dt", {
      reserved: false
    }], ["em", {
      reserved: false
    }], ["embed", {
      reserved: false
    }], ["fieldset", {
      reserved: false
    }], ["figcaption", {
      reserved: false
    }], ["figure", {
      reserved: false
    }], ["font", {
      reserved: false
    }], ["footer", {
      reserved: false
    }], ["form", {
      reserved: false
    }], ["frame", {
      reserved: false
    }], ["frameset", {
      reserved: false
    }], ["h1", {
      reserved: false
    }], ["h2", {
      reserved: false
    }], ["h3", {
      reserved: false
    }], ["h4", {
      reserved: false
    }], ["h5", {
      reserved: false
    }], ["h6", {
      reserved: false
    }], ["head", {
      reserved: true
    }], ["header", {
      reserved: false
    }], ["hgroup", {
      reserved: false
    }], ["hr", {
      reserved: false
    }], ["html", {
      reserved: true
    }], ["i", {
      reserved: false
    }], ["iframe", {
      reserved: false
    }], ["img", {
      reserved: false
    }], ["input", {
      reserved: false
    }], ["ins", {
      reserved: false
    }], ["kbd", {
      reserved: false
    }], ["keygen", {
      reserved: false
    }], ["label", {
      reserved: false
    }], ["legend", {
      reserved: false
    }], ["li", {
      reserved: false
    }], ["link", {
      reserved: true
    }], ["main", {
      reserved: false
    }], ["map", {
      reserved: false
    }], ["mark", {
      reserved: false
    }], ["marquee", {
      reserved: false
    }], ["menu", {
      reserved: false
    }], ["menuitem", {
      reserved: false
    }], ["meta", {
      reserved: true
    }], ["meter", {
      reserved: false
    }], ["nav", {
      reserved: false
    }], ["noembed", {
      reserved: true
    }], ["noscript", {
      reserved: true
    }], ["object", {
      reserved: false
    }], ["ol", {
      reserved: false
    }], ["optgroup", {
      reserved: false
    }], ["option", {
      reserved: false
    }], ["output", {
      reserved: false
    }], ["p", {
      reserved: false
    }], ["param", {
      reserved: true
    }], ["picture", {
      reserved: true
    }], ["pre", {
      reserved: false
    }], ["progress", {
      reserved: false
    }], ["q", {
      reserved: false
    }], ["rp", {
      reserved: false
    }], ["rt", {
      reserved: false
    }], ["rtc", {
      reserved: false
    }], ["ruby", {
      reserved: false
    }], ["s", {
      reserved: false
    }], ["samp", {
      reserved: false
    }], ["script", {
      reserved: true
    }], ["section", {
      reserved: false
    }], ["select", {
      reserved: false
    }], ["small", {
      reserved: false
    }], ["source", {
      reserved: true
    }], ["spacer", {
      reserved: false
    }], ["span", {
      reserved: false
    }], ["strike", {
      reserved: false
    }], ["strong", {
      reserved: false
    }], ["style", {
      reserved: true
    }], ["sub", {
      reserved: false
    }], ["summary", {
      reserved: false
    }], ["sup", {
      reserved: false
    }], ["table", {
      reserved: false
    }], ["tbody", {
      reserved: false
    }], ["td", {
      reserved: false
    }], ["textarea", {
      reserved: false
    }], ["tfoot", {
      reserved: false
    }], ["th", {
      reserved: false
    }], ["thead", {
      reserved: false
    }], ["time", {
      reserved: false
    }], ["title", {
      reserved: true
    }], ["tr", {
      reserved: false
    }], ["track", {
      reserved: true
    }], ["tt", {
      reserved: false
    }], ["u", {
      reserved: false
    }], ["ul", {
      reserved: false
    }], ["var", {
      reserved: false
    }], ["video", {
      reserved: false
    }], ["wbr", {
      reserved: false
    }], ["xmp", {
      reserved: false
    }]];
    var domMap = {
      entries: function entries() {
        return dom2;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator = _createForOfIteratorHelper(dom2), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], values = _step$value[1];
            fn.call(thisArg, values, key, dom2);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      },
      get: function get(key) {
        var item = dom2.find(function(tuple) {
          return tuple[0] === key ? true : false;
        });
        return item && item[1];
      },
      has: function has(key) {
        return !!domMap.get(key);
      },
      keys: function keys() {
        return dom2.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
          return key;
        });
      },
      values: function values() {
        return dom2.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(domMap, domMap.entries());
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/commandRole.js
var require_commandRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/commandRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var commandRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    var _default = commandRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js
var require_compositeRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var compositeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    var _default = compositeRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/inputRole.js
var require_inputRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/inputRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var inputRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "input"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    var _default = inputRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js
var require_landmarkRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var landmarkRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = landmarkRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js
var require_rangeRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rangeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuemax": null,
        "aria-valuemin": null,
        "aria-valuenow": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = rangeRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js
var require_roletypeRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var roletypeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {
        "aria-atomic": null,
        "aria-busy": null,
        "aria-controls": null,
        "aria-current": null,
        "aria-describedby": null,
        "aria-details": null,
        "aria-dropeffect": null,
        "aria-flowto": null,
        "aria-grabbed": null,
        "aria-hidden": null,
        "aria-keyshortcuts": null,
        "aria-label": null,
        "aria-labelledby": null,
        "aria-live": null,
        "aria-owns": null,
        "aria-relevant": null,
        "aria-roledescription": null
      },
      relatedConcepts: [{
        concept: {
          name: "role"
        },
        module: "XHTML"
      }, {
        concept: {
          name: "type"
        },
        module: "Dublin Core"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    var _default = roletypeRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js
var require_sectionRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sectionRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "frontmatter"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "SMIL"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = sectionRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js
var require_sectionheadRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sectionheadRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = sectionheadRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/selectRole.js
var require_selectRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/selectRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var selectRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "group"]]
    };
    var _default = selectRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/structureRole.js
var require_structureRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/structureRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var structureRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    var _default = structureRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js
var require_widgetRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var widgetRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    var _default = widgetRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/abstract/windowRole.js
var require_windowRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/abstract/windowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var windowRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-modal": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    var _default = windowRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js
var require_ariaAbstractRoles = __commonJS({
  "node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _commandRole = _interopRequireDefault(require_commandRole());
    var _compositeRole = _interopRequireDefault(require_compositeRole());
    var _inputRole = _interopRequireDefault(require_inputRole());
    var _landmarkRole = _interopRequireDefault(require_landmarkRole());
    var _rangeRole = _interopRequireDefault(require_rangeRole());
    var _roletypeRole = _interopRequireDefault(require_roletypeRole());
    var _sectionRole = _interopRequireDefault(require_sectionRole());
    var _sectionheadRole = _interopRequireDefault(require_sectionheadRole());
    var _selectRole = _interopRequireDefault(require_selectRole());
    var _structureRole = _interopRequireDefault(require_structureRole());
    var _widgetRole = _interopRequireDefault(require_widgetRole());
    var _windowRole = _interopRequireDefault(require_windowRole());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ariaAbstractRoles = [["command", _commandRole.default], ["composite", _compositeRole.default], ["input", _inputRole.default], ["landmark", _landmarkRole.default], ["range", _rangeRole.default], ["roletype", _roletypeRole.default], ["section", _sectionRole.default], ["sectionhead", _sectionheadRole.default], ["select", _selectRole.default], ["structure", _structureRole.default], ["widget", _widgetRole.default], ["window", _windowRole.default]];
    var _default = ariaAbstractRoles;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/alertRole.js
var require_alertRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/alertRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var alertRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "assertive"
      },
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = alertRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js
var require_alertdialogRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var alertdialogRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "alert"], ["roletype", "window", "dialog"]]
    };
    var _default = alertdialogRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/applicationRole.js
var require_applicationRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/applicationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var applicationRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = applicationRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/articleRole.js
var require_articleRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/articleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var articleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "article"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    };
    var _default = articleRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/bannerRole.js
var require_bannerRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/bannerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var bannerRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "header"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = bannerRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js
var require_blockquoteRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var blockquoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "blockquote"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = blockquoteRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/buttonRole.js
var require_buttonRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/buttonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var buttonRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-pressed": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "button"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "image"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "reset"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "submit"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "button"
        },
        module: "HTML"
      }, {
        concept: {
          name: "trigger"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    var _default = buttonRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/captionRole.js
var require_captionRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/captionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var captionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "caption"
        },
        module: "HTML"
      }],
      requireContextRole: ["figure", "grid", "table"],
      requiredContextRole: ["figure", "grid", "table"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = captionRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/cellRole.js
var require_cellRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/cellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var cellRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-colspan": null,
        "aria-rowindex": null,
        "aria-rowspan": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has table role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = cellRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js
var require_checkboxRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var checkboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "checkbox"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = checkboxRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/codeRole.js
var require_codeRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/codeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var codeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "code"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = codeRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js
var require_columnheaderRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var columnheaderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "col"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "colgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    };
    var _default = columnheaderRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js
var require_comboboxRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var comboboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-expanded": "false",
        "aria-haspopup": "listbox"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "multiple"
          }, {
            constraints: ["undefined"],
            name: "size"
          }],
          constraints: ["the multiple attribute is not set and the size attribute does not have a value greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-expanded": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = comboboxRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js
var require_complementaryRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var complementaryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = complementaryRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js
var require_contentinfoRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var contentinfoRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "footer"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = contentinfoRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/definitionRole.js
var require_definitionRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/definitionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var definitionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dd"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = definitionRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/deletionRole.js
var require_deletionRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/deletionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var deletionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "del"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = deletionRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/dialogRole.js
var require_dialogRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/dialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var dialogRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dialog"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "window"]]
    };
    var _default = dialogRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/directoryRole.js
var require_directoryRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/directoryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var directoryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        module: "DAISY Guide"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    };
    var _default = directoryRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/documentRole.js
var require_documentRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/documentRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var documentRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }, {
        concept: {
          name: "html"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = documentRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js
var require_emphasisRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var emphasisRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "em"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = emphasisRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/feedRole.js
var require_feedRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/feedRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var feedRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["article"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    };
    var _default = feedRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/figureRole.js
var require_figureRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/figureRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var figureRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "figure"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = figureRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/formRole.js
var require_formRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/formRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var formRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "name"
          }],
          name: "form"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = formRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/genericRole.js
var require_genericRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/genericRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var genericRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          name: "area"
        },
        module: "HTML"
      }, {
        concept: {
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          name: "b"
        },
        module: "HTML"
      }, {
        concept: {
          name: "bdo"
        },
        module: "HTML"
      }, {
        concept: {
          name: "body"
        },
        module: "HTML"
      }, {
        concept: {
          name: "data"
        },
        module: "HTML"
      }, {
        concept: {
          name: "div"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "footer"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "header"
        },
        module: "HTML"
      }, {
        concept: {
          name: "hgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "i"
        },
        module: "HTML"
      }, {
        concept: {
          name: "pre"
        },
        module: "HTML"
      }, {
        concept: {
          name: "q"
        },
        module: "HTML"
      }, {
        concept: {
          name: "samp"
        },
        module: "HTML"
      }, {
        concept: {
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "small"
        },
        module: "HTML"
      }, {
        concept: {
          name: "span"
        },
        module: "HTML"
      }, {
        concept: {
          name: "u"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = genericRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/gridRole.js
var require_gridRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/gridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var gridRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-multiselectable": null,
        "aria-readonly": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "table"]]
    };
    var _default = gridRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js
var require_gridcellRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var gridcellRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-selected": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has grid role", "ancestor table element has treegrid role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "widget"]]
    };
    var _default = gridcellRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/groupRole.js
var require_groupRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/groupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var groupRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "details"
        },
        module: "HTML"
      }, {
        concept: {
          name: "fieldset"
        },
        module: "HTML"
      }, {
        concept: {
          name: "optgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "address"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = groupRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/headingRole.js
var require_headingRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/headingRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var headingRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-level": "2"
      },
      relatedConcepts: [{
        concept: {
          name: "h1"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h2"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h3"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h4"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h5"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h6"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-level": "2"
      },
      superClass: [["roletype", "structure", "sectionhead"]]
    };
    var _default = headingRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/imgRole.js
var require_imgRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/imgRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var imgRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          name: "imggroup"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = imgRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/insertionRole.js
var require_insertionRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/insertionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var insertionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "ins"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = insertionRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/linkRole.js
var require_linkRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/linkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var linkRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "area"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    var _default = linkRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/listRole.js
var require_listRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/listRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menu"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ol"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ul"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["listitem"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = listRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/listboxRole.js
var require_listboxRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/listboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: [">1"],
            name: "size"
          }],
          constraints: ["the size attribute value is greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "multiple"
          }],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "datalist"
        },
        module: "HTML"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["option", "group"], ["option"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = listboxRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/listitemRole.js
var require_listitemRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/listitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listitemRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["direct descendant of ol", "direct descendant of ul", "direct descendant of menu"],
          name: "li"
        },
        module: "HTML"
      }, {
        concept: {
          name: "item"
        },
        module: "XForms"
      }],
      requireContextRole: ["directory", "list"],
      requiredContextRole: ["directory", "list"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = listitemRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/logRole.js
var require_logRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/logRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var logRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-live": "polite"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = logRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/mainRole.js
var require_mainRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/mainRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var mainRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "main"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = mainRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/markRole.js
var require_markRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/markRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var markRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null
      },
      relatedConcepts: [{
        concept: {
          name: "mark"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = markRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js
var require_marqueeRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var marqueeRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = marqueeRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/mathRole.js
var require_mathRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/mathRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var mathRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "math"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = mathRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/menuRole.js
var require_menuRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/menuRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          name: "MENU"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }, {
        concept: {
          name: "sidebar"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = menuRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/menubarRole.js
var require_menubarRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/menubarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menubarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "toolbar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select", "menu"], ["roletype", "structure", "section", "group", "select", "menu"]]
    };
    var _default = menubarRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js
var require_menuitemRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "MENU_ITEM"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    var _default = menuitemRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js
var require_menuitemcheckboxRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemcheckboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"], ["roletype", "widget", "command", "menuitem"]]
    };
    var _default = menuitemcheckboxRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js
var require_menuitemradioRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemradioRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox", "menuitemcheckbox"], ["roletype", "widget", "command", "menuitem", "menuitemcheckbox"], ["roletype", "widget", "input", "radio"]]
    };
    var _default = menuitemradioRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/meterRole.js
var require_meterRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/meterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var meterRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null,
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          name: "meter"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"]]
    };
    var _default = meterRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/navigationRole.js
var require_navigationRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/navigationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var navigationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "nav"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = navigationRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/noneRole.js
var require_noneRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/noneRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var noneRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    var _default = noneRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/noteRole.js
var require_noteRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/noteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var noteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = noteRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/optionRole.js
var require_optionRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/optionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var optionRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [{
        concept: {
          name: "item"
        },
        module: "XForms"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = optionRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js
var require_paragraphRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var paragraphRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "p"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = paragraphRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/presentationRole.js
var require_presentationRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/presentationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var presentationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "alt",
            value: ""
          }],
          name: "img"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = presentationRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js
var require_progressbarRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var progressbarRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "progress"
        },
        module: "HTML"
      }, {
        concept: {
          name: "status"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    };
    var _default = progressbarRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/radioRole.js
var require_radioRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/radioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var radioRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "radio"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = radioRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js
var require_radiogroupRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var radiogroupRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          name: "list"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["radio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = radiogroupRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/regionRole.js
var require_regionRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/regionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var regionRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "Device Independence Glossart perceivable unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = regionRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/rowRole.js
var require_rowRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/rowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-expanded": null,
        "aria-level": null,
        "aria-posinset": null,
        "aria-rowindex": null,
        "aria-selected": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "tr"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredOwnedElements: [["cell"], ["columnheader"], ["gridcell"], ["rowheader"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"], ["roletype", "widget"]]
    };
    var _default = rowRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js
var require_rowgroupRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowgroupRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "tbody"
        },
        module: "HTML"
      }, {
        concept: {
          name: "tfoot"
        },
        module: "HTML"
      }, {
        concept: {
          name: "thead"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "table", "treegrid"],
      requiredContextRole: ["grid", "table", "treegrid"],
      requiredOwnedElements: [["row"]],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = rowgroupRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js
var require_rowheaderRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowheaderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "scope",
            value: "row"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "rowgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row", "rowgroup"],
      requiredContextRole: ["row", "rowgroup"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    };
    var _default = rowheaderRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js
var require_scrollbarRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var scrollbarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-valuetext": null,
        "aria-orientation": "vertical",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    };
    var _default = scrollbarRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/searchRole.js
var require_searchRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/searchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var searchRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = searchRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js
var require_searchboxRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var searchboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input", "textbox"]]
    };
    var _default = searchboxRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/separatorRole.js
var require_separatorRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/separatorRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var separatorRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0",
        "aria-valuenow": null,
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "hr"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = separatorRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/sliderRole.js
var require_sliderRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/sliderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sliderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-valuetext": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "range"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    };
    var _default = sliderRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js
var require_spinbuttonRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var spinbuttonRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-valuetext": null,
        "aria-valuenow": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "number"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    };
    var _default = spinbuttonRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/statusRole.js
var require_statusRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/statusRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var statusRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "polite"
      },
      relatedConcepts: [{
        concept: {
          name: "output"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = statusRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/strongRole.js
var require_strongRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/strongRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var strongRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "strong"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = strongRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js
var require_subscriptRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var subscriptRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sub"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = subscriptRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js
var require_superscriptRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var superscriptRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sup"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = superscriptRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/switchRole.js
var require_switchRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/switchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var switchRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "button"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"]]
    };
    var _default = switchRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/tabRole.js
var require_tabRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/tabRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tabRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [],
      requireContextRole: ["tablist"],
      requiredContextRole: ["tablist"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"], ["roletype", "widget"]]
    };
    var _default = tabRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/tableRole.js
var require_tableRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/tableRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tableRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-colcount": null,
        "aria-rowcount": null
      },
      relatedConcepts: [{
        concept: {
          name: "table"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = tableRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/tablistRole.js
var require_tablistRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/tablistRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tablistRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-multiselectable": null,
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        module: "DAISY",
        concept: {
          name: "guide"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["tab"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"]]
    };
    var _default = tablistRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js
var require_tabpanelRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tabpanelRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = tabpanelRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/termRole.js
var require_termRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/termRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var termRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dfn"
        },
        module: "HTML"
      }, {
        concept: {
          name: "dt"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = termRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/textboxRole.js
var require_textboxRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/textboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var textboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-multiline": null,
        "aria-placeholder": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "type"
          }, {
            constraints: ["undefined"],
            name: "list"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "input"
        },
        module: "XForms"
      }, {
        concept: {
          name: "textarea"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = textboxRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/timeRole.js
var require_timeRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/timeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var timeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "time"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = timeRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/timerRole.js
var require_timerRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/timerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var timerRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "status"]]
    };
    var _default = timerRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js
var require_toolbarRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var toolbarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "menubar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    };
    var _default = toolbarRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js
var require_tooltipRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tooltipRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = tooltipRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/treeRole.js
var require_treeRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/treeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treeRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["treeitem", "group"], ["treeitem"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = treeRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/treegridRole.js
var require_treegridRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/treegridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treegridRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "grid"], ["roletype", "structure", "section", "table", "grid"], ["roletype", "widget", "composite", "select", "tree"], ["roletype", "structure", "section", "group", "select", "tree"]]
    };
    var _default = treegridRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js
var require_treeitemRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treeitemRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [],
      requireContextRole: ["group", "tree"],
      requiredContextRole: ["group", "tree"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": null
      },
      superClass: [["roletype", "structure", "section", "listitem"], ["roletype", "widget", "input", "option"]]
    };
    var _default = treeitemRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js
var require_ariaLiteralRoles = __commonJS({
  "node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _alertRole = _interopRequireDefault(require_alertRole());
    var _alertdialogRole = _interopRequireDefault(require_alertdialogRole());
    var _applicationRole = _interopRequireDefault(require_applicationRole());
    var _articleRole = _interopRequireDefault(require_articleRole());
    var _bannerRole = _interopRequireDefault(require_bannerRole());
    var _blockquoteRole = _interopRequireDefault(require_blockquoteRole());
    var _buttonRole = _interopRequireDefault(require_buttonRole());
    var _captionRole = _interopRequireDefault(require_captionRole());
    var _cellRole = _interopRequireDefault(require_cellRole());
    var _checkboxRole = _interopRequireDefault(require_checkboxRole());
    var _codeRole = _interopRequireDefault(require_codeRole());
    var _columnheaderRole = _interopRequireDefault(require_columnheaderRole());
    var _comboboxRole = _interopRequireDefault(require_comboboxRole());
    var _complementaryRole = _interopRequireDefault(require_complementaryRole());
    var _contentinfoRole = _interopRequireDefault(require_contentinfoRole());
    var _definitionRole = _interopRequireDefault(require_definitionRole());
    var _deletionRole = _interopRequireDefault(require_deletionRole());
    var _dialogRole = _interopRequireDefault(require_dialogRole());
    var _directoryRole = _interopRequireDefault(require_directoryRole());
    var _documentRole = _interopRequireDefault(require_documentRole());
    var _emphasisRole = _interopRequireDefault(require_emphasisRole());
    var _feedRole = _interopRequireDefault(require_feedRole());
    var _figureRole = _interopRequireDefault(require_figureRole());
    var _formRole = _interopRequireDefault(require_formRole());
    var _genericRole = _interopRequireDefault(require_genericRole());
    var _gridRole = _interopRequireDefault(require_gridRole());
    var _gridcellRole = _interopRequireDefault(require_gridcellRole());
    var _groupRole = _interopRequireDefault(require_groupRole());
    var _headingRole = _interopRequireDefault(require_headingRole());
    var _imgRole = _interopRequireDefault(require_imgRole());
    var _insertionRole = _interopRequireDefault(require_insertionRole());
    var _linkRole = _interopRequireDefault(require_linkRole());
    var _listRole = _interopRequireDefault(require_listRole());
    var _listboxRole = _interopRequireDefault(require_listboxRole());
    var _listitemRole = _interopRequireDefault(require_listitemRole());
    var _logRole = _interopRequireDefault(require_logRole());
    var _mainRole = _interopRequireDefault(require_mainRole());
    var _markRole = _interopRequireDefault(require_markRole());
    var _marqueeRole = _interopRequireDefault(require_marqueeRole());
    var _mathRole = _interopRequireDefault(require_mathRole());
    var _menuRole = _interopRequireDefault(require_menuRole());
    var _menubarRole = _interopRequireDefault(require_menubarRole());
    var _menuitemRole = _interopRequireDefault(require_menuitemRole());
    var _menuitemcheckboxRole = _interopRequireDefault(require_menuitemcheckboxRole());
    var _menuitemradioRole = _interopRequireDefault(require_menuitemradioRole());
    var _meterRole = _interopRequireDefault(require_meterRole());
    var _navigationRole = _interopRequireDefault(require_navigationRole());
    var _noneRole = _interopRequireDefault(require_noneRole());
    var _noteRole = _interopRequireDefault(require_noteRole());
    var _optionRole = _interopRequireDefault(require_optionRole());
    var _paragraphRole = _interopRequireDefault(require_paragraphRole());
    var _presentationRole = _interopRequireDefault(require_presentationRole());
    var _progressbarRole = _interopRequireDefault(require_progressbarRole());
    var _radioRole = _interopRequireDefault(require_radioRole());
    var _radiogroupRole = _interopRequireDefault(require_radiogroupRole());
    var _regionRole = _interopRequireDefault(require_regionRole());
    var _rowRole = _interopRequireDefault(require_rowRole());
    var _rowgroupRole = _interopRequireDefault(require_rowgroupRole());
    var _rowheaderRole = _interopRequireDefault(require_rowheaderRole());
    var _scrollbarRole = _interopRequireDefault(require_scrollbarRole());
    var _searchRole = _interopRequireDefault(require_searchRole());
    var _searchboxRole = _interopRequireDefault(require_searchboxRole());
    var _separatorRole = _interopRequireDefault(require_separatorRole());
    var _sliderRole = _interopRequireDefault(require_sliderRole());
    var _spinbuttonRole = _interopRequireDefault(require_spinbuttonRole());
    var _statusRole = _interopRequireDefault(require_statusRole());
    var _strongRole = _interopRequireDefault(require_strongRole());
    var _subscriptRole = _interopRequireDefault(require_subscriptRole());
    var _superscriptRole = _interopRequireDefault(require_superscriptRole());
    var _switchRole = _interopRequireDefault(require_switchRole());
    var _tabRole = _interopRequireDefault(require_tabRole());
    var _tableRole = _interopRequireDefault(require_tableRole());
    var _tablistRole = _interopRequireDefault(require_tablistRole());
    var _tabpanelRole = _interopRequireDefault(require_tabpanelRole());
    var _termRole = _interopRequireDefault(require_termRole());
    var _textboxRole = _interopRequireDefault(require_textboxRole());
    var _timeRole = _interopRequireDefault(require_timeRole());
    var _timerRole = _interopRequireDefault(require_timerRole());
    var _toolbarRole = _interopRequireDefault(require_toolbarRole());
    var _tooltipRole = _interopRequireDefault(require_tooltipRole());
    var _treeRole = _interopRequireDefault(require_treeRole());
    var _treegridRole = _interopRequireDefault(require_treegridRole());
    var _treeitemRole = _interopRequireDefault(require_treeitemRole());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ariaLiteralRoles = [["alert", _alertRole.default], ["alertdialog", _alertdialogRole.default], ["application", _applicationRole.default], ["article", _articleRole.default], ["banner", _bannerRole.default], ["blockquote", _blockquoteRole.default], ["button", _buttonRole.default], ["caption", _captionRole.default], ["cell", _cellRole.default], ["checkbox", _checkboxRole.default], ["code", _codeRole.default], ["columnheader", _columnheaderRole.default], ["combobox", _comboboxRole.default], ["complementary", _complementaryRole.default], ["contentinfo", _contentinfoRole.default], ["definition", _definitionRole.default], ["deletion", _deletionRole.default], ["dialog", _dialogRole.default], ["directory", _directoryRole.default], ["document", _documentRole.default], ["emphasis", _emphasisRole.default], ["feed", _feedRole.default], ["figure", _figureRole.default], ["form", _formRole.default], ["generic", _genericRole.default], ["grid", _gridRole.default], ["gridcell", _gridcellRole.default], ["group", _groupRole.default], ["heading", _headingRole.default], ["img", _imgRole.default], ["insertion", _insertionRole.default], ["link", _linkRole.default], ["list", _listRole.default], ["listbox", _listboxRole.default], ["listitem", _listitemRole.default], ["log", _logRole.default], ["main", _mainRole.default], ["mark", _markRole.default], ["marquee", _marqueeRole.default], ["math", _mathRole.default], ["menu", _menuRole.default], ["menubar", _menubarRole.default], ["menuitem", _menuitemRole.default], ["menuitemcheckbox", _menuitemcheckboxRole.default], ["menuitemradio", _menuitemradioRole.default], ["meter", _meterRole.default], ["navigation", _navigationRole.default], ["none", _noneRole.default], ["note", _noteRole.default], ["option", _optionRole.default], ["paragraph", _paragraphRole.default], ["presentation", _presentationRole.default], ["progressbar", _progressbarRole.default], ["radio", _radioRole.default], ["radiogroup", _radiogroupRole.default], ["region", _regionRole.default], ["row", _rowRole.default], ["rowgroup", _rowgroupRole.default], ["rowheader", _rowheaderRole.default], ["scrollbar", _scrollbarRole.default], ["search", _searchRole.default], ["searchbox", _searchboxRole.default], ["separator", _separatorRole.default], ["slider", _sliderRole.default], ["spinbutton", _spinbuttonRole.default], ["status", _statusRole.default], ["strong", _strongRole.default], ["subscript", _subscriptRole.default], ["superscript", _superscriptRole.default], ["switch", _switchRole.default], ["tab", _tabRole.default], ["table", _tableRole.default], ["tablist", _tablistRole.default], ["tabpanel", _tabpanelRole.default], ["term", _termRole.default], ["textbox", _textboxRole.default], ["time", _timeRole.default], ["timer", _timerRole.default], ["toolbar", _toolbarRole.default], ["tooltip", _tooltipRole.default], ["tree", _treeRole.default], ["treegrid", _treegridRole.default], ["treeitem", _treeitemRole.default]];
    var _default = ariaLiteralRoles;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js
var require_docAbstractRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAbstractRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "abstract [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = docAbstractRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js
var require_docAcknowledgmentsRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAcknowledgmentsRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "acknowledgments [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docAcknowledgmentsRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js
var require_docAfterwordRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAfterwordRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "afterword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docAfterwordRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js
var require_docAppendixRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAppendixRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "appendix [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docAppendixRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js
var require_docBacklinkRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBacklinkRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "referrer [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = docBacklinkRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js
var require_docBiblioentryRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBiblioentryRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "EPUB biblioentry [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-bibliography"],
      requiredContextRole: ["doc-bibliography"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    };
    var _default = docBiblioentryRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js
var require_docBibliographyRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBibliographyRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "bibliography [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-biblioentry"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docBibliographyRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js
var require_docBibliorefRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBibliorefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "biblioref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = docBibliorefRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js
var require_docChapterRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docChapterRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "chapter [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docChapterRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js
var require_docColophonRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docColophonRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "colophon [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = docColophonRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js
var require_docConclusionRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docConclusionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "conclusion [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docConclusionRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js
var require_docCoverRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCoverRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "cover [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    };
    var _default = docCoverRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js
var require_docCreditRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCreditRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credit [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = docCreditRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js
var require_docCreditsRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCreditsRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credits [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docCreditsRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js
var require_docDedicationRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docDedicationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "dedication [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = docDedicationRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js
var require_docEndnoteRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEndnoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-endnotes"],
      requiredContextRole: ["doc-endnotes"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    };
    var _default = docEndnoteRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js
var require_docEndnotesRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEndnotesRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnotes [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-endnote"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docEndnotesRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js
var require_docEpigraphRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEpigraphRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epigraph [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = docEpigraphRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js
var require_docEpilogueRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEpilogueRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epilogue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docEpilogueRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js
var require_docErrataRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docErrataRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "errata [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docErrataRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js
var require_docExampleRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docExampleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = docExampleRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js
var require_docFootnoteRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docFootnoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "footnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = docFootnoteRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js
var require_docForewordRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docForewordRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "foreword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docForewordRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js
var require_docGlossaryRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docGlossaryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossary [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["definition"], ["term"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docGlossaryRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js
var require_docGlossrefRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docGlossrefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = docGlossrefRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js
var require_docIndexRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docIndexRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "index [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    var _default = docIndexRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js
var require_docIntroductionRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docIntroductionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "introduction [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docIntroductionRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js
var require_docNoterefRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docNoterefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "noteref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = docNoterefRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js
var require_docNoticeRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docNoticeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "notice [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    };
    var _default = docNoticeRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js
var require_docPagebreakRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPagebreakRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "pagebreak [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "separator"]]
    };
    var _default = docPagebreakRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js
var require_docPagelistRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPagelistRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "page-list [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    var _default = docPagelistRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js
var require_docPartRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPartRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "part [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docPartRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js
var require_docPrefaceRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPrefaceRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "preface [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docPrefaceRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js
var require_docPrologueRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPrologueRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "prologue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docPrologueRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js
var require_docPullquoteRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPullquoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "pullquote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["none"]]
    };
    var _default = docPullquoteRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js
var require_docQnaRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docQnaRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "qna [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = docQnaRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js
var require_docSubtitleRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docSubtitleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "subtitle [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"]]
    };
    var _default = docSubtitleRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js
var require_docTipRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docTipRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "help [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    };
    var _default = docTipRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js
var require_docTocRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docTocRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "toc [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    var _default = docTocRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js
var require_ariaDpubRoles = __commonJS({
  "node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _docAbstractRole = _interopRequireDefault(require_docAbstractRole());
    var _docAcknowledgmentsRole = _interopRequireDefault(require_docAcknowledgmentsRole());
    var _docAfterwordRole = _interopRequireDefault(require_docAfterwordRole());
    var _docAppendixRole = _interopRequireDefault(require_docAppendixRole());
    var _docBacklinkRole = _interopRequireDefault(require_docBacklinkRole());
    var _docBiblioentryRole = _interopRequireDefault(require_docBiblioentryRole());
    var _docBibliographyRole = _interopRequireDefault(require_docBibliographyRole());
    var _docBibliorefRole = _interopRequireDefault(require_docBibliorefRole());
    var _docChapterRole = _interopRequireDefault(require_docChapterRole());
    var _docColophonRole = _interopRequireDefault(require_docColophonRole());
    var _docConclusionRole = _interopRequireDefault(require_docConclusionRole());
    var _docCoverRole = _interopRequireDefault(require_docCoverRole());
    var _docCreditRole = _interopRequireDefault(require_docCreditRole());
    var _docCreditsRole = _interopRequireDefault(require_docCreditsRole());
    var _docDedicationRole = _interopRequireDefault(require_docDedicationRole());
    var _docEndnoteRole = _interopRequireDefault(require_docEndnoteRole());
    var _docEndnotesRole = _interopRequireDefault(require_docEndnotesRole());
    var _docEpigraphRole = _interopRequireDefault(require_docEpigraphRole());
    var _docEpilogueRole = _interopRequireDefault(require_docEpilogueRole());
    var _docErrataRole = _interopRequireDefault(require_docErrataRole());
    var _docExampleRole = _interopRequireDefault(require_docExampleRole());
    var _docFootnoteRole = _interopRequireDefault(require_docFootnoteRole());
    var _docForewordRole = _interopRequireDefault(require_docForewordRole());
    var _docGlossaryRole = _interopRequireDefault(require_docGlossaryRole());
    var _docGlossrefRole = _interopRequireDefault(require_docGlossrefRole());
    var _docIndexRole = _interopRequireDefault(require_docIndexRole());
    var _docIntroductionRole = _interopRequireDefault(require_docIntroductionRole());
    var _docNoterefRole = _interopRequireDefault(require_docNoterefRole());
    var _docNoticeRole = _interopRequireDefault(require_docNoticeRole());
    var _docPagebreakRole = _interopRequireDefault(require_docPagebreakRole());
    var _docPagelistRole = _interopRequireDefault(require_docPagelistRole());
    var _docPartRole = _interopRequireDefault(require_docPartRole());
    var _docPrefaceRole = _interopRequireDefault(require_docPrefaceRole());
    var _docPrologueRole = _interopRequireDefault(require_docPrologueRole());
    var _docPullquoteRole = _interopRequireDefault(require_docPullquoteRole());
    var _docQnaRole = _interopRequireDefault(require_docQnaRole());
    var _docSubtitleRole = _interopRequireDefault(require_docSubtitleRole());
    var _docTipRole = _interopRequireDefault(require_docTipRole());
    var _docTocRole = _interopRequireDefault(require_docTocRole());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ariaDpubRoles = [["doc-abstract", _docAbstractRole.default], ["doc-acknowledgments", _docAcknowledgmentsRole.default], ["doc-afterword", _docAfterwordRole.default], ["doc-appendix", _docAppendixRole.default], ["doc-backlink", _docBacklinkRole.default], ["doc-biblioentry", _docBiblioentryRole.default], ["doc-bibliography", _docBibliographyRole.default], ["doc-biblioref", _docBibliorefRole.default], ["doc-chapter", _docChapterRole.default], ["doc-colophon", _docColophonRole.default], ["doc-conclusion", _docConclusionRole.default], ["doc-cover", _docCoverRole.default], ["doc-credit", _docCreditRole.default], ["doc-credits", _docCreditsRole.default], ["doc-dedication", _docDedicationRole.default], ["doc-endnote", _docEndnoteRole.default], ["doc-endnotes", _docEndnotesRole.default], ["doc-epigraph", _docEpigraphRole.default], ["doc-epilogue", _docEpilogueRole.default], ["doc-errata", _docErrataRole.default], ["doc-example", _docExampleRole.default], ["doc-footnote", _docFootnoteRole.default], ["doc-foreword", _docForewordRole.default], ["doc-glossary", _docGlossaryRole.default], ["doc-glossref", _docGlossrefRole.default], ["doc-index", _docIndexRole.default], ["doc-introduction", _docIntroductionRole.default], ["doc-noteref", _docNoterefRole.default], ["doc-notice", _docNoticeRole.default], ["doc-pagebreak", _docPagebreakRole.default], ["doc-pagelist", _docPagelistRole.default], ["doc-part", _docPartRole.default], ["doc-preface", _docPrefaceRole.default], ["doc-prologue", _docPrologueRole.default], ["doc-pullquote", _docPullquoteRole.default], ["doc-qna", _docQnaRole.default], ["doc-subtitle", _docSubtitleRole.default], ["doc-tip", _docTipRole.default], ["doc-toc", _docTocRole.default]];
    var _default = ariaDpubRoles;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js
var require_graphicsDocumentRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsDocumentRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-object"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "article"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    };
    var _default = graphicsDocumentRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js
var require_graphicsObjectRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsObjectRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-document"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "group"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "GRAPHICS",
        concept: {
          name: "graphics-symbol"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    };
    var _default = graphicsObjectRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js
var require_graphicsSymbolRole = __commonJS({
  "node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsSymbolRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    };
    var _default = graphicsSymbolRole;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js
var require_ariaGraphicsRoles = __commonJS({
  "node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _graphicsDocumentRole = _interopRequireDefault(require_graphicsDocumentRole());
    var _graphicsObjectRole = _interopRequireDefault(require_graphicsObjectRole());
    var _graphicsSymbolRole = _interopRequireDefault(require_graphicsSymbolRole());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ariaGraphicsRoles = [["graphics-document", _graphicsDocumentRole.default], ["graphics-object", _graphicsObjectRole.default], ["graphics-symbol", _graphicsSymbolRole.default]];
    var _default = ariaGraphicsRoles;
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/rolesMap.js
var require_rolesMap = __commonJS({
  "node_modules/aria-query/lib/rolesMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _ariaAbstractRoles = _interopRequireDefault(require_ariaAbstractRoles());
    var _ariaLiteralRoles = _interopRequireDefault(require_ariaLiteralRoles());
    var _ariaDpubRoles = _interopRequireDefault(require_ariaDpubRoles());
    var _ariaGraphicsRoles = _interopRequireDefault(require_ariaGraphicsRoles());
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F4 = function F5() {
          };
          return { s: F4, n: function n2() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e2) {
            throw _e2;
          }, f: F4 };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    var roles2 = [].concat(_ariaAbstractRoles.default, _ariaLiteralRoles.default, _ariaDpubRoles.default, _ariaGraphicsRoles.default);
    roles2.forEach(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 2), roleDefinition = _ref2[1];
      var _iterator = _createForOfIteratorHelper(roleDefinition.superClass), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var superClassIter = _step.value;
          var _iterator2 = _createForOfIteratorHelper(superClassIter), _step2;
          try {
            var _loop = function _loop2() {
              var superClassName = _step2.value;
              var superClassRoleTuple = roles2.find(function(_ref3) {
                var _ref4 = _slicedToArray(_ref3, 1), name49 = _ref4[0];
                return name49 === superClassName;
              });
              if (superClassRoleTuple) {
                var superClassDefinition = superClassRoleTuple[1];
                for (var _i2 = 0, _Object$keys = Object.keys(superClassDefinition.props); _i2 < _Object$keys.length; _i2++) {
                  var prop = _Object$keys[_i2];
                  if (
                    // $FlowIssue Accessing the hasOwnProperty on the Object prototype is fine.
                    !Object.prototype.hasOwnProperty.call(roleDefinition.props, prop)
                  ) {
                    Object.assign(roleDefinition.props, _defineProperty({}, prop, superClassDefinition.props[prop]));
                  }
                }
              }
            };
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              _loop();
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    });
    var rolesMap = {
      entries: function entries() {
        return roles2;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator3 = _createForOfIteratorHelper(roles2), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var _step3$value = _slicedToArray(_step3.value, 2), key = _step3$value[0], values = _step3$value[1];
            fn.call(thisArg, values, key, roles2);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      },
      get: function get(key) {
        var item = roles2.find(function(tuple) {
          return tuple[0] === key ? true : false;
        });
        return item && item[1];
      },
      has: function has(key) {
        return !!rolesMap.get(key);
      },
      keys: function keys() {
        return roles2.map(function(_ref5) {
          var _ref6 = _slicedToArray(_ref5, 1), key = _ref6[0];
          return key;
        });
      },
      values: function values() {
        return roles2.map(function(_ref7) {
          var _ref8 = _slicedToArray(_ref7, 2), values2 = _ref8[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(rolesMap, rolesMap.entries());
    exports.default = _default;
  }
});

// node_modules/dequal/lite/index.js
var require_lite = __commonJS({
  "node_modules/dequal/lite/index.js"(exports) {
    var has = Object.prototype.hasOwnProperty;
    function dequal(foo, bar) {
      var ctor, len;
      if (foo === bar)
        return true;
      if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
        if (ctor === Date)
          return foo.getTime() === bar.getTime();
        if (ctor === RegExp)
          return foo.toString() === bar.toString();
        if (ctor === Array) {
          if ((len = foo.length) === bar.length) {
            while (len-- && dequal(foo[len], bar[len]))
              ;
          }
          return len === -1;
        }
        if (!ctor || typeof foo === "object") {
          len = 0;
          for (ctor in foo) {
            if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))
              return false;
            if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))
              return false;
          }
          return Object.keys(bar).length === len;
        }
      }
      return foo !== foo && bar !== bar;
    }
    exports.dequal = dequal;
  }
});

// node_modules/aria-query/lib/elementRoleMap.js
var require_elementRoleMap = __commonJS({
  "node_modules/aria-query/lib/elementRoleMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _lite = require_lite();
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    var _rolesMap = _interopRequireDefault(require_rolesMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i2) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i2 = 0;
          var F4 = function F5() {
          };
          return { s: F4, n: function n2() {
            if (i2 >= o.length)
              return { done: true };
            return { done: false, value: o[i2++] };
          }, e: function e(_e2) {
            throw _e2;
          }, f: F4 };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
        arr2[i2] = arr[i2];
      }
      return arr2;
    }
    var elementRoles2 = [];
    var keys = _rolesMap.default.keys();
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      role = _rolesMap.default.get(key);
      if (role) {
        concepts = [].concat(role.baseConcepts, role.relatedConcepts);
        for (k = 0; k < concepts.length; k++) {
          relation = concepts[k];
          if (relation.module === "HTML") {
            (function() {
              var concept = relation.concept;
              if (concept) {
                var elementRoleRelation = elementRoles2.find(function(relation2) {
                  return (0, _lite.dequal)(relation2, concept);
                });
                var roles2;
                if (elementRoleRelation) {
                  roles2 = elementRoleRelation[1];
                } else {
                  roles2 = [];
                }
                var isUnique = true;
                for (var _i = 0; _i < roles2.length; _i++) {
                  if (roles2[_i] === key) {
                    isUnique = false;
                    break;
                  }
                }
                if (isUnique) {
                  roles2.push(key);
                }
                elementRoles2.push([concept, roles2]);
              }
            })();
          }
        }
      }
    }
    var key;
    var role;
    var concepts;
    var relation;
    var k;
    var i;
    var elementRoleMap = {
      entries: function entries() {
        return elementRoles2;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator = _createForOfIteratorHelper(elementRoles2), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray(_step.value, 2), _key = _step$value[0], values = _step$value[1];
            fn.call(thisArg, values, _key, elementRoles2);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      },
      get: function get(key2) {
        var item = elementRoles2.find(function(tuple) {
          return key2.name === tuple[0].name && (0, _lite.dequal)(key2.attributes, tuple[0].attributes);
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!elementRoleMap.get(key2);
      },
      keys: function keys2() {
        return elementRoles2.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return elementRoles2.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(elementRoleMap, elementRoleMap.entries());
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/roleElementMap.js
var require_roleElementMap = __commonJS({
  "node_modules/aria-query/lib/roleElementMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    var _rolesMap = _interopRequireDefault(require_rolesMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i2) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i2 = 0;
          var F4 = function F5() {
          };
          return { s: F4, n: function n2() {
            if (i2 >= o.length)
              return { done: true };
            return { done: false, value: o[i2++] };
          }, e: function e(_e2) {
            throw _e2;
          }, f: F4 };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
        arr2[i2] = arr[i2];
      }
      return arr2;
    }
    var roleElement = [];
    var keys = _rolesMap.default.keys();
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      role = _rolesMap.default.get(key);
      relationConcepts = [];
      if (role) {
        concepts = [].concat(role.baseConcepts, role.relatedConcepts);
        for (k = 0; k < concepts.length; k++) {
          relation = concepts[k];
          if (relation.module === "HTML") {
            concept = relation.concept;
            if (concept != null) {
              relationConcepts.push(concept);
            }
          }
        }
        if (relationConcepts.length > 0) {
          roleElement.push([key, relationConcepts]);
        }
      }
    }
    var key;
    var role;
    var relationConcepts;
    var concepts;
    var relation;
    var concept;
    var k;
    var i;
    var roleElementMap = {
      entries: function entries() {
        return roleElement;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator = _createForOfIteratorHelper(roleElement), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray(_step.value, 2), _key = _step$value[0], values = _step$value[1];
            fn.call(thisArg, values, _key, roleElement);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      },
      get: function get(key2) {
        var item = roleElement.find(function(tuple) {
          return tuple[0] === key2 ? true : false;
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!roleElementMap.get(key2);
      },
      keys: function keys2() {
        return roleElement.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return roleElement.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(roleElementMap, roleElementMap.entries());
    exports.default = _default;
  }
});

// node_modules/aria-query/lib/index.js
var require_lib = __commonJS({
  "node_modules/aria-query/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.roles = exports.roleElements = exports.elementRoles = exports.dom = exports.aria = void 0;
    var _ariaPropsMap = _interopRequireDefault(require_ariaPropsMap());
    var _domMap = _interopRequireDefault(require_domMap());
    var _rolesMap = _interopRequireDefault(require_rolesMap());
    var _elementRoleMap = _interopRequireDefault(require_elementRoleMap());
    var _roleElementMap = _interopRequireDefault(require_roleElementMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var aria2 = _ariaPropsMap.default;
    exports.aria = aria2;
    var dom2 = _domMap.default;
    exports.dom = dom2;
    var roles2 = _rolesMap.default;
    exports.roles = roles2;
    var elementRoles2 = _elementRoleMap.default;
    exports.elementRoles = elementRoles2;
    var roleElements = _roleElementMap.default;
    exports.roleElements = roleElements;
  }
});

// node_modules/axobject-query/lib/util/iteratorProxy.js
var require_iteratorProxy2 = __commonJS({
  "node_modules/axobject-query/lib/util/iteratorProxy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function iteratorProxy() {
      var values = this;
      var index = 0;
      var iter = {
        "@@iterator": function iterator() {
          return iter;
        },
        next: function next() {
          if (index < values.length) {
            var value = values[index];
            index = index + 1;
            return {
              done: false,
              value
            };
          } else {
            return {
              done: true
            };
          }
        }
      };
      return iter;
    }
    var _default = iteratorProxy;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/util/iterationDecorator.js
var require_iterationDecorator2 = __commonJS({
  "node_modules/axobject-query/lib/util/iterationDecorator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = iterationDecorator;
    var _iteratorProxy = _interopRequireDefault(require_iteratorProxy2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function iterationDecorator(collection, entries) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
        Object.defineProperty(collection, Symbol.iterator, {
          value: _iteratorProxy.default.bind(entries)
        });
      }
      return collection;
    }
  }
});

// node_modules/axobject-query/lib/etc/objects/AbbrRole.js
var require_AbbrRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/AbbrRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AbbrRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "abbr"
        }
      }],
      type: "structure"
    };
    var _default = AbbrRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/AlertDialogRole.js
var require_AlertDialogRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/AlertDialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AlertDialogRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "alertdialog"
        }
      }],
      type: "window"
    };
    var _default = AlertDialogRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/AlertRole.js
var require_AlertRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/AlertRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AlertRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "alert"
        }
      }],
      type: "structure"
    };
    var _default = AlertRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/AnnotationRole.js
var require_AnnotationRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/AnnotationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AnnotationRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = AnnotationRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ApplicationRole.js
var require_ApplicationRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ApplicationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ApplicationRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "application"
        }
      }],
      type: "window"
    };
    var _default = ApplicationRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ArticleRole.js
var require_ArticleRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ArticleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ArticleRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "article"
        }
      }, {
        module: "HTML",
        concept: {
          name: "article"
        }
      }],
      type: "structure"
    };
    var _default = ArticleRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/AudioRole.js
var require_AudioRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/AudioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AudioRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "audio"
        }
      }],
      type: "widget"
    };
    var _default = AudioRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/BannerRole.js
var require_BannerRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/BannerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var BannerRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "banner"
        }
      }],
      type: "structure"
    };
    var _default = BannerRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/BlockquoteRole.js
var require_BlockquoteRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/BlockquoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var BlockquoteRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "blockquote"
        }
      }],
      type: "structure"
    };
    var _default = BlockquoteRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/BusyIndicatorRole.js
var require_BusyIndicatorRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/BusyIndicatorRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var BusyIndicatorRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          attributes: [{
            name: "aria-busy",
            value: "true"
          }]
        }
      }],
      type: "widget"
    };
    var _default = BusyIndicatorRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ButtonRole.js
var require_ButtonRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ButtonRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "button"
        }
      }, {
        module: "HTML",
        concept: {
          name: "button"
        }
      }],
      type: "widget"
    };
    var _default = ButtonRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/CanvasRole.js
var require_CanvasRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/CanvasRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var CanvasRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "canvas"
        }
      }],
      type: "widget"
    };
    var _default = CanvasRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/CaptionRole.js
var require_CaptionRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/CaptionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var CaptionRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "caption"
        }
      }],
      type: "structure"
    };
    var _default = CaptionRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/CellRole.js
var require_CellRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/CellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var CellRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "cell"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "gridcell"
        }
      }, {
        module: "HTML",
        concept: {
          name: "td"
        }
      }],
      type: "widget"
    };
    var _default = CellRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/CheckBoxRole.js
var require_CheckBoxRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/CheckBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var CheckBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "checkbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "checkbox"
          }]
        }
      }],
      type: "widget"
    };
    var _default = CheckBoxRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ColorWellRole.js
var require_ColorWellRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ColorWellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ColorWellRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "color"
          }]
        }
      }],
      type: "widget"
    };
    var _default = ColorWellRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ColumnHeaderRole.js
var require_ColumnHeaderRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ColumnHeaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ColumnHeaderRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "columnheader"
        }
      }, {
        module: "HTML",
        concept: {
          name: "th"
        }
      }],
      type: "widget"
    };
    var _default = ColumnHeaderRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ColumnRole.js
var require_ColumnRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ColumnRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ColumnRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = ColumnRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ComboBoxRole.js
var require_ComboBoxRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ComboBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ComboBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "combobox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "select"
        }
      }],
      type: "widget"
    };
    var _default = ComboBoxRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ComplementaryRole.js
var require_ComplementaryRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ComplementaryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ComplementaryRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "complementary"
        }
      }],
      type: "structure"
    };
    var _default = ComplementaryRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ContentInfoRole.js
var require_ContentInfoRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ContentInfoRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ContentInfoRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "structureinfo"
        }
      }],
      type: "structure"
    };
    var _default = ContentInfoRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DateRole.js
var require_DateRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DateRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DateRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "date"
          }]
        }
      }],
      type: "widget"
    };
    var _default = DateRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DateTimeRole.js
var require_DateTimeRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DateTimeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DateTimeRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "datetime"
          }]
        }
      }],
      type: "widget"
    };
    var _default = DateTimeRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DefinitionRole.js
var require_DefinitionRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DefinitionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DefinitionRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "dfn"
        }
      }],
      type: "structure"
    };
    var _default = DefinitionRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DescriptionListDetailRole.js
var require_DescriptionListDetailRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DescriptionListDetailRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DescriptionListDetailRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "dd"
        }
      }],
      type: "structure"
    };
    var _default = DescriptionListDetailRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DescriptionListRole.js
var require_DescriptionListRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DescriptionListRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DescriptionListRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "dl"
        }
      }],
      type: "structure"
    };
    var _default = DescriptionListRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DescriptionListTermRole.js
var require_DescriptionListTermRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DescriptionListTermRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DescriptionListTermRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "dt"
        }
      }],
      type: "structure"
    };
    var _default = DescriptionListTermRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DetailsRole.js
var require_DetailsRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DetailsRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DetailsRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "details"
        }
      }],
      type: "structure"
    };
    var _default = DetailsRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DialogRole.js
var require_DialogRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DialogRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "dialog"
        }
      }, {
        module: "HTML",
        concept: {
          name: "dialog"
        }
      }],
      type: "window"
    };
    var _default = DialogRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DirectoryRole.js
var require_DirectoryRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DirectoryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DirectoryRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "directory"
        }
      }, {
        module: "HTML",
        concept: {
          name: "dir"
        }
      }],
      type: "structure"
    };
    var _default = DirectoryRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DisclosureTriangleRole.js
var require_DisclosureTriangleRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DisclosureTriangleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DisclosureTriangleRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          constraints: ["scoped to a details element"],
          name: "summary"
        }
      }],
      type: "widget"
    };
    var _default = DisclosureTriangleRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DivRole.js
var require_DivRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DivRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DivRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "div"
        }
      }],
      type: "generic"
    };
    var _default = DivRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/DocumentRole.js
var require_DocumentRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/DocumentRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DocumentRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "document"
        }
      }],
      type: "structure"
    };
    var _default = DocumentRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/EmbeddedObjectRole.js
var require_EmbeddedObjectRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/EmbeddedObjectRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var EmbeddedObjectRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "embed"
        }
      }],
      type: "widget"
    };
    var _default = EmbeddedObjectRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/FeedRole.js
var require_FeedRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/FeedRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FeedRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "feed"
        }
      }],
      type: "structure"
    };
    var _default = FeedRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/FigcaptionRole.js
var require_FigcaptionRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/FigcaptionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FigcaptionRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "figcaption"
        }
      }],
      type: "structure"
    };
    var _default = FigcaptionRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/FigureRole.js
var require_FigureRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/FigureRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FigureRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "figure"
        }
      }, {
        module: "HTML",
        concept: {
          name: "figure"
        }
      }],
      type: "structure"
    };
    var _default = FigureRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/FooterRole.js
var require_FooterRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/FooterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FooterRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "footer"
        }
      }],
      type: "structure"
    };
    var _default = FooterRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/FormRole.js
var require_FormRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/FormRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FormRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "form"
        }
      }, {
        module: "HTML",
        concept: {
          name: "form"
        }
      }],
      type: "structure"
    };
    var _default = FormRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/GridRole.js
var require_GridRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/GridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var GridRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "grid"
        }
      }],
      type: "widget"
    };
    var _default = GridRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/GroupRole.js
var require_GroupRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/GroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var GroupRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "group"
        }
      }],
      type: "structure"
    };
    var _default = GroupRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/HeadingRole.js
var require_HeadingRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/HeadingRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var HeadingRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "heading"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h1"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h2"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h3"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h4"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h5"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h6"
        }
      }],
      type: "structure"
    };
    var _default = HeadingRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/IframePresentationalRole.js
var require_IframePresentationalRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/IframePresentationalRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var IframePresentationalRole = {
      relatedConcepts: [],
      type: "window"
    };
    var _default = IframePresentationalRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/IframeRole.js
var require_IframeRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/IframeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var IframeRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "iframe"
        }
      }],
      type: "window"
    };
    var _default = IframeRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/IgnoredRole.js
var require_IgnoredRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/IgnoredRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var IgnoredRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = IgnoredRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ImageMapLinkRole.js
var require_ImageMapLinkRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ImageMapLinkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ImageMapLinkRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = ImageMapLinkRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ImageMapRole.js
var require_ImageMapRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ImageMapRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ImageMapRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "img",
          attributes: [{
            name: "usemap"
          }]
        }
      }],
      type: "structure"
    };
    var _default = ImageMapRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ImageRole.js
var require_ImageRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ImageRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ImageRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "HTML",
        concept: {
          name: "img"
        }
      }],
      type: "structure"
    };
    var _default = ImageRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/InlineTextBoxRole.js
var require_InlineTextBoxRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/InlineTextBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var InlineTextBoxRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input"
        }
      }],
      type: "widget"
    };
    var _default = InlineTextBoxRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/InputTimeRole.js
var require_InputTimeRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/InputTimeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var InputTimeRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "time"
          }]
        }
      }],
      type: "widget"
    };
    var _default = InputTimeRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/LabelRole.js
var require_LabelRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/LabelRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LabelRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "label"
        }
      }],
      type: "structure"
    };
    var _default = LabelRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/LegendRole.js
var require_LegendRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/LegendRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LegendRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "legend"
        }
      }],
      type: "structure"
    };
    var _default = LegendRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/LineBreakRole.js
var require_LineBreakRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/LineBreakRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LineBreakRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "br"
        }
      }],
      type: "structure"
    };
    var _default = LineBreakRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/LinkRole.js
var require_LinkRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/LinkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LinkRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "link"
        }
      }, {
        module: "HTML",
        concept: {
          name: "a",
          attributes: [{
            name: "href"
          }]
        }
      }],
      type: "widget"
    };
    var _default = LinkRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ListBoxOptionRole.js
var require_ListBoxOptionRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ListBoxOptionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListBoxOptionRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "option"
        }
      }, {
        module: "HTML",
        concept: {
          name: "option"
        }
      }],
      type: "widget"
    };
    var _default = ListBoxOptionRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ListBoxRole.js
var require_ListBoxRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ListBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "listbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "datalist"
        }
      }, {
        module: "HTML",
        concept: {
          name: "select"
        }
      }],
      type: "widget"
    };
    var _default = ListBoxRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ListItemRole.js
var require_ListItemRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ListItemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListItemRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "listitem"
        }
      }, {
        module: "HTML",
        concept: {
          name: "li"
        }
      }],
      type: "structure"
    };
    var _default = ListItemRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ListMarkerRole.js
var require_ListMarkerRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ListMarkerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListMarkerRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = ListMarkerRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ListRole.js
var require_ListRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ListRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "list"
        }
      }, {
        module: "HTML",
        concept: {
          name: "ul"
        }
      }, {
        module: "HTML",
        concept: {
          name: "ol"
        }
      }],
      type: "structure"
    };
    var _default = ListRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/LogRole.js
var require_LogRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/LogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LogRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "log"
        }
      }],
      type: "structure"
    };
    var _default = LogRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MainRole.js
var require_MainRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MainRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MainRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "main"
        }
      }, {
        module: "HTML",
        concept: {
          name: "main"
        }
      }],
      type: "structure"
    };
    var _default = MainRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MarkRole.js
var require_MarkRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MarkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MarkRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "mark"
        }
      }],
      type: "structure"
    };
    var _default = MarkRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MarqueeRole.js
var require_MarqueeRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MarqueeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MarqueeRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "marquee"
        }
      }, {
        module: "HTML",
        concept: {
          name: "marquee"
        }
      }],
      type: "structure"
    };
    var _default = MarqueeRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MathRole.js
var require_MathRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MathRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MathRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "math"
        }
      }],
      type: "structure"
    };
    var _default = MathRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MenuBarRole.js
var require_MenuBarRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MenuBarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuBarRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menubar"
        }
      }],
      type: "structure"
    };
    var _default = MenuBarRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MenuButtonRole.js
var require_MenuButtonRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MenuButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuButtonRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = MenuButtonRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MenuItemRole.js
var require_MenuItemRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MenuItemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuItemRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menuitem"
        }
      }, {
        module: "HTML",
        concept: {
          name: "menuitem"
        }
      }],
      type: "widget"
    };
    var _default = MenuItemRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MenuItemCheckBoxRole.js
var require_MenuItemCheckBoxRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MenuItemCheckBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuItemCheckBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menuitemcheckbox"
        }
      }],
      type: "widget"
    };
    var _default = MenuItemCheckBoxRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MenuItemRadioRole.js
var require_MenuItemRadioRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MenuItemRadioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuItemRadioRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menuitemradio"
        }
      }],
      type: "widget"
    };
    var _default = MenuItemRadioRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MenuListOptionRole.js
var require_MenuListOptionRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MenuListOptionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuListOptionRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = MenuListOptionRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MenuListPopupRole.js
var require_MenuListPopupRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MenuListPopupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuListPopupRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = MenuListPopupRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MenuRole.js
var require_MenuRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MenuRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menu"
        }
      }, {
        module: "HTML",
        concept: {
          name: "menu"
        }
      }],
      type: "structure"
    };
    var _default = MenuRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/MeterRole.js
var require_MeterRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/MeterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MeterRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "meter"
        }
      }],
      type: "structure"
    };
    var _default = MeterRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/NavigationRole.js
var require_NavigationRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/NavigationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NavigationRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "navigation"
        }
      }, {
        module: "HTML",
        concept: {
          name: "nav"
        }
      }],
      type: "structure"
    };
    var _default = NavigationRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/NoneRole.js
var require_NoneRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/NoneRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NoneRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "none"
        }
      }],
      type: "structure"
    };
    var _default = NoneRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/NoteRole.js
var require_NoteRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/NoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NoteRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "note"
        }
      }],
      type: "structure"
    };
    var _default = NoteRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/OutlineRole.js
var require_OutlineRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/OutlineRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var OutlineRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = OutlineRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ParagraphRole.js
var require_ParagraphRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ParagraphRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ParagraphRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "p"
        }
      }],
      type: "structure"
    };
    var _default = ParagraphRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/PopUpButtonRole.js
var require_PopUpButtonRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/PopUpButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var PopUpButtonRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = PopUpButtonRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/PreRole.js
var require_PreRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/PreRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var PreRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "pre"
        }
      }],
      type: "structure"
    };
    var _default = PreRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/PresentationalRole.js
var require_PresentationalRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/PresentationalRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var PresentationalRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "presentation"
        }
      }],
      type: "structure"
    };
    var _default = PresentationalRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ProgressIndicatorRole.js
var require_ProgressIndicatorRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ProgressIndicatorRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ProgressIndicatorRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "progressbar"
        }
      }, {
        module: "HTML",
        concept: {
          name: "progress"
        }
      }],
      type: "structure"
    };
    var _default = ProgressIndicatorRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/RadioButtonRole.js
var require_RadioButtonRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/RadioButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RadioButtonRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "radio"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "radio"
          }]
        }
      }],
      type: "widget"
    };
    var _default = RadioButtonRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/RadioGroupRole.js
var require_RadioGroupRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/RadioGroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RadioGroupRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "radiogroup"
        }
      }],
      type: "structure"
    };
    var _default = RadioGroupRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/RegionRole.js
var require_RegionRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/RegionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RegionRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "region"
        }
      }],
      type: "structure"
    };
    var _default = RegionRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/RootWebAreaRole.js
var require_RootWebAreaRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/RootWebAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RootWebAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = RootWebAreaRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/RowHeaderRole.js
var require_RowHeaderRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/RowHeaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RowHeaderRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "rowheader"
        }
      }, {
        module: "HTML",
        concept: {
          name: "th",
          attributes: [{
            name: "scope",
            value: "row"
          }]
        }
      }],
      type: "widget"
    };
    var _default = RowHeaderRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/RowRole.js
var require_RowRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/RowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RowRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "row"
        }
      }, {
        module: "HTML",
        concept: {
          name: "tr"
        }
      }],
      type: "structure"
    };
    var _default = RowRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/RubyRole.js
var require_RubyRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/RubyRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RubyRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "ruby"
        }
      }],
      type: "structure"
    };
    var _default = RubyRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/RulerRole.js
var require_RulerRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/RulerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RulerRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = RulerRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ScrollAreaRole.js
var require_ScrollAreaRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ScrollAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ScrollAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = ScrollAreaRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ScrollBarRole.js
var require_ScrollBarRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ScrollBarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ScrollBarRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "scrollbar"
        }
      }],
      type: "widget"
    };
    var _default = ScrollBarRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/SeamlessWebAreaRole.js
var require_SeamlessWebAreaRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/SeamlessWebAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SeamlessWebAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SeamlessWebAreaRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/SearchRole.js
var require_SearchRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/SearchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SearchRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "search"
        }
      }],
      type: "structure"
    };
    var _default = SearchRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/SearchBoxRole.js
var require_SearchBoxRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/SearchBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SearchBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "searchbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "search"
          }]
        }
      }],
      type: "widget"
    };
    var _default = SearchBoxRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/SliderRole.js
var require_SliderRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/SliderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SliderRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "slider"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "range"
          }]
        }
      }],
      type: "widget"
    };
    var _default = SliderRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/SliderThumbRole.js
var require_SliderThumbRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/SliderThumbRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SliderThumbRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SliderThumbRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/SpinButtonRole.js
var require_SpinButtonRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/SpinButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SpinButtonRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "spinbutton"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "number"
          }]
        }
      }],
      type: "widget"
    };
    var _default = SpinButtonRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/SpinButtonPartRole.js
var require_SpinButtonPartRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/SpinButtonPartRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SpinButtonPartRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SpinButtonPartRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/SplitterRole.js
var require_SplitterRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/SplitterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SplitterRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "separator"
        }
      }],
      type: "widget"
    };
    var _default = SplitterRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/StaticTextRole.js
var require_StaticTextRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/StaticTextRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var StaticTextRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = StaticTextRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/StatusRole.js
var require_StatusRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/StatusRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var StatusRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "status"
        }
      }],
      type: "structure"
    };
    var _default = StatusRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/SVGRootRole.js
var require_SVGRootRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/SVGRootRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SVGRootRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SVGRootRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/SwitchRole.js
var require_SwitchRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/SwitchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SwitchRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "switch"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "checkbox"
          }]
        }
      }],
      type: "widget"
    };
    var _default = SwitchRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TabGroupRole.js
var require_TabGroupRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TabGroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TabGroupRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tablist"
        }
      }],
      type: "structure"
    };
    var _default = TabGroupRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TabRole.js
var require_TabRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TabRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TabRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tab"
        }
      }],
      type: "widget"
    };
    var _default = TabRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TableHeaderContainerRole.js
var require_TableHeaderContainerRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TableHeaderContainerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TableHeaderContainerRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = TableHeaderContainerRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TableRole.js
var require_TableRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TableRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TableRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "table"
        }
      }, {
        module: "HTML",
        concept: {
          name: "table"
        }
      }],
      type: "structure"
    };
    var _default = TableRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TabListRole.js
var require_TabListRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TabListRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TabListRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tablist"
        }
      }],
      type: "structure"
    };
    var _default = TabListRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TabPanelRole.js
var require_TabPanelRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TabPanelRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TabPanelRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tabpanel"
        }
      }],
      type: "structure"
    };
    var _default = TabPanelRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TermRole.js
var require_TermRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TermRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TermRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "term"
        }
      }],
      type: "structure"
    };
    var _default = TermRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TextAreaRole.js
var require_TextAreaRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TextAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TextAreaRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          attributes: [{
            name: "aria-multiline",
            value: "true"
          }],
          name: "textbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "textarea"
        }
      }],
      type: "widget"
    };
    var _default = TextAreaRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TextFieldRole.js
var require_TextFieldRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TextFieldRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TextFieldRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "textbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "text"
          }]
        }
      }],
      type: "widget"
    };
    var _default = TextFieldRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TimeRole.js
var require_TimeRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TimeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TimeRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "time"
        }
      }],
      type: "structure"
    };
    var _default = TimeRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TimerRole.js
var require_TimerRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TimerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TimerRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "timer"
        }
      }],
      type: "structure"
    };
    var _default = TimerRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ToggleButtonRole.js
var require_ToggleButtonRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ToggleButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ToggleButtonRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          attributes: [{
            name: "aria-pressed"
          }]
        }
      }],
      type: "widget"
    };
    var _default = ToggleButtonRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/ToolbarRole.js
var require_ToolbarRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/ToolbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ToolbarRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "toolbar"
        }
      }],
      type: "structure"
    };
    var _default = ToolbarRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TreeRole.js
var require_TreeRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TreeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TreeRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tree"
        }
      }],
      type: "widget"
    };
    var _default = TreeRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TreeGridRole.js
var require_TreeGridRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TreeGridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TreeGridRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "treegrid"
        }
      }],
      type: "widget"
    };
    var _default = TreeGridRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/TreeItemRole.js
var require_TreeItemRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/TreeItemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TreeItemRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "treeitem"
        }
      }],
      type: "widget"
    };
    var _default = TreeItemRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/UserInterfaceTooltipRole.js
var require_UserInterfaceTooltipRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/UserInterfaceTooltipRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var UserInterfaceTooltipRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tooltip"
        }
      }],
      type: "structure"
    };
    var _default = UserInterfaceTooltipRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/VideoRole.js
var require_VideoRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/VideoRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var VideoRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "video"
        }
      }],
      type: "widget"
    };
    var _default = VideoRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/WebAreaRole.js
var require_WebAreaRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/WebAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var WebAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = WebAreaRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/etc/objects/WindowRole.js
var require_WindowRole = __commonJS({
  "node_modules/axobject-query/lib/etc/objects/WindowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var WindowRole = {
      relatedConcepts: [],
      type: "window"
    };
    var _default = WindowRole;
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/AXObjectsMap.js
var require_AXObjectsMap = __commonJS({
  "node_modules/axobject-query/lib/AXObjectsMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator2());
    var _AbbrRole = _interopRequireDefault(require_AbbrRole());
    var _AlertDialogRole = _interopRequireDefault(require_AlertDialogRole());
    var _AlertRole = _interopRequireDefault(require_AlertRole());
    var _AnnotationRole = _interopRequireDefault(require_AnnotationRole());
    var _ApplicationRole = _interopRequireDefault(require_ApplicationRole());
    var _ArticleRole = _interopRequireDefault(require_ArticleRole());
    var _AudioRole = _interopRequireDefault(require_AudioRole());
    var _BannerRole = _interopRequireDefault(require_BannerRole());
    var _BlockquoteRole = _interopRequireDefault(require_BlockquoteRole());
    var _BusyIndicatorRole = _interopRequireDefault(require_BusyIndicatorRole());
    var _ButtonRole = _interopRequireDefault(require_ButtonRole());
    var _CanvasRole = _interopRequireDefault(require_CanvasRole());
    var _CaptionRole = _interopRequireDefault(require_CaptionRole());
    var _CellRole = _interopRequireDefault(require_CellRole());
    var _CheckBoxRole = _interopRequireDefault(require_CheckBoxRole());
    var _ColorWellRole = _interopRequireDefault(require_ColorWellRole());
    var _ColumnHeaderRole = _interopRequireDefault(require_ColumnHeaderRole());
    var _ColumnRole = _interopRequireDefault(require_ColumnRole());
    var _ComboBoxRole = _interopRequireDefault(require_ComboBoxRole());
    var _ComplementaryRole = _interopRequireDefault(require_ComplementaryRole());
    var _ContentInfoRole = _interopRequireDefault(require_ContentInfoRole());
    var _DateRole = _interopRequireDefault(require_DateRole());
    var _DateTimeRole = _interopRequireDefault(require_DateTimeRole());
    var _DefinitionRole = _interopRequireDefault(require_DefinitionRole());
    var _DescriptionListDetailRole = _interopRequireDefault(require_DescriptionListDetailRole());
    var _DescriptionListRole = _interopRequireDefault(require_DescriptionListRole());
    var _DescriptionListTermRole = _interopRequireDefault(require_DescriptionListTermRole());
    var _DetailsRole = _interopRequireDefault(require_DetailsRole());
    var _DialogRole = _interopRequireDefault(require_DialogRole());
    var _DirectoryRole = _interopRequireDefault(require_DirectoryRole());
    var _DisclosureTriangleRole = _interopRequireDefault(require_DisclosureTriangleRole());
    var _DivRole = _interopRequireDefault(require_DivRole());
    var _DocumentRole = _interopRequireDefault(require_DocumentRole());
    var _EmbeddedObjectRole = _interopRequireDefault(require_EmbeddedObjectRole());
    var _FeedRole = _interopRequireDefault(require_FeedRole());
    var _FigcaptionRole = _interopRequireDefault(require_FigcaptionRole());
    var _FigureRole = _interopRequireDefault(require_FigureRole());
    var _FooterRole = _interopRequireDefault(require_FooterRole());
    var _FormRole = _interopRequireDefault(require_FormRole());
    var _GridRole = _interopRequireDefault(require_GridRole());
    var _GroupRole = _interopRequireDefault(require_GroupRole());
    var _HeadingRole = _interopRequireDefault(require_HeadingRole());
    var _IframePresentationalRole = _interopRequireDefault(require_IframePresentationalRole());
    var _IframeRole = _interopRequireDefault(require_IframeRole());
    var _IgnoredRole = _interopRequireDefault(require_IgnoredRole());
    var _ImageMapLinkRole = _interopRequireDefault(require_ImageMapLinkRole());
    var _ImageMapRole = _interopRequireDefault(require_ImageMapRole());
    var _ImageRole = _interopRequireDefault(require_ImageRole());
    var _InlineTextBoxRole = _interopRequireDefault(require_InlineTextBoxRole());
    var _InputTimeRole = _interopRequireDefault(require_InputTimeRole());
    var _LabelRole = _interopRequireDefault(require_LabelRole());
    var _LegendRole = _interopRequireDefault(require_LegendRole());
    var _LineBreakRole = _interopRequireDefault(require_LineBreakRole());
    var _LinkRole = _interopRequireDefault(require_LinkRole());
    var _ListBoxOptionRole = _interopRequireDefault(require_ListBoxOptionRole());
    var _ListBoxRole = _interopRequireDefault(require_ListBoxRole());
    var _ListItemRole = _interopRequireDefault(require_ListItemRole());
    var _ListMarkerRole = _interopRequireDefault(require_ListMarkerRole());
    var _ListRole = _interopRequireDefault(require_ListRole());
    var _LogRole = _interopRequireDefault(require_LogRole());
    var _MainRole = _interopRequireDefault(require_MainRole());
    var _MarkRole = _interopRequireDefault(require_MarkRole());
    var _MarqueeRole = _interopRequireDefault(require_MarqueeRole());
    var _MathRole = _interopRequireDefault(require_MathRole());
    var _MenuBarRole = _interopRequireDefault(require_MenuBarRole());
    var _MenuButtonRole = _interopRequireDefault(require_MenuButtonRole());
    var _MenuItemRole = _interopRequireDefault(require_MenuItemRole());
    var _MenuItemCheckBoxRole = _interopRequireDefault(require_MenuItemCheckBoxRole());
    var _MenuItemRadioRole = _interopRequireDefault(require_MenuItemRadioRole());
    var _MenuListOptionRole = _interopRequireDefault(require_MenuListOptionRole());
    var _MenuListPopupRole = _interopRequireDefault(require_MenuListPopupRole());
    var _MenuRole = _interopRequireDefault(require_MenuRole());
    var _MeterRole = _interopRequireDefault(require_MeterRole());
    var _NavigationRole = _interopRequireDefault(require_NavigationRole());
    var _NoneRole = _interopRequireDefault(require_NoneRole());
    var _NoteRole = _interopRequireDefault(require_NoteRole());
    var _OutlineRole = _interopRequireDefault(require_OutlineRole());
    var _ParagraphRole = _interopRequireDefault(require_ParagraphRole());
    var _PopUpButtonRole = _interopRequireDefault(require_PopUpButtonRole());
    var _PreRole = _interopRequireDefault(require_PreRole());
    var _PresentationalRole = _interopRequireDefault(require_PresentationalRole());
    var _ProgressIndicatorRole = _interopRequireDefault(require_ProgressIndicatorRole());
    var _RadioButtonRole = _interopRequireDefault(require_RadioButtonRole());
    var _RadioGroupRole = _interopRequireDefault(require_RadioGroupRole());
    var _RegionRole = _interopRequireDefault(require_RegionRole());
    var _RootWebAreaRole = _interopRequireDefault(require_RootWebAreaRole());
    var _RowHeaderRole = _interopRequireDefault(require_RowHeaderRole());
    var _RowRole = _interopRequireDefault(require_RowRole());
    var _RubyRole = _interopRequireDefault(require_RubyRole());
    var _RulerRole = _interopRequireDefault(require_RulerRole());
    var _ScrollAreaRole = _interopRequireDefault(require_ScrollAreaRole());
    var _ScrollBarRole = _interopRequireDefault(require_ScrollBarRole());
    var _SeamlessWebAreaRole = _interopRequireDefault(require_SeamlessWebAreaRole());
    var _SearchRole = _interopRequireDefault(require_SearchRole());
    var _SearchBoxRole = _interopRequireDefault(require_SearchBoxRole());
    var _SliderRole = _interopRequireDefault(require_SliderRole());
    var _SliderThumbRole = _interopRequireDefault(require_SliderThumbRole());
    var _SpinButtonRole = _interopRequireDefault(require_SpinButtonRole());
    var _SpinButtonPartRole = _interopRequireDefault(require_SpinButtonPartRole());
    var _SplitterRole = _interopRequireDefault(require_SplitterRole());
    var _StaticTextRole = _interopRequireDefault(require_StaticTextRole());
    var _StatusRole = _interopRequireDefault(require_StatusRole());
    var _SVGRootRole = _interopRequireDefault(require_SVGRootRole());
    var _SwitchRole = _interopRequireDefault(require_SwitchRole());
    var _TabGroupRole = _interopRequireDefault(require_TabGroupRole());
    var _TabRole = _interopRequireDefault(require_TabRole());
    var _TableHeaderContainerRole = _interopRequireDefault(require_TableHeaderContainerRole());
    var _TableRole = _interopRequireDefault(require_TableRole());
    var _TabListRole = _interopRequireDefault(require_TabListRole());
    var _TabPanelRole = _interopRequireDefault(require_TabPanelRole());
    var _TermRole = _interopRequireDefault(require_TermRole());
    var _TextAreaRole = _interopRequireDefault(require_TextAreaRole());
    var _TextFieldRole = _interopRequireDefault(require_TextFieldRole());
    var _TimeRole = _interopRequireDefault(require_TimeRole());
    var _TimerRole = _interopRequireDefault(require_TimerRole());
    var _ToggleButtonRole = _interopRequireDefault(require_ToggleButtonRole());
    var _ToolbarRole = _interopRequireDefault(require_ToolbarRole());
    var _TreeRole = _interopRequireDefault(require_TreeRole());
    var _TreeGridRole = _interopRequireDefault(require_TreeGridRole());
    var _TreeItemRole = _interopRequireDefault(require_TreeItemRole());
    var _UserInterfaceTooltipRole = _interopRequireDefault(require_UserInterfaceTooltipRole());
    var _VideoRole = _interopRequireDefault(require_VideoRole());
    var _WebAreaRole = _interopRequireDefault(require_WebAreaRole());
    var _WindowRole = _interopRequireDefault(require_WindowRole());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F4 = function F5() {
          };
          return { s: F4, n: function n2() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e2) {
            throw _e2;
          }, f: F4 };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var AXObjects2 = [["AbbrRole", _AbbrRole.default], ["AlertDialogRole", _AlertDialogRole.default], ["AlertRole", _AlertRole.default], ["AnnotationRole", _AnnotationRole.default], ["ApplicationRole", _ApplicationRole.default], ["ArticleRole", _ArticleRole.default], ["AudioRole", _AudioRole.default], ["BannerRole", _BannerRole.default], ["BlockquoteRole", _BlockquoteRole.default], ["BusyIndicatorRole", _BusyIndicatorRole.default], ["ButtonRole", _ButtonRole.default], ["CanvasRole", _CanvasRole.default], ["CaptionRole", _CaptionRole.default], ["CellRole", _CellRole.default], ["CheckBoxRole", _CheckBoxRole.default], ["ColorWellRole", _ColorWellRole.default], ["ColumnHeaderRole", _ColumnHeaderRole.default], ["ColumnRole", _ColumnRole.default], ["ComboBoxRole", _ComboBoxRole.default], ["ComplementaryRole", _ComplementaryRole.default], ["ContentInfoRole", _ContentInfoRole.default], ["DateRole", _DateRole.default], ["DateTimeRole", _DateTimeRole.default], ["DefinitionRole", _DefinitionRole.default], ["DescriptionListDetailRole", _DescriptionListDetailRole.default], ["DescriptionListRole", _DescriptionListRole.default], ["DescriptionListTermRole", _DescriptionListTermRole.default], ["DetailsRole", _DetailsRole.default], ["DialogRole", _DialogRole.default], ["DirectoryRole", _DirectoryRole.default], ["DisclosureTriangleRole", _DisclosureTriangleRole.default], ["DivRole", _DivRole.default], ["DocumentRole", _DocumentRole.default], ["EmbeddedObjectRole", _EmbeddedObjectRole.default], ["FeedRole", _FeedRole.default], ["FigcaptionRole", _FigcaptionRole.default], ["FigureRole", _FigureRole.default], ["FooterRole", _FooterRole.default], ["FormRole", _FormRole.default], ["GridRole", _GridRole.default], ["GroupRole", _GroupRole.default], ["HeadingRole", _HeadingRole.default], ["IframePresentationalRole", _IframePresentationalRole.default], ["IframeRole", _IframeRole.default], ["IgnoredRole", _IgnoredRole.default], ["ImageMapLinkRole", _ImageMapLinkRole.default], ["ImageMapRole", _ImageMapRole.default], ["ImageRole", _ImageRole.default], ["InlineTextBoxRole", _InlineTextBoxRole.default], ["InputTimeRole", _InputTimeRole.default], ["LabelRole", _LabelRole.default], ["LegendRole", _LegendRole.default], ["LineBreakRole", _LineBreakRole.default], ["LinkRole", _LinkRole.default], ["ListBoxOptionRole", _ListBoxOptionRole.default], ["ListBoxRole", _ListBoxRole.default], ["ListItemRole", _ListItemRole.default], ["ListMarkerRole", _ListMarkerRole.default], ["ListRole", _ListRole.default], ["LogRole", _LogRole.default], ["MainRole", _MainRole.default], ["MarkRole", _MarkRole.default], ["MarqueeRole", _MarqueeRole.default], ["MathRole", _MathRole.default], ["MenuBarRole", _MenuBarRole.default], ["MenuButtonRole", _MenuButtonRole.default], ["MenuItemRole", _MenuItemRole.default], ["MenuItemCheckBoxRole", _MenuItemCheckBoxRole.default], ["MenuItemRadioRole", _MenuItemRadioRole.default], ["MenuListOptionRole", _MenuListOptionRole.default], ["MenuListPopupRole", _MenuListPopupRole.default], ["MenuRole", _MenuRole.default], ["MeterRole", _MeterRole.default], ["NavigationRole", _NavigationRole.default], ["NoneRole", _NoneRole.default], ["NoteRole", _NoteRole.default], ["OutlineRole", _OutlineRole.default], ["ParagraphRole", _ParagraphRole.default], ["PopUpButtonRole", _PopUpButtonRole.default], ["PreRole", _PreRole.default], ["PresentationalRole", _PresentationalRole.default], ["ProgressIndicatorRole", _ProgressIndicatorRole.default], ["RadioButtonRole", _RadioButtonRole.default], ["RadioGroupRole", _RadioGroupRole.default], ["RegionRole", _RegionRole.default], ["RootWebAreaRole", _RootWebAreaRole.default], ["RowHeaderRole", _RowHeaderRole.default], ["RowRole", _RowRole.default], ["RubyRole", _RubyRole.default], ["RulerRole", _RulerRole.default], ["ScrollAreaRole", _ScrollAreaRole.default], ["ScrollBarRole", _ScrollBarRole.default], ["SeamlessWebAreaRole", _SeamlessWebAreaRole.default], ["SearchRole", _SearchRole.default], ["SearchBoxRole", _SearchBoxRole.default], ["SliderRole", _SliderRole.default], ["SliderThumbRole", _SliderThumbRole.default], ["SpinButtonRole", _SpinButtonRole.default], ["SpinButtonPartRole", _SpinButtonPartRole.default], ["SplitterRole", _SplitterRole.default], ["StaticTextRole", _StaticTextRole.default], ["StatusRole", _StatusRole.default], ["SVGRootRole", _SVGRootRole.default], ["SwitchRole", _SwitchRole.default], ["TabGroupRole", _TabGroupRole.default], ["TabRole", _TabRole.default], ["TableHeaderContainerRole", _TableHeaderContainerRole.default], ["TableRole", _TableRole.default], ["TabListRole", _TabListRole.default], ["TabPanelRole", _TabPanelRole.default], ["TermRole", _TermRole.default], ["TextAreaRole", _TextAreaRole.default], ["TextFieldRole", _TextFieldRole.default], ["TimeRole", _TimeRole.default], ["TimerRole", _TimerRole.default], ["ToggleButtonRole", _ToggleButtonRole.default], ["ToolbarRole", _ToolbarRole.default], ["TreeRole", _TreeRole.default], ["TreeGridRole", _TreeGridRole.default], ["TreeItemRole", _TreeItemRole.default], ["UserInterfaceTooltipRole", _UserInterfaceTooltipRole.default], ["VideoRole", _VideoRole.default], ["WebAreaRole", _WebAreaRole.default], ["WindowRole", _WindowRole.default]];
    var AXObjectsMap = {
      entries: function entries() {
        return AXObjects2;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator = _createForOfIteratorHelper(AXObjects2), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], values = _step$value[1];
            fn.call(thisArg, values, key, AXObjects2);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      },
      get: function get(key) {
        var item = AXObjects2.find(function(tuple) {
          return tuple[0] === key ? true : false;
        });
        return item && item[1];
      },
      has: function has(key) {
        return !!AXObjectsMap.get(key);
      },
      keys: function keys() {
        return AXObjects2.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
          return key;
        });
      },
      values: function values() {
        return AXObjects2.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(AXObjectsMap, AXObjectsMap.entries());
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/AXObjectElementMap.js
var require_AXObjectElementMap = __commonJS({
  "node_modules/axobject-query/lib/AXObjectElementMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator2());
    var _AXObjectsMap = _interopRequireDefault(require_AXObjectsMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F4 = function F5() {
          };
          return { s: F4, n: function n2() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e2) {
            throw _e2;
          }, f: F4 };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var AXObjectElements = [];
    var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries());
    var _step;
    try {
      _loop = function _loop2() {
        var _step$value = _slicedToArray(_step.value, 2), name49 = _step$value[0], def = _step$value[1];
        var relatedConcepts = def.relatedConcepts;
        if (Array.isArray(relatedConcepts)) {
          relatedConcepts.forEach(function(relation) {
            if (relation.module === "HTML") {
              var concept = relation.concept;
              if (concept) {
                var index = AXObjectElements.findIndex(function(_ref5) {
                  var _ref6 = _slicedToArray(_ref5, 1), key = _ref6[0];
                  return key === name49;
                });
                if (index === -1) {
                  AXObjectElements.push([name49, []]);
                  index = AXObjectElements.length - 1;
                }
                AXObjectElements[index][1].push(concept);
              }
            }
          });
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _loop();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _loop;
    var AXObjectElementMap = {
      entries: function entries() {
        return AXObjectElements;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator2 = _createForOfIteratorHelper(AXObjectElements), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _step2$value = _slicedToArray(_step2.value, 2), key = _step2$value[0], values = _step2$value[1];
            fn.call(thisArg, values, key, AXObjectElements);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      },
      get: function get(key) {
        var item = AXObjectElements.find(function(tuple) {
          return tuple[0] === key ? true : false;
        });
        return item && item[1];
      },
      has: function has(key) {
        return !!AXObjectElementMap.get(key);
      },
      keys: function keys() {
        return AXObjectElements.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
          return key;
        });
      },
      values: function values() {
        return AXObjectElements.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(AXObjectElementMap, AXObjectElementMap.entries());
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/AXObjectRoleMap.js
var require_AXObjectRoleMap = __commonJS({
  "node_modules/axobject-query/lib/AXObjectRoleMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator2());
    var _AXObjectsMap = _interopRequireDefault(require_AXObjectsMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F4 = function F5() {
          };
          return { s: F4, n: function n2() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e2) {
            throw _e2;
          }, f: F4 };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var AXObjectRoleElements = [];
    var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries());
    var _step;
    try {
      _loop = function _loop2() {
        var _step$value = _slicedToArray(_step.value, 2), name49 = _step$value[0], def = _step$value[1];
        var relatedConcepts = def.relatedConcepts;
        if (Array.isArray(relatedConcepts)) {
          relatedConcepts.forEach(function(relation) {
            if (relation.module === "ARIA") {
              var concept = relation.concept;
              if (concept) {
                var index = AXObjectRoleElements.findIndex(function(_ref5) {
                  var _ref6 = _slicedToArray(_ref5, 1), key = _ref6[0];
                  return key === name49;
                });
                if (index === -1) {
                  AXObjectRoleElements.push([name49, []]);
                  index = AXObjectRoleElements.length - 1;
                }
                AXObjectRoleElements[index][1].push(concept);
              }
            }
          });
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _loop();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _loop;
    var AXObjectRoleMap = {
      entries: function entries() {
        return AXObjectRoleElements;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator2 = _createForOfIteratorHelper(AXObjectRoleElements), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _step2$value = _slicedToArray(_step2.value, 2), key = _step2$value[0], values = _step2$value[1];
            fn.call(thisArg, values, key, AXObjectRoleElements);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      },
      get: function get(key) {
        var item = AXObjectRoleElements.find(function(tuple) {
          return tuple[0] === key ? true : false;
        });
        return item && item[1];
      },
      has: function has(key) {
        return !!AXObjectRoleMap.get(key);
      },
      keys: function keys() {
        return AXObjectRoleElements.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
          return key;
        });
      },
      values: function values() {
        return AXObjectRoleElements.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(AXObjectRoleMap, AXObjectRoleMap.entries());
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/elementAXObjectMap.js
var require_elementAXObjectMap = __commonJS({
  "node_modules/axobject-query/lib/elementAXObjectMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _lite = require_lite();
    var _AXObjectsMap = _interopRequireDefault(require_AXObjectsMap());
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F4 = function F5() {
          };
          return { s: F4, n: function n2() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e2) {
            throw _e2;
          }, f: F4 };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var elementAXObjects2 = [];
    var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries());
    var _step;
    try {
      _loop = function _loop2() {
        var _step$value = _slicedToArray(_step.value, 2), name49 = _step$value[0], def = _step$value[1];
        var relatedConcepts = def.relatedConcepts;
        if (Array.isArray(relatedConcepts)) {
          relatedConcepts.forEach(function(relation) {
            if (relation.module === "HTML") {
              var concept = relation.concept;
              if (concept != null) {
                var conceptStr = JSON.stringify(concept);
                var axObjects;
                var index = 0;
                for (; index < elementAXObjects2.length; index++) {
                  var key = elementAXObjects2[index][0];
                  if (JSON.stringify(key) === conceptStr) {
                    axObjects = elementAXObjects2[index][1];
                    break;
                  }
                }
                if (!Array.isArray(axObjects)) {
                  axObjects = [];
                }
                var loc = axObjects.findIndex(function(item) {
                  return item === name49;
                });
                if (loc === -1) {
                  axObjects.push(name49);
                }
                if (index < elementAXObjects2.length) {
                  elementAXObjects2.splice(index, 1, [concept, axObjects]);
                } else {
                  elementAXObjects2.push([concept, axObjects]);
                }
              }
            }
          });
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _loop();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _loop;
    var elementAXObjectMap = {
      entries: function entries() {
        return elementAXObjects2;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator2 = _createForOfIteratorHelper(elementAXObjects2), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _step2$value = _slicedToArray(_step2.value, 2), key = _step2$value[0], values = _step2$value[1];
            fn.call(thisArg, values, key, elementAXObjects2);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      },
      get: function get(key) {
        var item = elementAXObjects2.find(function(tuple) {
          return key.name === tuple[0].name && (0, _lite.dequal)(key.attributes, tuple[0].attributes);
        });
        return item && item[1];
      },
      has: function has(key) {
        return !!elementAXObjectMap.get(key);
      },
      keys: function keys() {
        return elementAXObjects2.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
          return key;
        });
      },
      values: function values() {
        return elementAXObjects2.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(elementAXObjectMap, elementAXObjectMap.entries());
    exports.default = _default;
  }
});

// node_modules/axobject-query/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/axobject-query/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.elementAXObjects = exports.AXObjects = exports.AXObjectRoles = exports.AXObjectElements = void 0;
    var _AXObjectElementMap = _interopRequireDefault(require_AXObjectElementMap());
    var _AXObjectRoleMap = _interopRequireDefault(require_AXObjectRoleMap());
    var _AXObjectsMap = _interopRequireDefault(require_AXObjectsMap());
    var _elementAXObjectMap = _interopRequireDefault(require_elementAXObjectMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var AXObjectElements = _AXObjectElementMap.default;
    exports.AXObjectElements = AXObjectElements;
    var AXObjectRoles2 = _AXObjectRoleMap.default;
    exports.AXObjectRoles = AXObjectRoles2;
    var AXObjects2 = _AXObjectsMap.default;
    exports.AXObjects = AXObjects2;
    var elementAXObjects2 = _elementAXObjectMap.default;
    exports.elementAXObjects = elementAXObjects2;
  }
});

// node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS({
  "node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.resolveURI = factory());
    })(exports, function() {
      "use strict";
      const schemeRegex = /^[\w+.-]+:\/\//;
      const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
      }
      function isSchemeRelativeUrl(input) {
        return input.startsWith("//");
      }
      function isAbsolutePath(input) {
        return input.startsWith("/");
      }
      function isFileUrl(input) {
        return input.startsWith("file:");
      }
      function isRelative(input) {
        return /^[.?#]/.test(input);
      }
      function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
      }
      function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path = match[2];
        return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path) ? path : "/" + path, match[3] || "", match[4] || "");
      }
      function makeUrl(scheme, user, host, port, path, query, hash2) {
        return {
          scheme,
          user,
          host,
          port,
          path,
          query,
          hash: hash2,
          type: 7
        };
      }
      function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
          const url2 = parseAbsoluteUrl("http:" + input);
          url2.scheme = "";
          url2.type = 6;
          return url2;
        }
        if (isAbsolutePath(input)) {
          const url2 = parseAbsoluteUrl("http://foo.com" + input);
          url2.scheme = "";
          url2.host = "";
          url2.type = 5;
          return url2;
        }
        if (isFileUrl(input))
          return parseFileUrl(input);
        if (isAbsoluteUrl(input))
          return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl("http://foo.com/" + input);
        url.scheme = "";
        url.host = "";
        url.type = input ? input.startsWith("?") ? 3 : input.startsWith("#") ? 2 : 4 : 1;
        return url;
      }
      function stripPathFilename(path) {
        if (path.endsWith("/.."))
          return path;
        const index = path.lastIndexOf("/");
        return path.slice(0, index + 1);
      }
      function mergePaths(url, base) {
        normalizePath(base, base.type);
        if (url.path === "/") {
          url.path = base.path;
        } else {
          url.path = stripPathFilename(base.path) + url.path;
        }
      }
      function normalizePath(url, type) {
        const rel = type <= 4;
        const pieces = url.path.split("/");
        let pointer = 1;
        let positive = 0;
        let addTrailingSlash = false;
        for (let i = 1; i < pieces.length; i++) {
          const piece = pieces[i];
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          addTrailingSlash = false;
          if (piece === ".")
            continue;
          if (piece === "..") {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              pieces[pointer++] = piece;
            }
            continue;
          }
          pieces[pointer++] = piece;
          positive++;
        }
        let path = "";
        for (let i = 1; i < pointer; i++) {
          path += "/" + pieces[i];
        }
        if (!path || addTrailingSlash && !path.endsWith("/..")) {
          path += "/";
        }
        url.path = path;
      }
      function resolve(input, base) {
        if (!input && !base)
          return "";
        const url = parseUrl(input);
        let inputType = url.type;
        if (base && inputType !== 7) {
          const baseUrl = parseUrl(base);
          const baseType = baseUrl.type;
          switch (inputType) {
            case 1:
              url.hash = baseUrl.hash;
            case 2:
              url.query = baseUrl.query;
            case 3:
            case 4:
              mergePaths(url, baseUrl);
            case 5:
              url.user = baseUrl.user;
              url.host = baseUrl.host;
              url.port = baseUrl.port;
            case 6:
              url.scheme = baseUrl.scheme;
          }
          if (baseType > inputType)
            inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch (inputType) {
          case 2:
          case 3:
            return queryHash;
          case 4: {
            const path = url.path.slice(1);
            if (!path)
              return queryHash || ".";
            if (isRelative(base || input) && !isRelative(path)) {
              return "./" + path + queryHash;
            }
            return path + queryHash;
          }
          case 5:
            return url.path + queryHash;
          default:
            return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
        }
      }
      return resolve;
    });
  }
});

// node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var require_trace_mapping_umd = __commonJS({
  "node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_sourcemap_codec_umd(), require_resolve_uri_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/sourcemap-codec", "@jridgewell/resolve-uri"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.traceMapping = {}, global.sourcemapCodec, global.resolveURI));
    })(exports, function(exports2, sourcemapCodec, resolveUri) {
      "use strict";
      function resolve(input, base) {
        if (base && !base.endsWith("/"))
          base += "/";
        return resolveUri(input, base);
      }
      function stripFilename(path) {
        if (!path)
          return "";
        const index = path.lastIndexOf("/");
        return path.slice(0, index + 1);
      }
      const COLUMN = 0;
      const SOURCES_INDEX = 1;
      const SOURCE_LINE = 2;
      const SOURCE_COLUMN = 3;
      const NAMES_INDEX = 4;
      const REV_GENERATED_LINE = 1;
      const REV_GENERATED_COLUMN = 2;
      function maybeSort(mappings, owned) {
        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
        if (unsortedIndex === mappings.length)
          return mappings;
        if (!owned)
          mappings = mappings.slice();
        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
          mappings[i] = sortSegments(mappings[i], owned);
        }
        return mappings;
      }
      function nextUnsortedSegmentLine(mappings, start) {
        for (let i = start; i < mappings.length; i++) {
          if (!isSorted(mappings[i]))
            return i;
        }
        return mappings.length;
      }
      function isSorted(line) {
        for (let j = 1; j < line.length; j++) {
          if (line[j][COLUMN] < line[j - 1][COLUMN]) {
            return false;
          }
        }
        return true;
      }
      function sortSegments(line, owned) {
        if (!owned)
          line = line.slice();
        return line.sort(sortComparator);
      }
      function sortComparator(a, b2) {
        return a[COLUMN] - b2[COLUMN];
      }
      let found = false;
      function binarySearch(haystack, needle, low, high) {
        while (low <= high) {
          const mid = low + (high - low >> 1);
          const cmp = haystack[mid][COLUMN] - needle;
          if (cmp === 0) {
            found = true;
            return mid;
          }
          if (cmp < 0) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        found = false;
        return low - 1;
      }
      function upperBound(haystack, needle, index) {
        for (let i = index + 1; i < haystack.length; index = i++) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function lowerBound(haystack, needle, index) {
        for (let i = index - 1; i >= 0; index = i--) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function memoizedState() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function memoizedBinarySearch(haystack, needle, state, key) {
        const { lastKey, lastNeedle, lastIndex } = state;
        let low = 0;
        let high = haystack.length - 1;
        if (key === lastKey) {
          if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
          }
          if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
          } else {
            high = lastIndex;
          }
        }
        state.lastKey = key;
        state.lastNeedle = needle;
        return state.lastIndex = binarySearch(haystack, needle, low, high);
      }
      function buildBySources(decoded, memos) {
        const sources = memos.map(buildNullArray);
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            if (seg.length === 1)
              continue;
            const sourceIndex2 = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const originalSource = sources[sourceIndex2];
            const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
            const memo = memos[sourceIndex2];
            let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
            memo.lastIndex = ++index;
            insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);
          }
        }
        return sources;
      }
      function insert(array, index, value) {
        for (let i = array.length; i > index; i--) {
          array[i] = array[i - 1];
        }
        array[index] = value;
      }
      function buildNullArray() {
        return { __proto__: null };
      }
      const AnyMap = function(map, mapUrl) {
        const parsed = parse58(map);
        if (!("sections" in parsed)) {
          return new TraceMap2(parsed, mapUrl);
        }
        const mappings = [];
        const sources = [];
        const sourcesContent = [];
        const names = [];
        const ignoreList = [];
        recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);
        const joined = {
          version: 3,
          file: parsed.file,
          names,
          sources,
          sourcesContent,
          mappings,
          ignoreList
        };
        return presortedDecodedMap(joined);
      };
      function parse58(map) {
        return typeof map === "string" ? JSON.parse(map) : map;
      }
      function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const { sections } = input;
        for (let i = 0; i < sections.length; i++) {
          const { map, offset: offset2 } = sections[i];
          let sl = stopLine;
          let sc = stopColumn;
          if (i + 1 < sections.length) {
            const nextOffset = sections[i + 1].offset;
            sl = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl === stopLine) {
              sc = Math.min(stopColumn, columnOffset + nextOffset.column);
            } else if (sl < stopLine) {
              sc = columnOffset + nextOffset.column;
            }
          }
          addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset2.line, columnOffset + offset2.column, sl, sc);
        }
      }
      function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const parsed = parse58(input);
        if ("sections" in parsed)
          return recurse(...arguments);
        const map = new TraceMap2(parsed, mapUrl);
        const sourcesOffset = sources.length;
        const namesOffset = names.length;
        const decoded = decodedMappings(map);
        const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;
        append(sources, resolvedSources);
        append(names, map.names);
        if (contents)
          append(sourcesContent, contents);
        else
          for (let i = 0; i < resolvedSources.length; i++)
            sourcesContent.push(null);
        if (ignores)
          for (let i = 0; i < ignores.length; i++)
            ignoreList.push(ignores[i] + sourcesOffset);
        for (let i = 0; i < decoded.length; i++) {
          const lineI = lineOffset + i;
          if (lineI > stopLine)
            return;
          const out = getLine(mappings, lineI);
          const cOffset = i === 0 ? columnOffset : 0;
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const column = cOffset + seg[COLUMN];
            if (lineI === stopLine && column >= stopColumn)
              return;
            if (seg.length === 1) {
              out.push([column]);
              continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
          }
        }
      }
      function append(arr, other) {
        for (let i = 0; i < other.length; i++)
          arr.push(other[i]);
      }
      function getLine(arr, index) {
        for (let i = arr.length; i <= index; i++)
          arr[i] = [];
        return arr[index];
      }
      const LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
      const COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
      const LEAST_UPPER_BOUND = -1;
      const GREATEST_LOWER_BOUND = 1;
      class TraceMap2 {
        constructor(map, mapUrl) {
          const isString = typeof map === "string";
          if (!isString && map._decodedMemo)
            return map;
          const parsed = isString ? JSON.parse(map) : map;
          const { version: version2, file, names, sourceRoot, sources, sourcesContent } = parsed;
          this.version = version2;
          this.file = file;
          this.names = names || [];
          this.sourceRoot = sourceRoot;
          this.sources = sources;
          this.sourcesContent = sourcesContent;
          this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
          const from = resolve(sourceRoot || "", stripFilename(mapUrl));
          this.resolvedSources = sources.map((s) => resolve(s || "", from));
          const { mappings } = parsed;
          if (typeof mappings === "string") {
            this._encoded = mappings;
            this._decoded = void 0;
          } else {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString);
          }
          this._decodedMemo = memoizedState();
          this._bySources = void 0;
          this._bySourceMemos = void 0;
        }
      }
      function cast(map) {
        return map;
      }
      function encodedMappings(map) {
        var _a;
        var _b;
        return (_a = (_b = cast(map))._encoded) !== null && _a !== void 0 ? _a : _b._encoded = sourcemapCodec.encode(cast(map)._decoded);
      }
      function decodedMappings(map) {
        var _a;
        return (_a = cast(map))._decoded || (_a._decoded = sourcemapCodec.decode(cast(map)._encoded));
      }
      function traceSegment(map, line, column) {
        const decoded = decodedMappings(map);
        if (line >= decoded.length)
          return null;
        const segments = decoded[line];
        const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);
        return index === -1 ? null : segments[index];
      }
      function originalPositionFor2(map, needle) {
        let { line, column, bias } = needle;
        line--;
        if (line < 0)
          throw new Error(LINE_GTR_ZERO);
        if (column < 0)
          throw new Error(COL_GTR_EQ_ZERO);
        const decoded = decodedMappings(map);
        if (line >= decoded.length)
          return OMapping(null, null, null, null);
        const segments = decoded[line];
        const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
        if (index === -1)
          return OMapping(null, null, null, null);
        const segment = segments[index];
        if (segment.length === 1)
          return OMapping(null, null, null, null);
        const { names, resolvedSources } = map;
        return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
      }
      function generatedPositionFor(map, needle) {
        const { source, line, column, bias } = needle;
        return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
      }
      function allGeneratedPositionsFor(map, needle) {
        const { source, line, column, bias } = needle;
        return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);
      }
      function eachMapping(map, cb) {
        const decoded = decodedMappings(map);
        const { names, resolvedSources } = map;
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const generatedLine = i + 1;
            const generatedColumn = seg[0];
            let source = null;
            let originalLine = null;
            let originalColumn = null;
            let name49 = null;
            if (seg.length !== 1) {
              source = resolvedSources[seg[1]];
              originalLine = seg[2] + 1;
              originalColumn = seg[3];
            }
            if (seg.length === 5)
              name49 = names[seg[4]];
            cb({
              generatedLine,
              generatedColumn,
              source,
              originalLine,
              originalColumn,
              name: name49
            });
          }
        }
      }
      function sourceIndex(map, source) {
        const { sources, resolvedSources } = map;
        let index = sources.indexOf(source);
        if (index === -1)
          index = resolvedSources.indexOf(source);
        return index;
      }
      function sourceContentFor(map, source) {
        const { sourcesContent } = map;
        if (sourcesContent == null)
          return null;
        const index = sourceIndex(map, source);
        return index === -1 ? null : sourcesContent[index];
      }
      function isIgnored(map, source) {
        const { ignoreList } = map;
        if (ignoreList == null)
          return false;
        const index = sourceIndex(map, source);
        return index === -1 ? false : ignoreList.includes(index);
      }
      function presortedDecodedMap(map, mapUrl) {
        const tracer = new TraceMap2(clone3(map, []), mapUrl);
        cast(tracer)._decoded = map.mappings;
        return tracer;
      }
      function decodedMap(map) {
        return clone3(map, decodedMappings(map));
      }
      function encodedMap(map) {
        return clone3(map, encodedMappings(map));
      }
      function clone3(map, mappings) {
        return {
          version: map.version,
          file: map.file,
          names: map.names,
          sourceRoot: map.sourceRoot,
          sources: map.sources,
          sourcesContent: map.sourcesContent,
          mappings,
          ignoreList: map.ignoreList || map.x_google_ignoreList
        };
      }
      function OMapping(source, line, column, name49) {
        return { source, line, column, name: name49 };
      }
      function GMapping(line, column) {
        return { line, column };
      }
      function traceSegmentInternal(segments, memo, line, column, bias) {
        let index = memoizedBinarySearch(segments, column, memo, line);
        if (found) {
          index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
        } else if (bias === LEAST_UPPER_BOUND)
          index++;
        if (index === -1 || index === segments.length)
          return -1;
        return index;
      }
      function sliceGeneratedPositions(segments, memo, line, column, bias) {
        let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
        if (!found && bias === LEAST_UPPER_BOUND)
          min++;
        if (min === -1 || min === segments.length)
          return [];
        const matchedColumn = found ? column : segments[min][COLUMN];
        if (!found)
          min = lowerBound(segments, matchedColumn, min);
        const max = upperBound(segments, matchedColumn, min);
        const result = [];
        for (; min <= max; min++) {
          const segment = segments[min];
          result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
        }
        return result;
      }
      function generatedPosition(map, source, line, column, bias, all) {
        var _a;
        line--;
        if (line < 0)
          throw new Error(LINE_GTR_ZERO);
        if (column < 0)
          throw new Error(COL_GTR_EQ_ZERO);
        const { sources, resolvedSources } = map;
        let sourceIndex2 = sources.indexOf(source);
        if (sourceIndex2 === -1)
          sourceIndex2 = resolvedSources.indexOf(source);
        if (sourceIndex2 === -1)
          return all ? [] : GMapping(null, null);
        const generated = (_a = cast(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), cast(map)._bySourceMemos = sources.map(memoizedState)));
        const segments = generated[sourceIndex2][line];
        if (segments == null)
          return all ? [] : GMapping(null, null);
        const memo = cast(map)._bySourceMemos[sourceIndex2];
        if (all)
          return sliceGeneratedPositions(segments, memo, line, column, bias);
        const index = traceSegmentInternal(segments, memo, line, column, bias);
        if (index === -1)
          return GMapping(null, null);
        const segment = segments[index];
        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
      }
      exports2.AnyMap = AnyMap;
      exports2.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;
      exports2.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;
      exports2.TraceMap = TraceMap2;
      exports2.allGeneratedPositionsFor = allGeneratedPositionsFor;
      exports2.decodedMap = decodedMap;
      exports2.decodedMappings = decodedMappings;
      exports2.eachMapping = eachMapping;
      exports2.encodedMap = encodedMap;
      exports2.encodedMappings = encodedMappings;
      exports2.generatedPositionFor = generatedPositionFor;
      exports2.isIgnored = isIgnored;
      exports2.originalPositionFor = originalPositionFor2;
      exports2.presortedDecodedMap = presortedDecodedMap;
      exports2.sourceContentFor = sourceContentFor;
      exports2.traceSegment = traceSegment;
    });
  }
});

// node_modules/@jridgewell/set-array/dist/set-array.umd.js
var require_set_array_umd = __commonJS({
  "node_modules/@jridgewell/set-array/dist/set-array.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.setArray = {}));
    })(exports, function(exports2) {
      "use strict";
      class SetArray {
        constructor() {
          this._indexes = { __proto__: null };
          this.array = [];
        }
      }
      function cast(set) {
        return set;
      }
      function get(setarr, key) {
        return cast(setarr)._indexes[key];
      }
      function put(setarr, key) {
        const index = get(setarr, key);
        if (index !== void 0)
          return index;
        const { array, _indexes: indexes } = cast(setarr);
        const length2 = array.push(key);
        return indexes[key] = length2 - 1;
      }
      function pop(setarr) {
        const { array, _indexes: indexes } = cast(setarr);
        if (array.length === 0)
          return;
        const last = array.pop();
        indexes[last] = void 0;
      }
      function remove(setarr, key) {
        const index = get(setarr, key);
        if (index === void 0)
          return;
        const { array, _indexes: indexes } = cast(setarr);
        for (let i = index + 1; i < array.length; i++) {
          const k = array[i];
          array[i - 1] = k;
          indexes[k]--;
        }
        indexes[key] = void 0;
        array.pop();
      }
      exports2.SetArray = SetArray;
      exports2.get = get;
      exports2.pop = pop;
      exports2.put = put;
      exports2.remove = remove;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var require_gen_mapping_umd = __commonJS({
  "node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_set_array_umd(), require_sourcemap_codec_umd(), require_trace_mapping_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.genMapping = {}, global.setArray, global.sourcemapCodec, global.traceMapping));
    })(exports, function(exports2, setArray, sourcemapCodec, traceMapping) {
      "use strict";
      const COLUMN = 0;
      const SOURCES_INDEX = 1;
      const SOURCE_LINE = 2;
      const SOURCE_COLUMN = 3;
      const NAMES_INDEX = 4;
      const NO_NAME = -1;
      class GenMapping {
        constructor({ file, sourceRoot } = {}) {
          this._names = new setArray.SetArray();
          this._sources = new setArray.SetArray();
          this._sourcesContent = [];
          this._mappings = [];
          this.file = file;
          this.sourceRoot = sourceRoot;
          this._ignoreList = new setArray.SetArray();
        }
      }
      function cast(map) {
        return map;
      }
      function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name49, content) {
        return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name49, content);
      }
      function addMapping(map, mapping) {
        return addMappingInternal(false, map, mapping);
      }
      const maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name49, content) => {
        return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name49, content);
      };
      const maybeAddMapping = (map, mapping) => {
        return addMappingInternal(true, map, mapping);
      };
      function setSourceContent(map, source, content) {
        const { _sources: sources, _sourcesContent: sourcesContent } = cast(map);
        const index = setArray.put(sources, source);
        sourcesContent[index] = content;
      }
      function setIgnore(map, source, ignore = true) {
        const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast(map);
        const index = setArray.put(sources, source);
        if (index === sourcesContent.length)
          sourcesContent[index] = null;
        if (ignore)
          setArray.put(ignoreList, index);
        else
          setArray.remove(ignoreList, index);
      }
      function toDecodedMap(map) {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, _ignoreList: ignoreList } = cast(map);
        removeEmptyFinalLines(mappings);
        return {
          version: 3,
          file: map.file || void 0,
          names: names.array,
          sourceRoot: map.sourceRoot || void 0,
          sources: sources.array,
          sourcesContent,
          mappings,
          ignoreList: ignoreList.array
        };
      }
      function toEncodedMap(map) {
        const decoded = toDecodedMap(map);
        return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });
      }
      function fromMap(input) {
        const map = new traceMapping.TraceMap(input);
        const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
        putAll(cast(gen)._names, map.names);
        putAll(cast(gen)._sources, map.sources);
        cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);
        cast(gen)._mappings = traceMapping.decodedMappings(map);
        if (map.ignoreList)
          putAll(cast(gen)._ignoreList, map.ignoreList);
        return gen;
      }
      function allMappings(map) {
        const out = [];
        const { _mappings: mappings, _sources: sources, _names: names } = cast(map);
        for (let i = 0; i < mappings.length; i++) {
          const line = mappings[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const generated = { line: i + 1, column: seg[COLUMN] };
            let source = void 0;
            let original = void 0;
            let name49 = void 0;
            if (seg.length !== 1) {
              source = sources.array[seg[SOURCES_INDEX]];
              original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
              if (seg.length === 5)
                name49 = names.array[seg[NAMES_INDEX]];
            }
            out.push({ generated, source, original, name: name49 });
          }
        }
        return out;
      }
      function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name49, content) {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = cast(map);
        const line = getLine(mappings, genLine);
        const index = getColumnIndex(line, genColumn);
        if (!source) {
          if (skipable && skipSourceless(line, index))
            return;
          return insert(line, index, [genColumn]);
        }
        const sourcesIndex = setArray.put(sources, source);
        const namesIndex = name49 ? setArray.put(names, name49) : NO_NAME;
        if (sourcesIndex === sourcesContent.length)
          sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
        if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
          return;
        }
        return insert(line, index, name49 ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
      }
      function getLine(mappings, index) {
        for (let i = mappings.length; i <= index; i++) {
          mappings[i] = [];
        }
        return mappings[index];
      }
      function getColumnIndex(line, genColumn) {
        let index = line.length;
        for (let i = index - 1; i >= 0; index = i--) {
          const current2 = line[i];
          if (genColumn >= current2[COLUMN])
            break;
        }
        return index;
      }
      function insert(array, index, value) {
        for (let i = array.length; i > index; i--) {
          array[i] = array[i - 1];
        }
        array[index] = value;
      }
      function removeEmptyFinalLines(mappings) {
        const { length: length2 } = mappings;
        let len = length2;
        for (let i = len - 1; i >= 0; len = i, i--) {
          if (mappings[i].length > 0)
            break;
        }
        if (len < length2)
          mappings.length = len;
      }
      function putAll(setarr, array) {
        for (let i = 0; i < array.length; i++)
          setArray.put(setarr, array[i]);
      }
      function skipSourceless(line, index) {
        if (index === 0)
          return true;
        const prev = line[index - 1];
        return prev.length === 1;
      }
      function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
        if (index === 0)
          return false;
        const prev = line[index - 1];
        if (prev.length === 1)
          return false;
        return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
      }
      function addMappingInternal(skipable, map, mapping) {
        const { generated, source, original, name: name49, content } = mapping;
        if (!source) {
          return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
        }
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name49, content);
      }
      exports2.GenMapping = GenMapping;
      exports2.addMapping = addMapping;
      exports2.addSegment = addSegment;
      exports2.allMappings = allMappings;
      exports2.fromMap = fromMap;
      exports2.maybeAddMapping = maybeAddMapping;
      exports2.maybeAddSegment = maybeAddSegment;
      exports2.setIgnore = setIgnore;
      exports2.setSourceContent = setSourceContent;
      exports2.toDecodedMap = toDecodedMap;
      exports2.toEncodedMap = toEncodedMap;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/@ampproject/remapping/dist/remapping.umd.js
var require_remapping_umd = __commonJS({
  "node_modules/@ampproject/remapping/dist/remapping.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(require_trace_mapping_umd(), require_gen_mapping_umd()) : typeof define === "function" && define.amd ? define(["@jridgewell/trace-mapping", "@jridgewell/gen-mapping"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.remapping = factory(global.traceMapping, global.genMapping));
    })(exports, function(traceMapping, genMapping) {
      "use strict";
      const SOURCELESS_MAPPING = SegmentObject("", -1, -1, "", null, false);
      const EMPTY_SOURCES = [];
      function SegmentObject(source, line, column, name49, content, ignore) {
        return { source, line, column, name: name49, content, ignore };
      }
      function Source(map, sources, source, content, ignore) {
        return {
          map,
          sources,
          source,
          content,
          ignore
        };
      }
      function MapSource(map, sources) {
        return Source(map, sources, "", null, false);
      }
      function OriginalSource(source, content, ignore) {
        return Source(null, EMPTY_SOURCES, source, content, ignore);
      }
      function traceMappings(tree) {
        const gen = new genMapping.GenMapping({ file: tree.map.file });
        const { sources: rootSources, map } = tree;
        const rootNames = map.names;
        const rootMappings = traceMapping.decodedMappings(map);
        for (let i = 0; i < rootMappings.length; i++) {
          const segments = rootMappings[i];
          for (let j = 0; j < segments.length; j++) {
            const segment = segments[j];
            const genCol = segment[0];
            let traced = SOURCELESS_MAPPING;
            if (segment.length !== 1) {
              const source2 = rootSources[segment[1]];
              traced = originalPositionFor2(source2, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : "");
              if (traced == null)
                continue;
            }
            const { column, line, name: name49, content, source, ignore } = traced;
            genMapping.maybeAddSegment(gen, i, genCol, source, line, column, name49);
            if (source && content != null)
              genMapping.setSourceContent(gen, source, content);
            if (ignore)
              genMapping.setIgnore(gen, source, true);
          }
        }
        return gen;
      }
      function originalPositionFor2(source, line, column, name49) {
        if (!source.map) {
          return SegmentObject(source.source, line, column, name49, source.content, source.ignore);
        }
        const segment = traceMapping.traceSegment(source.map, line, column);
        if (segment == null)
          return null;
        if (segment.length === 1)
          return SOURCELESS_MAPPING;
        return originalPositionFor2(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name49);
      }
      function asArray(value) {
        if (Array.isArray(value))
          return value;
        return [value];
      }
      function buildSourceMapTree(input, loader) {
        const maps = asArray(input).map((m) => new traceMapping.TraceMap(m, ""));
        const map = maps.pop();
        for (let i = 0; i < maps.length; i++) {
          if (maps[i].sources.length > 1) {
            throw new Error(`Transformation map ${i} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
          }
        }
        let tree = build(map, loader, "", 0);
        for (let i = maps.length - 1; i >= 0; i--) {
          tree = MapSource(maps[i], [tree]);
        }
        return tree;
      }
      function build(map, loader, importer, importerDepth) {
        const { resolvedSources, sourcesContent, ignoreList } = map;
        const depth = importerDepth + 1;
        const children = resolvedSources.map((sourceFile, i) => {
          const ctx = {
            importer,
            depth,
            source: sourceFile || "",
            content: void 0,
            ignore: void 0
          };
          const sourceMap = loader(ctx.source, ctx);
          const { source, content, ignore } = ctx;
          if (sourceMap)
            return build(new traceMapping.TraceMap(sourceMap, source), loader, source, depth);
          const sourceContent = content !== void 0 ? content : sourcesContent ? sourcesContent[i] : null;
          const ignored = ignore !== void 0 ? ignore : ignoreList ? ignoreList.includes(i) : false;
          return OriginalSource(source, sourceContent, ignored);
        });
        return MapSource(map, children);
      }
      class SourceMap2 {
        constructor(map, options) {
          const out = options.decodedMappings ? genMapping.toDecodedMap(map) : genMapping.toEncodedMap(map);
          this.version = out.version;
          this.file = out.file;
          this.mappings = out.mappings;
          this.names = out.names;
          this.ignoreList = out.ignoreList;
          this.sourceRoot = out.sourceRoot;
          this.sources = out.sources;
          if (!options.excludeContent) {
            this.sourcesContent = out.sourcesContent;
          }
        }
        toString() {
          return JSON.stringify(this);
        }
      }
      function remapping2(input, loader, options) {
        const opts = typeof options === "object" ? options : { excludeContent: !!options, decodedMappings: false };
        const tree = buildSourceMapTree(input, loader);
        return new SourceMap2(traceMappings(tree), opts);
      }
      return remapping2;
    });
  }
});

// node_modules/svelte/src/compiler/Stats.js
var now = () => performance.now();
function collapse_timings(timings) {
  const result = {};
  timings.forEach((timing) => {
    result[timing.label] = Object.assign(
      {
        total: timing.end - timing.start
      },
      timing.children && collapse_timings(timing.children)
    );
  });
  return result;
}
var Stats = class {
  constructor() {
    /**
     * @typedef {Object} Timing
     * @property {string} label
     * @property {number} start
     * @property {number} end
     * @property {Timing[]} children
     */
    /** @type {number} */
    __publicField(this, "start_time");
    /** @type {Timing} */
    __publicField(this, "current_timing");
    /** @type {Timing[]} */
    __publicField(this, "current_children");
    /** @type {Timing[]} */
    __publicField(this, "timings");
    /** @type {Timing[]} */
    __publicField(this, "stack");
    this.start_time = now();
    this.stack = [];
    this.current_children = this.timings = [];
  }
  /** @param {any} label */
  start(label) {
    const timing = {
      label,
      start: now(),
      end: null,
      children: []
    };
    this.current_children.push(timing);
    this.stack.push(timing);
    this.current_timing = timing;
    this.current_children = timing.children;
  }
  /** @param {any} label */
  stop(label) {
    if (label !== this.current_timing.label) {
      throw new Error(
        `Mismatched timing labels (expected ${this.current_timing.label}, got ${label})`
      );
    }
    this.current_timing.end = now();
    this.stack.pop();
    this.current_timing = this.stack[this.stack.length - 1];
    this.current_children = this.current_timing ? this.current_timing.children : this.timings;
  }
  render() {
    const timings = Object.assign(
      {
        total: now() - this.start_time
      },
      collapse_timings(this.timings)
    );
    return {
      timings
    };
  }
};

// node_modules/acorn/dist/acorn.mjs
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code2, set) {
  var pos = 65536;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code2) {
      return false;
    }
    pos += set[i + 1];
    if (pos >= code2) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code2, astral) {
  if (code2 < 65) {
    return code2 === 36;
  }
  if (code2 < 91) {
    return true;
  }
  if (code2 < 97) {
    return code2 === 95;
  }
  if (code2 < 123) {
    return true;
  }
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code2, astralIdentifierStartCodes);
}
function isIdentifierChar(code2, astral) {
  if (code2 < 48) {
    return code2 === 36;
  }
  if (code2 < 58) {
    return true;
  }
  if (code2 < 65) {
    return false;
  }
  if (code2 < 91) {
    return true;
  }
  if (code2 < 97) {
    return code2 === 95;
  }
  if (code2 < 123) {
    return true;
  }
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === void 0)
    conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name49, prec) {
  return new TokenType(name49, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords = {};
function kw(name49, options) {
  if (options === void 0)
    options = {};
  options.keyword = name49;
  return keywords[name49] = new TokenType(name49, options);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code2) {
  return code2 === 10 || code2 === 13 || code2 === 8232 || code2 === 8233;
}
function nextLineBreak(code2, from, end) {
  if (end === void 0)
    end = code2.length;
  for (var i = from; i < end; i++) {
    var next = code2.charCodeAt(i);
    if (isNewLine(next)) {
      return i < end - 1 && next === 13 && code2.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty2 = ref.hasOwnProperty;
var toString = ref.toString;
var hasOwn = Object.hasOwn || function(obj, propName) {
  return hasOwnProperty2.call(obj, propName);
};
var isArray = Array.isArray || function(obj) {
  return toString.call(obj) === "[object Array]";
};
var regexpCache = /* @__PURE__ */ Object.create(null);
function wordsRegexp(words) {
  return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
}
function codePointToString(code2) {
  if (code2 <= 65535) {
    return String.fromCharCode(code2);
  }
  code2 -= 65536;
  return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line, col) {
  this.line = line;
  this.column = col;
};
Position.prototype.offset = function offset(n2) {
  return new Position(this.line, this.column + n2);
};
var SourceLocation = function SourceLocation2(p2, start, end) {
  this.start = start;
  this.end = end;
  if (p2.sourceFile !== null) {
    this.source = p2.sourceFile;
  }
};
function getLineInfo(input, offset2) {
  for (var line = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line, offset2 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called when
  // a semicolon is automatically inserted. It will be passed the
  // position of the inserted semicolon as an offset, and if
  // `locations` is enabled, it is given the location as a `{line,
  // column}` object as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: true,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  // When this option has an array as value, objects representing the
  // comments are pushed to it.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }
  if (options.allowReserved == null) {
    options.allowReserved = options.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options.allowHashBang = options.ecmaVersion >= 14;
  }
  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options.onComment)) {
    options.onComment = pushComment(options, options.onComment);
  }
  return options;
}
function pushComment(options, array) {
  return function(block, text2, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text2,
      start,
      end
    };
    if (options.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options.ranges) {
      comment.range = [start, end];
    }
    array.push(comment);
  };
}
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;
var SCOPE_CLASS_STATIC_BLOCK = 256;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5;
var Parser = function Parser2(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved2 = "";
  if (options.allowReserved !== true) {
    reserved2 = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
    if (options.sourceType === "module") {
      reserved2 += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved2);
  var reservedStrict = (reserved2 ? reserved2 + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse() {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.canAwait.get = function() {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var scope = this.scopeStack[i];
    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
      return false;
    }
    if (scope.flags & SCOPE_FUNCTION) {
      return (scope.flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend() {
  var plugins = [], len = arguments.length;
  while (len--)
    plugins[len] = arguments[len];
  var cls = this;
  for (var i = 0; i < plugins.length; i++) {
    cls = plugins[i](cls);
  }
  return cls;
};
Parser.parse = function parse2(input, options) {
  return new this(options, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options) {
  return new this(options, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) {
      return false;
    }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
    }
    start += match[0].length;
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";") {
      start++;
    }
  }
};
pp$9.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name49) {
  return this.type === types$1.name && this.value === name49 && !this.containsEsc;
};
pp$9.eatContextual = function(name49) {
  if (!this.isContextual(name49)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name49) {
  if (!this.eatContextual(name49)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type) {
  this.eat(type) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node) {
  var exports = /* @__PURE__ */ Object.create(null);
  if (!node.body) {
    node.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule) {
    for (var i = 0, list2 = Object.keys(this.undefinedExports); i < list2.length; i += 1) {
      var name49 = list2[i];
      this.raiseRecoverable(this.undefinedExports[name49].start, "Export '" + name49 + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program");
};
var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
};
pp$8.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;
  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node);
    case types$1._do:
      return this.parseDoStatement(node);
    case types$1._for:
      return this.parseForStatement(node);
    case types$1._function:
      if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node, false, !context);
    case types$1._class:
      if (context) {
        this.unexpected();
      }
      return this.parseClass(node, true);
    case types$1._if:
      return this.parseIfStatement(node);
    case types$1._return:
      return this.parseReturnStatement(node);
    case types$1._switch:
      return this.parseSwitchStatement(node);
    case types$1._throw:
      return this.parseThrowStatement(node);
    case types$1._try:
      return this.parseTryStatement(node);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node, kind);
    case types$1._while:
      return this.parseWhileStatement(node);
    case types$1._with:
      return this.parseWithStatement(node);
    case types$1.braceL:
      return this.parseBlock(true, node);
    case types$1.semi:
      return this.parseEmptyStatement(node);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports);
    default:
      if (this.isAsyncFunction()) {
        if (context) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node, true, !context);
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node, keyword2) {
  var isBreak = keyword2 === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node.label = this.parseIdent();
    this.semicolon();
  }
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node.label && isBreak) {
        break;
      }
    }
  }
  if (i === this.labels.length) {
    this.raise(node.start, "Unsyntactic " + keyword2);
  }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node, "DoWhileStatement");
};
pp$8.parseForStatement = function(node) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node.await = awaitAt > -1;
        }
      }
      return this.parseForIn(node, init$1);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, init$1);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var refDestructuringErrors = new DestructuringErrors();
  var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node.await = awaitAt > -1;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLValPattern(init);
    return this.parseForIn(node, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node, init);
};
pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement");
};
pp$8.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple = param.type === "Identifier";
  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);
  return param;
};
pp$8.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }
  return this.finishNode(node, "TryStatement");
};
pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};
pp$8.parseWithStatement = function(node) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement");
};
pp$8.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
    var label = list2[i$1];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
  if (createNewLexicalScope === void 0)
    createNewLexicalScope = true;
  if (node === void 0)
    node = this.startNode();
  node.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node, "BlockStatement");
};
pp$8.parseFor = function(node, init) {
  node.init = init;
  this.expect(types$1.semi);
  node.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};
pp$8.parseForIn = function(node, init) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
    this.raise(
      init.start,
      (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    );
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
  node.declarations = [];
  node.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node) {
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) {
          this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
        this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion = this.options.ecmaVersion;
  var node = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node);
      return node;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node.computed = false;
    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node.key.name = keyName;
    this.finishNode(node.key, "Identifier");
  } else {
    this.parseClassElementName(node);
  }
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node.static && checkKeyName(node, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node.key.start, "Constructor can't have get/set modifier");
    }
    node.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node);
  }
  return node;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element.computed = false;
    element.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element);
  }
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  var key = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) {
      this.raise(key.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key.start, "Constructor can't be an async method");
    }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && value.params.length !== 0) {
    this.raiseRecoverable(value.start, "getter should have no params");
  }
  if (method.kind === "set" && value.params.length !== 1) {
    this.raiseRecoverable(value.start, "setter should have exactly one param");
  }
  if (method.kind === "set" && value.params[0].type === "RestElement") {
    this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    var scope = this.currentThisScope();
    var inClassFieldInit = scope.inClassFieldInit;
    scope.inClassFieldInit = true;
    field.value = this.parseMaybeAssign();
    scope.inClassFieldInit = inClassFieldInit;
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node) {
  node.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node, "StaticBlock");
};
pp$8.parseClassId = function(node, isStatement) {
  if (this.type === types$1.name) {
    node.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node.id = null;
  }
};
pp$8.parseClassSuper = function(node) {
  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element);
  return element.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  if (!this.options.checkPrivateFields) {
    return;
  }
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i = 0; i < used.length; ++i) {
    var id2 = used[i];
    if (!hasOwn(declared, id2.name)) {
      if (parent) {
        parent.used.push(id2);
      } else {
        this.raiseRecoverable(id2.start, "Private field '#" + id2.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element) {
  var name49 = element.key.name;
  var curr = privateNameMap[name49];
  var next = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next = (element.static ? "s" : "i") + element.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name49] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name49] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node, name49) {
  var computed = node.computed;
  var key = node.key;
  return !computed && (key.type === "Identifier" && key.name === name49 || key.type === "Literal" && key.value === name49);
}
pp$8.parseExportAllDeclaration = function(node, exports) {
  if (this.options.ecmaVersion >= 11) {
    if (this.eatContextual("as")) {
      node.exported = this.parseModuleExportName();
      this.checkExport(exports, node.exported, this.lastTokStart);
    } else {
      node.exported = null;
    }
  }
  this.expectContextual("from");
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.source = this.parseExprAtom();
  this.semicolon();
  return this.finishNode(node, "ExportAllDeclaration");
};
pp$8.parseExport = function(node, exports) {
  this.next();
  if (this.eat(types$1.star)) {
    return this.parseExportAllDeclaration(node, exports);
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports, "default", this.lastTokStart);
    node.declaration = this.parseExportDefaultDeclaration();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseExportDeclaration(node);
    if (node.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports, node.declaration.declarations);
    } else {
      this.checkExport(exports, node.declaration.id, node.declaration.id.start);
    }
    node.specifiers = [];
    node.source = null;
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node.source = this.parseExprAtom();
    } else {
      for (var i = 0, list2 = node.specifiers; i < list2.length; i += 1) {
        var spec2 = list2[i];
        this.checkUnreserved(spec2.local);
        this.checkLocalExport(spec2.local);
        if (spec2.local.type === "Literal") {
          this.raise(spec2.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node) {
  return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
  var isAsync;
  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) {
      this.next();
    }
    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types$1._class) {
    var cNode = this.startNode();
    return this.parseClass(cNode, "nullableID");
  } else {
    var declaration = this.parseMaybeAssign();
    this.semicolon();
    return declaration;
  }
};
pp$8.checkExport = function(exports, name49, pos) {
  if (!exports) {
    return;
  }
  if (typeof name49 !== "string") {
    name49 = name49.type === "Identifier" ? name49.name : name49.value;
  }
  if (hasOwn(exports, name49)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name49 + "'");
  }
  exports[name49] = true;
};
pp$8.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier") {
    this.checkExport(exports, pat, pat.start);
  } else if (type === "ObjectPattern") {
    for (var i = 0, list2 = pat.properties; i < list2.length; i += 1) {
      var prop = list2[i];
      this.checkPatternExport(exports, prop);
    }
  } else if (type === "ArrayPattern") {
    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];
      if (elt) {
        this.checkPatternExport(exports, elt);
      }
    }
  } else if (type === "Property") {
    this.checkPatternExport(exports, pat.value);
  } else if (type === "AssignmentPattern") {
    this.checkPatternExport(exports, pat.left);
  } else if (type === "RestElement") {
    this.checkPatternExport(exports, pat.argument);
  }
};
pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) {
    return;
  }
  for (var i = 0, list2 = decls; i < list2.length; i += 1) {
    var decl = list2[i];
    this.checkPatternExport(exports, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports) {
  var node = this.startNode();
  node.local = this.parseModuleExportName();
  node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
  this.checkExport(
    exports,
    node.exported,
    node.exported.start
  );
  return this.finishNode(node, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseExportSpecifier(exports));
  }
  return nodes;
};
pp$8.parseImport = function(node) {
  this.next();
  if (this.type === types$1.string) {
    node.specifiers = empty$1;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
  var node = this.startNode();
  node.imported = this.parseModuleExportName();
  if (this.eatContextual("as")) {
    node.local = this.parseIdent();
  } else {
    this.checkUnreserved(node.imported);
    node.local = node.imported;
  }
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
  var node = this.startNode();
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
  var node = this.startNode();
  this.next();
  this.expectContextual("as");
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    nodes.push(this.parseImportDefaultSpecifier());
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    nodes.push(this.parseImportNamespaceSpecifier());
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseImportSpecifier());
  }
  return nodes;
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
  (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await") {
          this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i = 0, list2 = node.properties; i < list2.length; i += 1) {
          var prop = list2[i];
          this.toAssignable(prop, isBinding);
          if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node.kind !== "init") {
          this.raise(node.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node.value, isBinding);
        break;
      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node.elements, isBinding);
        break;
      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern") {
          this.raise(node.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node.operator !== "=") {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node.argument = this.parseBindingAtom();
  return this.finishNode(node, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close);
      break;
    } else {
      elts.push(this.parseAssignableListItem(allowModifiers));
    }
  }
  return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
  return elem;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i = 0, list2 = expr.properties; i < list2.length; i += 1) {
        var prop = list2[i];
        this.checkLValInnerPattern(prop, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p2) {
    return p2.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function") {
      return context.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update = type.updateContext) {
    update.call(this, prevType);
  } else {
    this.exprAllowed = type.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
    this.context.push(types.f_expr);
  } else {
    this.context.push(types.f_stat);
  }
  this.exprAllowed = false;
};
types$1.colon.updateContext = function() {
  if (this.curContext().token === "function") {
    this.context.pop();
  }
  this.exprAllowed = true;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types.f_expr) {
      this.context[index] = types.f_expr_gen;
    } else {
      this.context[index] = types.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
    return;
  }
  var key = prop.key;
  var name49;
  switch (key.type) {
    case "Identifier":
      name49 = key.name;
      break;
    case "Literal":
      name49 = String(key.value);
      break;
    default:
      return;
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name49 === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          }
        } else {
          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name49 = "$" + name49;
  var other = propHash[name49];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key.start, "Redefinition of property");
    }
  } else {
    other = propHash[name49] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node.left = left;
    this.next();
    node.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types$1.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) {
      this.checkLValSimple(node.argument);
    } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
      this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
    } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isPrivateFieldAccess(node) {
  return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
  var optionalChained = false;
  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element.optional) {
      optionalChained = true;
    }
    if (element === base || element.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element;
        element = this.finishNode(chainNode, "ChainExpression");
      }
      return element;
    }
    base = element;
  }
};
pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    if (computed) {
      node.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node.property = this.parsePrivateIdent();
    } else {
      node.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node.computed = !!computed;
    if (optionalSupported) {
      node.optional = optional;
    }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional;
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node, "Super");
    case types$1._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id2 = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id2.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id2 = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], true, forInit);
        }
      }
      return id2;
    case types$1.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = { pattern: value.pattern, flags: value.flags };
      return node;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node = this.startNode();
      node.value = this.type === types$1._null ? null : this.type === types$1._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");
    case types$1.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start;
        }
      }
      return expr;
    case types$1.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport(forNew);
      } else {
        return this.unexpected();
      }
    default:
      return this.parseExprAtomDefault();
  }
};
pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
  var node = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  this.next();
  if (this.type === types$1.parenL && !forNew) {
    return this.parseDynamicImport(node);
  } else if (this.type === types$1.dot) {
    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta.name = "import";
    node.meta = this.finishNode(meta, "Identifier");
    return this.parseImportMeta(node);
  } else {
    this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node) {
  this.next();
  node.source = this.parseMaybeAssign();
  if (!this.eat(types$1.parenR)) {
    var errorPos = this.start;
    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
    } else {
      this.unexpected(errorPos);
    }
  }
  return this.finishNode(node, "ImportExpression");
};
pp$5.parseImportMeta = function(node) {
  this.next();
  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);
  if (node.property.name !== "meta") {
    this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
    node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.shouldParseArrow = function(exprList) {
  return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raiseRecoverable(
            this.start,
            "Comma is not permitted after the rest element"
          );
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta.name = "new";
    node.meta = this.finishNode(meta, "Identifier");
    this.next();
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") {
      this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
  if (this.eat(types$1.parenL)) {
    node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node.arguments = empty;
  }
  return this.finishNode(node, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === void 0)
    isTagged = false;
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop, propHash, refDestructuringErrors);
    }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement");
    }
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property");
};
pp$5.parseGetterSetter = function(prop) {
  prop.kind = prop.key.name;
  this.parsePropertyName(prop);
  prop.value = this.parseMethod(false);
  var paramCount = prop.kind === "get" ? 0 : 1;
  if (prop.value.params.length !== paramCount) {
    var start = prop.value.start;
    if (prop.kind === "get") {
      this.raiseRecoverable(start, "getter should have no params");
    } else {
      this.raiseRecoverable(start, "setter should have exactly one param");
    }
  } else {
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
      this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
    }
  }
};
pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.parseGetterSetter(prop);
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else {
      prop.value = this.copyNode(prop.key);
    }
    prop.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = node.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) {
    node.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node.body = this.parseMaybeAssign(forInit);
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    if (this.strict && node.id) {
      this.checkLValSimple(node.id, BIND_OUTSIDE);
    }
    node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i = 0, list2 = params; i < list2.length; i += 1) {
    var param = list2[i];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i = 0, list2 = node.params; i < list2.length; i += 1) {
    var param = list2[i];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) {
        break;
      }
    } else {
      first = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start = ref2.start;
  var end = ref2.end;
  var name49 = ref2.name;
  if (this.inGenerator && name49 === "yield") {
    this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name49 === "await") {
    this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
  }
  if (this.currentThisScope().inClassFieldInit && name49 === "arguments") {
    this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name49 === "arguments" || name49 === "await")) {
    this.raise(start, "Cannot use " + name49 + " in class static initialization block");
  }
  if (this.keywords.test(name49)) {
    this.raise(start, "Unexpected keyword '" + name49 + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
    return;
  }
  var re2 = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re2.test(name49)) {
    if (!this.inAsync && name49 === "await") {
      this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start, "The keyword '" + name49 + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node = this.parseIdentNode();
  this.next(!!liberal);
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node.start;
    }
  }
  return node;
};
pp$5.parseIdentNode = function() {
  var node = this.startNode();
  if (this.type === types$1.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;
    if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
    this.type = types$1.name;
  } else {
    this.unexpected();
  }
  return node;
};
pp$5.parsePrivateIdent = function() {
  var node = this.startNode();
  if (this.type === types$1.privateId) {
    node.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "PrivateIdentifier");
  if (this.options.checkPrivateFields) {
    if (this.privateNameStack.length === 0) {
      this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
    } else {
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
    }
  }
  return node;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types$1.star);
    node.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
  this.inClassFieldInit = false;
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name49, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name49) > -1 || scope.functions.indexOf(name49) > -1 || scope.var.indexOf(name49) > -1;
    scope.lexical.push(name49);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name49];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name49);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name49) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name49) > -1 || scope$2.var.indexOf(name49) > -1;
    }
    scope$2.functions.push(name49);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name49) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name49) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name49) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name49);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name49];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name49 + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id2) {
  if (this.scopeStack[0].lexical.indexOf(id2.name) === -1 && this.scopeStack[0].var.indexOf(id2.name) === -1) {
    this.undefinedExports[id2.name] = id2;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node = function Node2(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) {
    this.loc = new SourceLocation(parser, loc);
  }
  if (parser.options.directSourceFile) {
    this.sourceFile = parser.options.directSourceFile;
  }
  if (parser.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) {
    node.loc.end = loc;
  }
  if (this.options.ranges) {
    node.range[1] = pos;
  }
  return node;
}
pp$2.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};
pp$2.copyNode = function(node) {
  var newNode = new Node(this, node.start, this.startLoc);
  for (var prop in node) {
    newNode[prop] = node[prop];
  }
  return newNode;
};
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;
  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
for (i = 0, list2 = [9, 10, 11, 12, 13, 14]; i < list2.length; i += 1) {
  ecmaVersion = list2[i];
  buildUnicodeData(ecmaVersion);
}
var ecmaVersion;
var i;
var list2;
var pp$1 = Parser.prototype;
var RegExpValidationState = function RegExpValidationState2(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchV = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};
RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
  var unicodeSets = flags.indexOf("v") !== -1;
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
    this.switchU = true;
    this.switchV = true;
    this.switchN = true;
  } else {
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchV = false;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }
};
RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1;
  }
  var c2 = s.charCodeAt(i);
  if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i + 1 >= l) {
    return c2;
  }
  var next = s.charCodeAt(i + 1);
  return next >= 56320 && next <= 57343 ? (c2 << 10) + next - 56613888 : c2;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l;
  }
  var c2 = s.charCodeAt(i), next;
  if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
    return i + 1;
  }
  return i + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0)
    forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
  if (forceU === void 0)
    forceU = false;
  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true;
  }
  return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
  if (forceU === void 0)
    forceU = false;
  var pos = this.pos;
  for (var i = 0, list2 = chs; i < list2.length; i += 1) {
    var ch = list2[i];
    var current2 = this.at(pos, forceU);
    if (current2 === -1 || current2 !== ch) {
      return false;
    }
    pos = this.nextIndex(pos, forceU);
  }
  this.pos = pos;
  return true;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  var u = false;
  var v = false;
  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
    if (flag === "u") {
      u = true;
    }
    if (flag === "v") {
      v = true;
    }
  }
  if (this.options.ecmaVersion >= 15 && u && v) {
    this.raise(state.start, "Invalid regular expression flag");
  }
};
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(
      41
      /* ) */
    )) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(
      93
      /* ] */
    ) || state.eat(
      125
      /* } */
    )) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list2 = state.backReferenceNames; i < list2.length; i += 1) {
    var name49 = list2[i];
    if (state.groupNames.indexOf(name49) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(
    124
    /* | */
  )) {
    this.regexp_alternative(state);
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(
    123
    /* { */
  )) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
  }
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(
    94
    /* ^ */
  ) || state.eat(
    36
    /* $ */
  )) {
    return true;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    if (state.eat(
      66
      /* B */
    ) || state.eat(
      98
      /* b */
    )) {
      return true;
    }
    state.pos = start;
  }
  if (state.eat(
    40
    /* ( */
  ) && state.eat(
    63
    /* ? */
  )) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(
        60
        /* < */
      );
    }
    if (state.eat(
      61
      /* = */
    ) || state.eat(
      33
      /* ! */
    )) {
      this.regexp_disjunction(state);
      if (!state.eat(
        41
        /* ) */
      )) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === void 0)
    noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(
      63
      /* ? */
    );
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(
    42
    /* * */
  ) || state.eat(
    43
    /* + */
  ) || state.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(
    123
    /* { */
  )) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(
        44
        /* , */
      ) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(
        125
        /* } */
      )) {
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(
    40
    /* ( */
  )) {
    if (state.eat(
      63
      /* ? */
    ) && state.eat(
      58
      /* : */
    )) {
      this.regexp_disjunction(state);
      if (state.eat(
        41
        /* ) */
      )) {
        return true;
      }
      state.raise("Unterminated group");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(
      41
      /* ) */
    )) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(
    63
    /* ? */
  )) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return;
    }
    state.raise("Invalid group");
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
      62
      /* > */
    )) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n2 = state.lastIntValue;
    if (state.switchU) {
      if (n2 > state.maxBackReference) {
        state.maxBackReference = n2;
      }
      return true;
    }
    if (n2 <= state.numCapturingParens) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === void 0)
    forceU = false;
  var start = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(
          92
          /* \ */
        ) && state.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(state) && state.eat(
      125
      /* } */
    ) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }
  return false;
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(
      47
      /* / */
    )) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch = state.current();
  if (ch !== 99 && (!state.switchN || ch !== 107)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 49 && ch <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
      state.advance();
    } while ((ch = state.current()) >= 48 && ch <= 57);
    return true;
  }
  return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();
  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return CharSetOk;
  }
  var negate = false;
  if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
    state.lastIntValue = -1;
    state.advance();
    var result;
    if (state.eat(
      123
      /* { */
    ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
      125
      /* } */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Invalid property name");
      }
      return result;
    }
    state.raise("Invalid property name");
  }
  return CharSetNone;
};
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(
    61
    /* = */
  )) {
    var name49 = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name49, value);
      return CharSetOk;
    }
  }
  state.pos = start;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
  }
  return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name49, value) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name49)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name49].test(value)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (state.unicodeProperties.binary.test(nameOrValue)) {
    return CharSetOk;
  }
  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
    return CharSetString;
  }
  state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (!state.eat(
      93
      /* ] */
    )) {
      state.raise("Unterminated character class");
    }
    if (negate && result === CharSetString) {
      state.raise("Negated character class may contain strings");
    }
    return true;
  }
  return false;
};
pp$1.regexp_classContents = function(state) {
  if (state.current() === 93) {
    return CharSetOk;
  }
  if (state.switchV) {
    return this.regexp_classSetExpression(state);
  }
  this.regexp_nonEmptyClassRanges(state);
  return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  var ch = state.current();
  if (ch !== 93) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    98
    /* b */
  )) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(
    45
    /* - */
  )) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
  var result = CharSetOk, subResult;
  if (this.regexp_eatClassSetRange(state))
    ;
  else if (subResult = this.regexp_eatClassSetOperand(state)) {
    if (subResult === CharSetString) {
      result = CharSetString;
    }
    var start = state.pos;
    while (state.eatChars(
      [38, 38]
      /* && */
    )) {
      if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
        if (subResult !== CharSetString) {
          result = CharSetOk;
        }
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
    while (state.eatChars(
      [45, 45]
      /* -- */
    )) {
      if (this.regexp_eatClassSetOperand(state)) {
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
  } else {
    state.raise("Invalid character in character class");
  }
  for (; ; ) {
    if (this.regexp_eatClassSetRange(state)) {
      continue;
    }
    subResult = this.regexp_eatClassSetOperand(state);
    if (!subResult) {
      return result;
    }
    if (subResult === CharSetString) {
      result = CharSetString;
    }
  }
};
pp$1.regexp_eatClassSetRange = function(state) {
  var start = state.pos;
  if (this.regexp_eatClassSetCharacter(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassSetCharacter(state)) {
      var right = state.lastIntValue;
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
  if (this.regexp_eatClassSetCharacter(state)) {
    return CharSetOk;
  }
  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
  var start = state.pos;
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (state.eat(
      93
      /* ] */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return result;
    }
    state.pos = start;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    var result$1 = this.regexp_eatCharacterClassEscape(state);
    if (result$1) {
      return result$1;
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
  var start = state.pos;
  if (state.eatChars(
    [92, 113]
    /* \q */
  )) {
    if (state.eat(
      123
      /* { */
    )) {
      var result = this.regexp_classStringDisjunctionContents(state);
      if (state.eat(
        125
        /* } */
      )) {
        return result;
      }
    } else {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
  var result = this.regexp_classString(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (this.regexp_classString(state) === CharSetString) {
      result = CharSetString;
    }
  }
  return result;
};
pp$1.regexp_classString = function(state) {
  var count = 0;
  while (this.regexp_eatClassSetCharacter(state)) {
    count++;
  }
  return count === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
      return true;
    }
    if (state.eat(
      98
      /* b */
    )) {
      state.lastIntValue = 8;
      return true;
    }
    state.pos = start;
    return false;
  }
  var ch = state.current();
  if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
    return false;
  }
  if (isClassSetSyntaxCharacter(ch)) {
    return false;
  }
  state.advance();
  state.lastIntValue = ch;
  return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch) {
  return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
}
function isClassSetSyntaxCharacter(ch) {
  return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
  var ch = state.current();
  if (isClassSetReservedPunctuator(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isClassSetReservedPunctuator(ch) {
  return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 95) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
    state.advance();
  }
  return state.pos !== start;
};
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start;
};
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length2) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length2; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true;
};
var Token = function Token2(p2) {
  this.type = p2.type;
  this.value = p2.value;
  this.start = p2.start;
  this.end = p2.end;
  if (p2.options.locations) {
    this.loc = new SourceLocation(p2, p2.startLoc, p2.endLoc);
  }
  if (p2.options.ranges) {
    this.range = [p2.start, p2.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code2) {
  if (isIdentifierStart(code2, this.options.ecmaVersion >= 6) || code2 === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code2);
};
pp.fullCharCodeAtPos = function() {
  var code2 = this.input.charCodeAt(this.pos);
  if (code2 <= 55295 || code2 >= 56320) {
    return code2;
  }
  var next = this.input.charCodeAt(this.pos + 1);
  return next <= 56319 || next >= 57344 ? code2 : (code2 << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(
      true,
      this.input.slice(start + 2, end),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(
      false,
      this.input.slice(start + startSkip, this.pos),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipSpace = function() {
  loop:
    while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          if (this.input.charCodeAt(this.pos + 1) === 10) {
            ++this.pos;
          }
        case 10:
        case 8232:
        case 8233:
          ++this.pos;
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break loop;
          }
          break;
        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.pos;
          } else {
            break loop;
          }
      }
    }
};
pp.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) {
    return this.readNumber(true);
  }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code2 === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code2 === 42 && next === 42) {
    ++size;
    tokentype = types$1.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code2) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code2 === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code2 === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code2) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code2) {
    size = code2 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next === 33 && code2 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code2 === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code2 === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion = this.options.ecmaVersion;
  var code2 = 35;
  if (ecmaVersion >= 13) {
    ++this.pos;
    code2 = this.fullCharCodeAtPos();
    if (isIdentifierStart(code2, true) || code2 === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
};
pp.getTokenFromCode = function(code2) {
  switch (code2) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) {
          return this.readRadixNumber(8);
        }
        if (next === 98 || next === 66) {
          return this.readRadixNumber(2);
        }
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    case 34:
    case 39:
      return this.readString(code2);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code2);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code2);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code2);
    case 60:
    case 62:
      return this.readToken_lt_gt(code2);
    case 61:
    case 33:
      return this.readToken_eq_excl(code2);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
};
pp.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};
pp.readRegexp = function() {
  var escaped2, inClass, start = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start, "Unterminated regular expression");
    }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) {
      this.raise(start, "Unterminated regular expression");
    }
    if (!escaped2) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }
      escaped2 = ch === "\\";
    } else {
      escaped2 = false;
    }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
  }
  return this.finishToken(types$1.regexp, { pattern, flags, value });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start = this.pos, total = 0, lastCode = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
    var code2 = this.input.charCodeAt(this.pos), val = void 0;
    if (allowSeparators && code2 === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code2;
      continue;
    }
    if (code2 >= 97) {
      val = code2 - 97 + 10;
    } else if (code2 >= 65) {
      val = code2 - 65 + 10;
    } else if (code2 >= 48 && code2 <= 57) {
      val = code2 - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code2;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start || len != null && this.pos - start !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start, "Invalid number");
  }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) {
    this.raise(start, "Invalid number");
  }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
    octal = false;
  }
  if (next === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code2;
  if (ch === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code2 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code2 > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code2 = this.readHexChar(4);
  }
  return code2;
};
pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) {
      break;
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 8232 || ch === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position, message);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n";
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return codePointToString(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch)) {
        return "";
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n2 = this.readInt(16, len);
  if (n2 === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n2;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 65535 ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word = this.readWord1();
  var type = types$1.name;
  if (this.keywords.test(word)) {
    type = keywords[word];
  }
  return this.finishToken(type, word);
};
var version = "8.11.3";
Parser.acorn = {
  Parser,
  version,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};
function parse3(input, options) {
  return Parser.parse(input, options);
}
function parseExpressionAt2(input, pos, options) {
  return Parser.parseExpressionAt(input, pos, options);
}

// node_modules/svelte/src/compiler/utils/flatten.js
function flatten(nodes, target = []) {
  for (let i = 0; i < nodes.length; i += 1) {
    const node = nodes[i];
    if (Array.isArray(node)) {
      flatten(node, target);
    } else {
      target.push(node);
    }
  }
  return target;
}

// node_modules/svelte/src/compiler/utils/patterns.js
var regex_whitespace = /\s/;
var regex_whitespaces = /\s+/;
var regex_starts_with_whitespace = /^\s/;
var regex_starts_with_whitespaces = /^[ \t\r\n]*/;
var regex_ends_with_whitespace = /\s$/;
var regex_ends_with_whitespaces = /[ \t\r\n]*$/;
var regex_only_whitespaces = /^[ \t\n\r\f]+$/;
var regex_whitespace_characters = /\s/g;
var regex_non_whitespace_character = /\S/;
var regex_starts_with_newline = /^\r?\n/;
var regex_not_newline_characters = /[^\n]/g;
var regex_double_quotes = /"/g;
var regex_backslashes = /\\/g;
var regex_starts_with_underscore = /^_/;
var regex_ends_with_underscore = /_$/;
var regex_dimensions = /^(?:offset|client)(?:Width|Height)$/;
var regex_content_rect = /^(?:contentRect)$/;
var regex_content_box_size = /^(?:contentBoxSize)$/;
var regex_border_box_size = /^(?:borderBoxSize)$/;
var regex_device_pixel_content_box_size = /^(?:devicePixelContentBoxSize)$/;
var regex_box_size = /^(?:contentRect|contentBoxSize|borderBoxSize|devicePixelContentBoxSize)$/;

// node_modules/svelte/src/compiler/utils/extract_svelte_ignore.js
var regex_svelte_ignore = /^\s*svelte-ignore\s+([\s\S]+)\s*$/m;
function extract_svelte_ignore(text2) {
  const match = regex_svelte_ignore.exec(text2);
  return match ? match[1].split(regex_whitespace).map((x2) => x2.trim()).filter(Boolean) : [];
}
function extract_svelte_ignore_from_comments(node) {
  return flatten(
    (node.leadingComments || []).map((comment) => extract_svelte_ignore(comment.value))
  );
}
function extract_ignores_above_position(position, template_nodes) {
  const previous_node_idx = template_nodes.findIndex((child) => child.end === position);
  if (previous_node_idx === -1) {
    return [];
  }
  for (let i = previous_node_idx; i >= 0; i--) {
    const node = template_nodes[i];
    if (node.type !== "Comment" && node.type !== "Text") {
      return [];
    }
    if (node.type === "Comment") {
      if (node.ignores.length) {
        return node.ignores;
      }
    }
  }
  return [];
}
function extract_ignores_above_node(node) {
  let cur_node = node.prev;
  while (cur_node) {
    if (cur_node.type !== "Comment" && cur_node.type !== "Text") {
      return [];
    }
    if (cur_node.type === "Comment" && cur_node.ignores.length) {
      return cur_node.ignores;
    }
    cur_node = cur_node.prev;
  }
  return [];
}

// node_modules/svelte/src/compiler/utils/fuzzymatch.js
function fuzzymatch(name49, names) {
  const set = new FuzzySet(names);
  const matches = set.get(name49);
  return matches && matches[0] && matches[0][0] > 0.7 ? matches[0][1] : null;
}
var GRAM_SIZE_LOWER = 2;
var GRAM_SIZE_UPPER = 3;
function _distance(str1, str2) {
  if (str1 === null && str2 === null) {
    throw "Trying to compare two null values";
  }
  if (str1 === null || str2 === null)
    return 0;
  str1 = String(str1);
  str2 = String(str2);
  const distance = levenshtein(str1, str2);
  return 1 - distance / Math.max(str1.length, str2.length);
}
function levenshtein(str1, str2) {
  const current2 = [];
  let prev;
  let value;
  for (let i = 0; i <= str2.length; i++) {
    for (let j = 0; j <= str1.length; j++) {
      if (i && j) {
        if (str1.charAt(j - 1) === str2.charAt(i - 1)) {
          value = prev;
        } else {
          value = Math.min(current2[j], current2[j - 1], prev) + 1;
        }
      } else {
        value = i + j;
      }
      prev = current2[j];
      current2[j] = value;
    }
  }
  return current2.pop();
}
var non_word_regex = /[^\w, ]+/;
function iterate_grams(value, gram_size = 2) {
  const simplified = "-" + value.toLowerCase().replace(non_word_regex, "") + "-";
  const len_diff = gram_size - simplified.length;
  const results = [];
  if (len_diff > 0) {
    for (let i = 0; i < len_diff; ++i) {
      value += "-";
    }
  }
  for (let i = 0; i < simplified.length - gram_size + 1; ++i) {
    results.push(simplified.slice(i, i + gram_size));
  }
  return results;
}
function gram_counter(value, gram_size = 2) {
  const result = {};
  const grams = iterate_grams(value, gram_size);
  let i = 0;
  for (i; i < grams.length; ++i) {
    if (grams[i] in result) {
      result[grams[i]] += 1;
    } else {
      result[grams[i]] = 1;
    }
  }
  return result;
}
function sort_descending(a, b2) {
  return b2[0] - a[0];
}
var FuzzySet = class {
  /**
   * @param {string[]} arr
   */
  constructor(arr) {
    __publicField(this, "exact_set", {});
    __publicField(this, "match_dict", {});
    __publicField(this, "items", {});
    for (let i = GRAM_SIZE_LOWER; i < GRAM_SIZE_UPPER + 1; ++i) {
      this.items[i] = [];
    }
    for (let i = 0; i < arr.length; ++i) {
      this.add(arr[i]);
    }
  }
  /**
   * @param {string} value
   */
  add(value) {
    const normalized_value = value.toLowerCase();
    if (normalized_value in this.exact_set) {
      return false;
    }
    let i = GRAM_SIZE_LOWER;
    for (i; i < GRAM_SIZE_UPPER + 1; ++i) {
      this._add(value, i);
    }
  }
  /**
   * @param {string} value
   * @param {number} gram_size
   */
  _add(value, gram_size) {
    const normalized_value = value.toLowerCase();
    const items = this.items[gram_size] || [];
    const index = items.length;
    items.push(0);
    const gram_counts = gram_counter(normalized_value, gram_size);
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        this.match_dict[gram].push([index, gram_count]);
      } else {
        this.match_dict[gram] = [[index, gram_count]];
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    items[index] = [vector_normal, normalized_value];
    this.items[gram_size] = items;
    this.exact_set[normalized_value] = value;
  }
  /**
   * @param {string} value
   */
  get(value) {
    const normalized_value = value.toLowerCase();
    const result = this.exact_set[normalized_value];
    if (result) {
      return [[1, result]];
    }
    let results = [];
    for (let gram_size = GRAM_SIZE_UPPER; gram_size >= GRAM_SIZE_LOWER; --gram_size) {
      results = this.__get(value, gram_size);
      if (results) {
        return results;
      }
    }
    return null;
  }
  /**
   * @param {string} value
   * @param {number} gram_size
   */
  __get(value, gram_size) {
    const normalized_value = value.toLowerCase();
    const matches = {};
    const gram_counts = gram_counter(normalized_value, gram_size);
    const items = this.items[gram_size];
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    let i;
    let index;
    let other_gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        for (i = 0; i < this.match_dict[gram].length; ++i) {
          index = this.match_dict[gram][i][0];
          other_gram_count = this.match_dict[gram][i][1];
          if (index in matches) {
            matches[index] += gram_count * other_gram_count;
          } else {
            matches[index] = gram_count * other_gram_count;
          }
        }
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    let results = [];
    let match_score;
    for (const match_index in matches) {
      match_score = matches[match_index];
      results.push([match_score / (vector_normal * items[match_index][0]), items[match_index][1]]);
    }
    results.sort(sort_descending);
    let new_results = [];
    const end_index = Math.min(50, results.length);
    for (let i2 = 0; i2 < end_index; ++i2) {
      new_results.push([_distance(results[i2][1], normalized_value), results[i2][1]]);
    }
    results = new_results;
    results.sort(sort_descending);
    new_results = [];
    for (let i2 = 0; i2 < results.length; ++i2) {
      if (results[i2][0] == results[0][0]) {
        new_results.push([results[i2][0], this.exact_set[results[i2][1]]]);
      }
    }
    return new_results;
  }
};

// node_modules/svelte/src/compiler/utils/list.js
function list(items, conjunction = "or") {
  if (items.length === 1)
    return items[0];
  return `${items.slice(0, -1).join(", ")} ${conjunction} ${items[items.length - 1]}`;
}

// node_modules/svelte/src/compiler/parse/errors.js
var errors_default = {
  /**
   * @param {string} message
   */
  css_syntax_error: (message) => ({
    code: "css-syntax-error",
    message
  }),
  duplicate_attribute: {
    code: "duplicate-attribute",
    message: "Attributes need to be unique"
  },
  /**
   * @param {string} slug
   * @param {string} name
   */
  duplicate_element: (slug, name49) => ({
    code: `duplicate-${slug}`,
    message: `A component can only have one <${name49}> tag`
  }),
  duplicate_style: {
    code: "duplicate-style",
    message: "You can only have one top-level <style> tag per component"
  },
  empty_attribute_shorthand: {
    code: "empty-attribute-shorthand",
    message: "Attribute shorthand cannot be empty"
  },
  /**
   * @param {string} type
   */
  empty_directive_name: (type) => ({
    code: "empty-directive-name",
    message: `${type} name cannot be empty`
  }),
  empty_global_selector: {
    code: "css-syntax-error",
    message: ":global() must contain a selector"
  },
  expected_block_type: {
    code: "expected-block-type",
    message: "Expected if, each or await"
  },
  expected_name: {
    code: "expected-name",
    message: "Expected name"
  },
  /** @param {string} block */
  invalid_catch_placement_unclosed_block: (block) => ({
    code: "invalid-catch-placement",
    message: `Expected to close ${block} before seeing {:catch} block`
  }),
  invalid_catch_placement_without_await: {
    code: "invalid-catch-placement",
    message: "Cannot have an {:catch} block outside an {#await ...} block"
  },
  invalid_component_definition: {
    code: "invalid-component-definition",
    message: "invalid component definition"
  },
  /**
   * @param {string} name
   */
  invalid_closing_tag_unopened: (name49) => ({
    code: "invalid-closing-tag",
    message: `</${name49}> attempted to close an element that was not open`
  }),
  /**
   * @param {string} name
   * @param {string} reason
   */
  invalid_closing_tag_autoclosed: (name49, reason) => ({
    code: "invalid-closing-tag",
    message: `</${name49}> attempted to close <${name49}> that was already automatically closed by <${reason}>`
  }),
  invalid_debug_args: {
    code: "invalid-debug-args",
    message: "{@debug ...} arguments must be identifiers, not arbitrary expressions"
  },
  invalid_declaration: {
    code: "invalid-declaration",
    message: "Declaration cannot be empty"
  },
  invalid_directive_value: {
    code: "invalid-directive-value",
    message: "Directive value must be a JavaScript expression enclosed in curly braces"
  },
  invalid_elseif: {
    code: "invalid-elseif",
    message: "'elseif' should be 'else if'"
  },
  invalid_elseif_placement_outside_if: {
    code: "invalid-elseif-placement",
    message: "Cannot have an {:else if ...} block outside an {#if ...} block"
  },
  /**
   * @param {string} block
   */
  invalid_elseif_placement_unclosed_block: (block) => ({
    code: "invalid-elseif-placement",
    message: `Expected to close ${block} before seeing {:else if ...} block`
  }),
  invalid_else_placement_outside_if: {
    code: "invalid-else-placement",
    message: "Cannot have an {:else} block outside an {#if ...} or {#each ...} block"
  },
  /**
   * @param {string} block
   */
  invalid_else_placement_unclosed_block: (block) => ({
    code: "invalid-else-placement",
    message: `Expected to close ${block} before seeing {:else} block`
  }),
  /**
   * @param {string} slug
   * @param {string} name
   */
  invalid_element_content: (slug, name49) => ({
    code: `invalid-${slug}-content`,
    message: `<${name49}> cannot have children`
  }),
  invalid_element_definition: {
    code: "invalid-element-definition",
    message: "Invalid element definition"
  },
  /**
   * @param {string} slug
   * @param {string} name
   */
  invalid_element_placement: (slug, name49) => ({
    code: `invalid-${slug}-placement`,
    message: `<${name49}> tags cannot be inside elements or blocks`
  }),
  /**
   * @param {string} location
   * @param {string} name
   */
  invalid_logic_block_placement: (location, name49) => ({
    code: "invalid-logic-block-placement",
    message: `{#${name49}} logic block cannot be ${location}`
  }),
  /**
   * @param {string} location
   * @param {string} name
   */
  invalid_tag_placement: (location, name49) => ({
    code: "invalid-tag-placement",
    message: `{@${name49}} tag cannot be ${location}`
  }),
  /**
   * @param {string} name
   */
  invalid_ref_directive: (name49) => ({
    code: "invalid-ref-directive",
    message: `The ref directive is no longer supported — use \`bind:this={${name49}}\` instead`
  }),
  invalid_ref_selector: {
    code: "invalid-ref-selector",
    message: "ref selectors are no longer supported"
  },
  invalid_self_placement: {
    code: "invalid-self-placement",
    message: "<svelte:self> components can only exist inside {#if} blocks, {#each} blocks, or slots passed to components"
  },
  invalid_script_instance: {
    code: "invalid-script",
    message: "A component can only have one instance-level <script> element"
  },
  invalid_script_module: {
    code: "invalid-script",
    message: 'A component can only have one <script context="module"> element'
  },
  invalid_script_context_attribute: {
    code: "invalid-script",
    message: "context attribute must be static"
  },
  invalid_script_context_value: {
    code: "invalid-script",
    message: 'If the context attribute is supplied, its value must be "module"'
  },
  invalid_tag_name: {
    code: "invalid-tag-name",
    message: "Expected valid tag name"
  },
  /**
   * @param {string[]} tags
   * @param {string} match
   */
  invalid_tag_name_svelte_element: (tags, match) => ({
    code: "invalid-tag-name",
    message: `Valid <svelte:...> tag names are ${list(tags)}${match ? " (did you mean " + match + "?)" : ""}`
  }),
  /** @param {string} block */
  invalid_then_placement_unclosed_block: (block) => ({
    code: "invalid-then-placement",
    message: `Expected to close ${block} before seeing {:then} block`
  }),
  invalid_then_placement_without_await: {
    code: "invalid-then-placement",
    message: "Cannot have an {:then} block outside an {#await ...} block"
  },
  /**
   * @param {string} name
   */
  invalid_void_content: (name49) => ({
    code: "invalid-void-content",
    message: `<${name49}> is a void element and cannot have children, or a closing tag`
  }),
  missing_component_definition: {
    code: "missing-component-definition",
    message: "<svelte:component> must have a 'this' attribute"
  },
  missing_attribute_value: {
    code: "missing-attribute-value",
    message: "Expected value for the attribute"
  },
  missing_element_definition: {
    code: "missing-element-definition",
    message: "<svelte:element> must have a 'this' attribute"
  },
  unclosed_script: {
    code: "unclosed-script",
    message: "<script> must have a closing tag"
  },
  unclosed_style: {
    code: "unclosed-style",
    message: "<style> must have a closing tag"
  },
  unclosed_comment: {
    code: "unclosed-comment",
    message: "comment was left open, expected -->"
  },
  /**
   * @param {string} token
   */
  unclosed_attribute_value: (token) => ({
    code: "unclosed-attribute-value",
    message: `Expected to close the attribute value with ${token}`
  }),
  unexpected_block_close: {
    code: "unexpected-block-close",
    message: "Unexpected block closing tag"
  },
  unexpected_eof: {
    code: "unexpected-eof",
    message: "Unexpected end of input"
  },
  /**
   * @param {string} token
   */
  unexpected_eof_token: (token) => ({
    code: "unexpected-eof",
    message: `Unexpected ${token}`
  }),
  /**
   * @param {string} token
   */
  unexpected_token: (token) => ({
    code: "unexpected-token",
    message: `Expected ${token}`
  }),
  unexpected_token_destructure: {
    code: "unexpected-token",
    message: "Expected identifier or destructure pattern"
  }
};

// node_modules/estree-walker/src/walker.js
var WalkerBase = class {
  constructor() {
    this.should_skip = false;
    this.should_remove = false;
    this.replacement = null;
    this.context = {
      skip: () => this.should_skip = true,
      remove: () => this.should_remove = true,
      replace: (node) => this.replacement = node
    };
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   * @param {Node} node
   */
  replace(parent, prop, index, node) {
    if (parent && prop) {
      if (index != null) {
        parent[prop][index] = node;
      } else {
        parent[prop] = node;
      }
    }
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   */
  remove(parent, prop, index) {
    if (parent && prop) {
      if (index !== null && index !== void 0) {
        parent[prop].splice(index, 1);
      } else {
        delete parent[prop];
      }
    }
  }
};

// node_modules/estree-walker/src/sync.js
var SyncWalker = class extends WalkerBase {
  /**
   *
   * @param {SyncHandler} [enter]
   * @param {SyncHandler} [leave]
   */
  constructor(enter, leave) {
    super();
    this.should_skip = false;
    this.should_remove = false;
    this.replacement = null;
    this.context = {
      skip: () => this.should_skip = true,
      remove: () => this.should_remove = true,
      replace: (node) => this.replacement = node
    };
    this.enter = enter;
    this.leave = leave;
  }
  /**
   * @template {Node} Parent
   * @param {Node} node
   * @param {Parent | null} parent
   * @param {keyof Parent} [prop]
   * @param {number | null} [index]
   * @returns {Node | null}
   */
  visit(node, parent, prop, index) {
    if (node) {
      if (this.enter) {
        const _should_skip = this.should_skip;
        const _should_remove = this.should_remove;
        const _replacement = this.replacement;
        this.should_skip = false;
        this.should_remove = false;
        this.replacement = null;
        this.enter.call(this.context, node, parent, prop, index);
        if (this.replacement) {
          node = this.replacement;
          this.replace(parent, prop, index, node);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index);
        }
        const skipped = this.should_skip;
        const removed = this.should_remove;
        this.should_skip = _should_skip;
        this.should_remove = _should_remove;
        this.replacement = _replacement;
        if (skipped)
          return node;
        if (removed)
          return null;
      }
      let key;
      for (key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          if (Array.isArray(value)) {
            const nodes = (
              /** @type {Array<unknown>} */
              value
            );
            for (let i = 0; i < nodes.length; i += 1) {
              const item = nodes[i];
              if (isNode(item)) {
                if (!this.visit(item, node, key, i)) {
                  i--;
                }
              }
            }
          } else if (isNode(value)) {
            this.visit(value, node, key, null);
          }
        }
      }
      if (this.leave) {
        const _replacement = this.replacement;
        const _should_remove = this.should_remove;
        this.replacement = null;
        this.should_remove = false;
        this.leave.call(this.context, node, parent, prop, index);
        if (this.replacement) {
          node = this.replacement;
          this.replace(parent, prop, index, node);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index);
        }
        const removed = this.should_remove;
        this.replacement = _replacement;
        this.should_remove = _should_remove;
        if (removed)
          return null;
      }
    }
    return node;
  }
};
function isNode(value) {
  return value !== null && typeof value === "object" && "type" in value && typeof value.type === "string";
}

// node_modules/estree-walker/src/index.js
function walk(ast, { enter, leave }) {
  const instance = new SyncWalker(enter, leave);
  return instance.visit(ast, null);
}

// node_modules/code-red/src/utils/id.js
var id = Math.round(Math.random() * 1e20).toString(36);
var re = new RegExp(`_${id}_(?:(\\d+)|(AT)|(HASH))_(\\w+)?`, "g");

// node_modules/code-red/src/utils/comments.js
var get_comment_handlers = (comments, raw) => ({
  // pass to acorn options
  /**
   * @param {boolean} block
   * @param {string} value
   * @param {number} start
   * @param {number} end
   */
  onComment: (block, value, start, end) => {
    if (block && /\n/.test(value)) {
      let a = start;
      while (a > 0 && raw[a - 1] !== "\n")
        a -= 1;
      let b2 = a;
      while (/[ \t]/.test(raw[b2]))
        b2 += 1;
      const indentation = raw.slice(a, b2);
      value = value.replace(new RegExp(`^${indentation}`, "gm"), "");
    }
    comments.push({ type: block ? "Block" : "Line", value, start, end });
  },
  // pass to estree-walker options
  /** @param {NodeWithLocation} node */
  enter(node) {
    let comment;
    while (comments[0] && comments[0].start < node.start) {
      comment = comments.shift();
      comment.value = comment.value.replace(
        re,
        (match, id2, at2, hash2, value) => {
          if (hash2)
            return `#${value}`;
          if (at2)
            return `@${value}`;
          return match;
        }
      );
      const next = comments[0] || node;
      comment.has_trailing_newline = comment.type === "Line" || /\n/.test(raw.slice(comment.end, next.start));
      (node.leadingComments || (node.leadingComments = [])).push(comment);
    }
  },
  /** @param {NodeWithLocation} node */
  leave(node) {
    if (comments[0]) {
      const slice = raw.slice(node.end, comments[0].start);
      if (/^[,) \t]*$/.test(slice)) {
        node.trailingComments = [comments.shift()];
      }
    }
  }
});

// node_modules/is-reference/src/index.js
function is_reference(node, parent) {
  if (node.type === "MemberExpression") {
    return !node.computed && is_reference(node.object, node);
  }
  if (node.type === "Identifier") {
    if (!parent)
      return true;
    switch (parent.type) {
      case "MemberExpression":
        return parent.computed || node === parent.object;
      case "MethodDefinition":
        return parent.computed;
      case "PropertyDefinition":
        return parent.computed || node === parent.value;
      case "Property":
        return parent.computed || node === parent.value;
      case "ExportSpecifier":
      case "ImportSpecifier":
        return node === parent.local;
      case "LabeledStatement":
      case "BreakStatement":
      case "ContinueStatement":
        return false;
      default:
        return true;
    }
  }
  return false;
}

// node_modules/periscopic/src/index.js
function analyze(expression) {
  const map = /* @__PURE__ */ new WeakMap();
  const globals = /* @__PURE__ */ new Map();
  const scope = new Scope3(null, false);
  const references = [];
  let current_scope = scope;
  walk(expression, {
    enter(node, parent) {
      switch (node.type) {
        case "Identifier":
          if (parent && is_reference(node, parent)) {
            references.push([current_scope, node]);
          }
          break;
        case "ImportDeclaration":
          node.specifiers.forEach((specifier) => {
            current_scope.declarations.set(specifier.local.name, specifier);
          });
          break;
        case "FunctionExpression":
        case "FunctionDeclaration":
        case "ArrowFunctionExpression":
          if (node.type === "FunctionDeclaration") {
            if (node.id) {
              current_scope.declarations.set(node.id.name, node);
            }
            map.set(node, current_scope = new Scope3(current_scope, false));
          } else {
            map.set(node, current_scope = new Scope3(current_scope, false));
            if (node.type === "FunctionExpression" && node.id) {
              current_scope.declarations.set(node.id.name, node);
            }
          }
          node.params.forEach((param) => {
            extract_names(param).forEach((name49) => {
              current_scope.declarations.set(name49, node);
            });
          });
          break;
        case "ForStatement":
        case "ForInStatement":
        case "ForOfStatement":
          map.set(node, current_scope = new Scope3(current_scope, true));
          break;
        case "BlockStatement":
          map.set(node, current_scope = new Scope3(current_scope, true));
          break;
        case "ClassDeclaration":
        case "VariableDeclaration":
          current_scope.add_declaration(node);
          break;
        case "CatchClause":
          map.set(node, current_scope = new Scope3(current_scope, true));
          if (node.param) {
            extract_names(node.param).forEach((name49) => {
              if (node.param) {
                current_scope.declarations.set(name49, node.param);
              }
            });
          }
          break;
      }
    },
    leave(node) {
      if (map.has(node) && current_scope !== null && current_scope.parent) {
        current_scope = current_scope.parent;
      }
    }
  });
  for (let i = references.length - 1; i >= 0; --i) {
    const [scope2, reference] = references[i];
    if (!scope2.references.has(reference.name)) {
      add_reference(scope2, reference.name);
    }
    if (!scope2.find_owner(reference.name)) {
      globals.set(reference.name, reference);
    }
  }
  return { map, scope, globals };
}
function add_reference(scope, name49) {
  scope.references.add(name49);
  if (scope.parent)
    add_reference(scope.parent, name49);
}
var Scope3 = class {
  /**
   * @param {Scope | null} parent 
   * @param {boolean} block 
   */
  constructor(parent, block) {
    this.parent = parent;
    this.block = block;
    this.declarations = /* @__PURE__ */ new Map();
    this.initialised_declarations = /* @__PURE__ */ new Set();
    this.references = /* @__PURE__ */ new Set();
  }
  /**
   * @param {import('estree').VariableDeclaration | import('estree').ClassDeclaration} node
   */
  add_declaration(node) {
    if (node.type === "VariableDeclaration") {
      if (node.kind === "var" && this.block && this.parent) {
        this.parent.add_declaration(node);
      } else {
        const handle_declarator = (declarator) => {
          extract_names(declarator.id).forEach((name49) => {
            this.declarations.set(name49, node);
            if (declarator.init)
              this.initialised_declarations.add(name49);
          });
          ;
        };
        node.declarations.forEach(handle_declarator);
      }
    } else if (node.id) {
      this.declarations.set(node.id.name, node);
    }
  }
  /**
   * @param {string} name
   * @returns {Scope | null}
   */
  find_owner(name49) {
    if (this.declarations.has(name49))
      return this;
    return this.parent && this.parent.find_owner(name49);
  }
  /**
   * @param {string} name
   * @returns {boolean}
   */
  has(name49) {
    return this.declarations.has(name49) || !!this.parent && this.parent.has(name49);
  }
};
function extract_names(param) {
  return extract_identifiers(param).map((node) => node.name);
}
function extract_identifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = /** @type {any} */
        object.object;
      }
      nodes.push(
        /** @type {any} */
        object
      );
      break;
    case "ObjectPattern":
      const handle_prop = (prop) => {
        if (prop.type === "RestElement") {
          extract_identifiers(prop.argument, nodes);
        } else {
          extract_identifiers(prop.value, nodes);
        }
      };
      param.properties.forEach(handle_prop);
      break;
    case "ArrayPattern":
      const handle_element = (element) => {
        if (element)
          extract_identifiers(element, nodes);
      };
      param.elements.forEach((element) => {
        if (element) {
          handle_element(element);
        }
      });
      break;
    case "RestElement":
      extract_identifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extract_identifiers(param.left, nodes);
      break;
  }
  return nodes;
}

// node_modules/code-red/src/utils/push_array.js
function push_array(array, items) {
  for (let i = 0; i < items.length; i++) {
    array.push(items[i]);
  }
}

// node_modules/code-red/src/print/handlers.js
function handle(node, state) {
  const handler = handlers[node.type];
  if (!handler) {
    throw new Error(`Not implemented ${node.type}`);
  }
  const result = handler(node, state);
  if (node.leadingComments) {
    result.unshift(
      c(
        node.leadingComments.map(
          (comment) => comment.type === "Block" ? `/*${comment.value}*/${/** @type {any} */
          comment.has_trailing_newline ? `
${state.indent}` : ` `}` : `//${comment.value}${/** @type {any} */
          comment.has_trailing_newline ? `
${state.indent}` : ` `}`
        ).join(``)
      )
    );
  }
  if (node.trailingComments) {
    state.comments.push(node.trailingComments[0]);
  }
  return result;
}
function c(content, node) {
  return {
    content,
    loc: node && node.loc,
    has_newline: /\n/.test(content)
  };
}
var OPERATOR_PRECEDENCE = {
  "||": 2,
  "&&": 3,
  "??": 4,
  "|": 5,
  "^": 6,
  "&": 7,
  "==": 8,
  "!=": 8,
  "===": 8,
  "!==": 8,
  "<": 9,
  ">": 9,
  "<=": 9,
  ">=": 9,
  in: 9,
  instanceof: 9,
  "<<": 10,
  ">>": 10,
  ">>>": 10,
  "+": 11,
  "-": 11,
  "*": 12,
  "%": 12,
  "/": 12,
  "**": 13
};
var EXPRESSIONS_PRECEDENCE = {
  ArrayExpression: 20,
  TaggedTemplateExpression: 20,
  ThisExpression: 20,
  Identifier: 20,
  Literal: 18,
  TemplateLiteral: 20,
  Super: 20,
  SequenceExpression: 20,
  MemberExpression: 19,
  CallExpression: 19,
  NewExpression: 19,
  AwaitExpression: 17,
  ClassExpression: 17,
  FunctionExpression: 17,
  ObjectExpression: 17,
  UpdateExpression: 16,
  UnaryExpression: 15,
  BinaryExpression: 14,
  LogicalExpression: 13,
  ConditionalExpression: 4,
  ArrowFunctionExpression: 3,
  AssignmentExpression: 3,
  YieldExpression: 2,
  RestElement: 1
};
function needs_parens(node, parent, is_right) {
  if (node.type === "LogicalExpression" && parent.type === "LogicalExpression" && (parent.operator === "??" && node.operator !== "??" || parent.operator !== "??" && node.operator === "??")) {
    return true;
  }
  const precedence = EXPRESSIONS_PRECEDENCE[node.type];
  const parent_precedence = EXPRESSIONS_PRECEDENCE[parent.type];
  if (precedence !== parent_precedence) {
    return !is_right && precedence === 15 && parent_precedence === 14 && parent.operator === "**" || precedence < parent_precedence;
  }
  if (precedence !== 13 && precedence !== 14) {
    return false;
  }
  if (
    /** @type {BinaryExpression} */
    node.operator === "**" && parent.operator === "**"
  ) {
    return !is_right;
  }
  if (is_right) {
    return OPERATOR_PRECEDENCE[
      /** @type {BinaryExpression} */
      node.operator
    ] <= OPERATOR_PRECEDENCE[parent.operator];
  }
  return OPERATOR_PRECEDENCE[
    /** @type {BinaryExpression} */
    node.operator
  ] < OPERATOR_PRECEDENCE[parent.operator];
}
function has_call_expression(node) {
  while (node) {
    if (node.type[0] === "CallExpression") {
      return true;
    } else if (node.type === "MemberExpression") {
      node = node.object;
    } else {
      return false;
    }
  }
}
var has_newline = (chunks) => {
  for (let i = 0; i < chunks.length; i += 1) {
    if (chunks[i].has_newline)
      return true;
  }
  return false;
};
var get_length = (chunks) => {
  let total = 0;
  for (let i = 0; i < chunks.length; i += 1) {
    total += chunks[i].content.length;
  }
  return total;
};
var sum = (a, b2) => a + b2;
var join = (nodes, separator) => {
  if (nodes.length === 0)
    return [];
  const joined = [...nodes[0]];
  for (let i = 1; i < nodes.length; i += 1) {
    joined.push(separator);
    push_array(joined, nodes[i]);
  }
  return joined;
};
var scoped = (fn) => {
  const scoped_fn = (node, state) => {
    return fn(node, {
      ...state,
      scope: state.scope_map.get(node)
    });
  };
  return scoped_fn;
};
var deconflict = (name49, names) => {
  const original = name49;
  let i = 1;
  while (names.has(name49)) {
    name49 = `${original}$${i++}`;
  }
  return name49;
};
var handle_body = (nodes, state) => {
  const chunks = [];
  const body = nodes.map((statement) => {
    const chunks2 = handle(statement, {
      ...state,
      indent: state.indent
    });
    let add_newline = false;
    while (state.comments.length) {
      const comment = state.comments.shift();
      const prefix = add_newline ? `
${state.indent}` : ` `;
      chunks2.push(
        c(
          comment.type === "Block" ? `${prefix}/*${comment.value}*/` : `${prefix}//${comment.value}`
        )
      );
      add_newline = comment.type === "Line";
    }
    return chunks2;
  });
  let needed_padding = false;
  for (let i = 0; i < body.length; i += 1) {
    const needs_padding = has_newline(body[i]);
    if (i > 0) {
      chunks.push(
        c(
          needs_padding || needed_padding ? `

${state.indent}` : `
${state.indent}`
        )
      );
    }
    push_array(chunks, body[i]);
    needed_padding = needs_padding;
  }
  return chunks;
};
var handle_var_declaration = (node, state) => {
  const chunks = [c(`${node.kind} `)];
  const declarators = node.declarations.map(
    (d) => handle(d, {
      ...state,
      indent: state.indent + (node.declarations.length === 1 ? "" : "	")
    })
  );
  const multiple_lines = declarators.some(has_newline) || declarators.map(get_length).reduce(sum, 0) + (state.indent.length + declarators.length - 1) * 2 > 80;
  const separator = c(multiple_lines ? `,
${state.indent}	` : ", ");
  push_array(chunks, join(declarators, separator));
  return chunks;
};
var handlers = {
  Program(node, state) {
    return handle_body(node.body, state);
  },
  BlockStatement: scoped((node, state) => {
    return [
      c(`{
${state.indent}	`),
      ...handle_body(node.body, { ...state, indent: state.indent + "	" }),
      c(`
${state.indent}}`)
    ];
  }),
  EmptyStatement(node, state) {
    return [c(";")];
  },
  ParenthesizedExpression(node, state) {
    return handle(node.expression, state);
  },
  ExpressionStatement(node, state) {
    if (node.expression.type === "AssignmentExpression" && node.expression.left.type === "ObjectPattern") {
      return [c("("), ...handle(node.expression, state), c(");")];
    }
    return [...handle(node.expression, state), c(";")];
  },
  IfStatement(node, state) {
    const chunks = [
      c("if ("),
      ...handle(node.test, state),
      c(") "),
      ...handle(node.consequent, state)
    ];
    if (node.alternate) {
      chunks.push(c(" else "));
      push_array(chunks, handle(node.alternate, state));
    }
    return chunks;
  },
  LabeledStatement(node, state) {
    return [...handle(node.label, state), c(": "), ...handle(node.body, state)];
  },
  BreakStatement(node, state) {
    return node.label ? [c("break "), ...handle(node.label, state), c(";")] : [c("break;")];
  },
  ContinueStatement(node, state) {
    return node.label ? [c("continue "), ...handle(node.label, state), c(";")] : [c("continue;")];
  },
  WithStatement(node, state) {
    return [
      c("with ("),
      ...handle(node.object, state),
      c(") "),
      ...handle(node.body, state)
    ];
  },
  SwitchStatement(node, state) {
    const chunks = [
      c("switch ("),
      ...handle(node.discriminant, state),
      c(") {")
    ];
    node.cases.forEach((block) => {
      if (block.test) {
        chunks.push(c(`
${state.indent}	case `));
        push_array(
          chunks,
          handle(block.test, { ...state, indent: `${state.indent}	` })
        );
        chunks.push(c(":"));
      } else {
        chunks.push(c(`
${state.indent}	default:`));
      }
      block.consequent.forEach((statement) => {
        chunks.push(c(`
${state.indent}		`));
        push_array(
          chunks,
          handle(statement, { ...state, indent: `${state.indent}		` })
        );
      });
    });
    chunks.push(c(`
${state.indent}}`));
    return chunks;
  },
  ReturnStatement(node, state) {
    if (node.argument) {
      const contains_comment = node.argument.leadingComments && node.argument.leadingComments.some(
        (comment) => comment.has_trailing_newline
      );
      return [
        c(contains_comment ? "return (" : "return "),
        ...handle(node.argument, state),
        c(contains_comment ? ");" : ";")
      ];
    } else {
      return [c("return;")];
    }
  },
  ThrowStatement(node, state) {
    return [c("throw "), ...handle(node.argument, state), c(";")];
  },
  TryStatement(node, state) {
    const chunks = [c("try "), ...handle(node.block, state)];
    if (node.handler) {
      if (node.handler.param) {
        chunks.push(c(" catch("));
        push_array(chunks, handle(node.handler.param, state));
        chunks.push(c(") "));
      } else {
        chunks.push(c(" catch "));
      }
      push_array(chunks, handle(node.handler.body, state));
    }
    if (node.finalizer) {
      chunks.push(c(" finally "));
      push_array(chunks, handle(node.finalizer, state));
    }
    return chunks;
  },
  WhileStatement(node, state) {
    return [
      c("while ("),
      ...handle(node.test, state),
      c(") "),
      ...handle(node.body, state)
    ];
  },
  DoWhileStatement(node, state) {
    return [
      c("do "),
      ...handle(node.body, state),
      c(" while ("),
      ...handle(node.test, state),
      c(");")
    ];
  },
  ForStatement: scoped((node, state) => {
    const chunks = [c("for (")];
    if (node.init) {
      if (node.init.type === "VariableDeclaration") {
        push_array(chunks, handle_var_declaration(node.init, state));
      } else {
        push_array(chunks, handle(node.init, state));
      }
    }
    chunks.push(c("; "));
    if (node.test)
      push_array(chunks, handle(node.test, state));
    chunks.push(c("; "));
    if (node.update)
      push_array(chunks, handle(node.update, state));
    chunks.push(c(") "));
    push_array(chunks, handle(node.body, state));
    return chunks;
  }),
  ForInStatement: scoped((node, state) => {
    const chunks = [c(`for ${node.await ? "await " : ""}(`)];
    if (node.left.type === "VariableDeclaration") {
      push_array(chunks, handle_var_declaration(node.left, state));
    } else {
      push_array(chunks, handle(node.left, state));
    }
    chunks.push(c(node.type === "ForInStatement" ? ` in ` : ` of `));
    push_array(chunks, handle(node.right, state));
    chunks.push(c(") "));
    push_array(chunks, handle(node.body, state));
    return chunks;
  }),
  DebuggerStatement(node, state) {
    return [c("debugger", node), c(";")];
  },
  FunctionDeclaration: scoped(
    (node, state) => {
      const chunks = [];
      if (node.async)
        chunks.push(c("async "));
      chunks.push(c(node.generator ? "function* " : "function "));
      if (node.id)
        push_array(chunks, handle(node.id, state));
      chunks.push(c("("));
      const params = node.params.map(
        (p2) => handle(p2, {
          ...state,
          indent: state.indent + "	"
        })
      );
      const multiple_lines = params.some(has_newline) || params.map(get_length).reduce(sum, 0) + (state.indent.length + params.length - 1) * 2 > 80;
      const separator = c(multiple_lines ? `,
${state.indent}` : ", ");
      if (multiple_lines) {
        chunks.push(c(`
${state.indent}	`));
        push_array(chunks, join(params, separator));
        chunks.push(c(`
${state.indent}`));
      } else {
        push_array(chunks, join(params, separator));
      }
      chunks.push(c(") "));
      push_array(chunks, handle(node.body, state));
      return chunks;
    }
  ),
  VariableDeclaration(node, state) {
    return handle_var_declaration(node, state).concat(c(";"));
  },
  VariableDeclarator(node, state) {
    if (node.init) {
      return [...handle(node.id, state), c(" = "), ...handle(node.init, state)];
    } else {
      return handle(node.id, state);
    }
  },
  ClassDeclaration(node, state) {
    const chunks = [c("class ")];
    if (node.id) {
      push_array(chunks, handle(node.id, state));
      chunks.push(c(" "));
    }
    if (node.superClass) {
      chunks.push(c("extends "));
      push_array(chunks, handle(node.superClass, state));
      chunks.push(c(" "));
    }
    push_array(chunks, handle(node.body, state));
    return chunks;
  },
  ImportDeclaration(node, state) {
    const chunks = [c("import ")];
    const { length: length2 } = node.specifiers;
    const source = handle(node.source, state);
    if (length2 > 0) {
      let i = 0;
      while (i < length2) {
        if (i > 0) {
          chunks.push(c(", "));
        }
        const specifier = node.specifiers[i];
        if (specifier.type === "ImportDefaultSpecifier") {
          chunks.push(c(specifier.local.name, specifier));
          i += 1;
        } else if (specifier.type === "ImportNamespaceSpecifier") {
          chunks.push(c("* as " + specifier.local.name, specifier));
          i += 1;
        } else {
          break;
        }
      }
      if (i < length2) {
        const specifiers = node.specifiers.slice(i).map((specifier) => {
          const name49 = handle(specifier.imported, state)[0];
          const as = handle(specifier.local, state)[0];
          if (name49.content === as.content) {
            return [as];
          }
          return [name49, c(" as "), as];
        });
        const width = get_length(chunks) + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length + 6 + get_length(source);
        if (width > 80) {
          chunks.push(c(`{
	`));
          push_array(chunks, join(specifiers, c(",\n	")));
          chunks.push(c("\n}"));
        } else {
          chunks.push(c(`{ `));
          push_array(chunks, join(specifiers, c(", ")));
          chunks.push(c(" }"));
        }
      }
      chunks.push(c(" from "));
    }
    push_array(chunks, source);
    chunks.push(c(";"));
    return chunks;
  },
  ImportExpression(node, state) {
    return [c("import("), ...handle(node.source, state), c(")")];
  },
  ExportDefaultDeclaration(node, state) {
    const chunks = [c(`export default `), ...handle(node.declaration, state)];
    if (node.declaration.type !== "FunctionDeclaration") {
      chunks.push(c(";"));
    }
    return chunks;
  },
  ExportNamedDeclaration(node, state) {
    const chunks = [c("export ")];
    if (node.declaration) {
      push_array(chunks, handle(node.declaration, state));
    } else {
      const specifiers = node.specifiers.map(
        (specifier) => {
          const name49 = handle(specifier.local, state)[0];
          const as = handle(specifier.exported, state)[0];
          if (name49.content === as.content) {
            return [name49];
          }
          return [name49, c(" as "), as];
        }
      );
      const width = 7 + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length;
      if (width > 80) {
        chunks.push(c("{\n	"));
        push_array(chunks, join(specifiers, c(",\n	")));
        chunks.push(c("\n}"));
      } else {
        chunks.push(c("{ "));
        push_array(chunks, join(specifiers, c(", ")));
        chunks.push(c(" }"));
      }
      if (node.source) {
        chunks.push(c(" from "));
        push_array(chunks, handle(node.source, state));
      }
    }
    chunks.push(c(";"));
    return chunks;
  },
  ExportAllDeclaration(node, state) {
    return [c(`export * from `), ...handle(node.source, state), c(`;`)];
  },
  MethodDefinition(node, state) {
    const chunks = [];
    if (node.static) {
      chunks.push(c("static "));
    }
    if (node.kind === "get" || node.kind === "set") {
      chunks.push(c(node.kind + " "));
    }
    if (node.value.async) {
      chunks.push(c("async "));
    }
    if (node.value.generator) {
      chunks.push(c("*"));
    }
    if (node.computed) {
      chunks.push(c("["));
      push_array(chunks, handle(node.key, state));
      chunks.push(c("]"));
    } else {
      push_array(chunks, handle(node.key, state));
    }
    chunks.push(c("("));
    const { params } = node.value;
    for (let i = 0; i < params.length; i += 1) {
      push_array(chunks, handle(params[i], state));
      if (i < params.length - 1)
        chunks.push(c(", "));
    }
    chunks.push(c(") "));
    push_array(chunks, handle(node.value.body, state));
    return chunks;
  },
  ArrowFunctionExpression: scoped(
    (node, state) => {
      const chunks = [];
      if (node.async)
        chunks.push(c("async "));
      if (node.params.length === 1 && node.params[0].type === "Identifier") {
        push_array(chunks, handle(node.params[0], state));
      } else {
        const params = node.params.map(
          (param) => handle(param, {
            ...state,
            indent: state.indent + "	"
          })
        );
        chunks.push(c("("));
        push_array(chunks, join(params, c(", ")));
        chunks.push(c(")"));
      }
      chunks.push(c(" => "));
      if (node.body.type === "ObjectExpression" || node.body.type === "AssignmentExpression" && node.body.left.type === "ObjectPattern") {
        chunks.push(c("("));
        push_array(chunks, handle(node.body, state));
        chunks.push(c(")"));
      } else {
        push_array(chunks, handle(node.body, state));
      }
      return chunks;
    }
  ),
  ThisExpression(node, state) {
    return [c("this", node)];
  },
  Super(node, state) {
    return [c("super", node)];
  },
  RestElement(node, state) {
    return [c("..."), ...handle(node.argument, state)];
  },
  YieldExpression(node, state) {
    if (node.argument) {
      return [
        c(node.delegate ? `yield* ` : `yield `),
        ...handle(node.argument, state)
      ];
    }
    return [c(node.delegate ? `yield*` : `yield`)];
  },
  AwaitExpression(node, state) {
    if (node.argument) {
      const precedence = EXPRESSIONS_PRECEDENCE[node.argument.type];
      if (precedence && precedence < EXPRESSIONS_PRECEDENCE.AwaitExpression) {
        return [c("await ("), ...handle(node.argument, state), c(")")];
      } else {
        return [c("await "), ...handle(node.argument, state)];
      }
    }
    return [c("await")];
  },
  TemplateLiteral(node, state) {
    const chunks = [c("`")];
    const { quasis, expressions } = node;
    for (let i = 0; i < expressions.length; i++) {
      chunks.push(c(quasis[i].value.raw), c("${"));
      push_array(chunks, handle(expressions[i], state));
      chunks.push(c("}"));
    }
    chunks.push(c(quasis[quasis.length - 1].value.raw), c("`"));
    return chunks;
  },
  TaggedTemplateExpression(node, state) {
    return handle(node.tag, state).concat(handle(node.quasi, state));
  },
  ArrayExpression(node, state) {
    const chunks = [c("[")];
    const elements = [];
    let sparse_commas = [];
    for (let i = 0; i < node.elements.length; i += 1) {
      const element = node.elements[i];
      if (element) {
        elements.push([
          ...sparse_commas,
          ...handle(element, {
            ...state,
            indent: state.indent + "	"
          })
        ]);
        sparse_commas = [];
      } else {
        sparse_commas.push(c(","));
      }
    }
    const multiple_lines = elements.some(has_newline) || elements.map(get_length).reduce(sum, 0) + (state.indent.length + elements.length - 1) * 2 > 80;
    if (multiple_lines) {
      chunks.push(c(`
${state.indent}	`));
      push_array(chunks, join(elements, c(`,
${state.indent}	`)));
      chunks.push(c(`
${state.indent}`));
      push_array(chunks, sparse_commas);
    } else {
      push_array(chunks, join(elements, c(", ")));
      push_array(chunks, sparse_commas);
    }
    chunks.push(c("]"));
    return chunks;
  },
  ObjectExpression(node, state) {
    if (node.properties.length === 0) {
      return [c("{}")];
    }
    let has_inline_comment = false;
    const chunks = [];
    const separator = c(", ");
    node.properties.forEach((p2, i) => {
      push_array(
        chunks,
        handle(p2, {
          ...state,
          indent: state.indent + "	"
        })
      );
      if (state.comments.length) {
        chunks.push(c(", "));
        while (state.comments.length) {
          const comment = state.comments.shift();
          chunks.push(
            c(
              comment.type === "Block" ? `/*${comment.value}*/
${state.indent}	` : `//${comment.value}
${state.indent}	`
            )
          );
          if (comment.type === "Line") {
            has_inline_comment = true;
          }
        }
      } else {
        if (i < node.properties.length - 1) {
          chunks.push(separator);
        }
      }
    });
    const multiple_lines = has_inline_comment || has_newline(chunks) || get_length(chunks) > 40;
    if (multiple_lines) {
      separator.content = `,
${state.indent}	`;
    }
    return [
      c(multiple_lines ? `{
${state.indent}	` : `{ `),
      ...chunks,
      c(multiple_lines ? `
${state.indent}}` : ` }`)
    ];
  },
  Property(node, state) {
    const value = handle(node.value, state);
    if (node.key === node.value) {
      return value;
    }
    if (!node.computed && node.value.type === "AssignmentPattern" && node.value.left.type === "Identifier" && node.value.left.name === node.key.name) {
      return value;
    }
    if (!node.computed && node.value.type === "Identifier" && (node.key.type === "Identifier" && node.key.name === value[0].content || node.key.type === "Literal" && node.key.value === value[0].content)) {
      return value;
    }
    const key = handle(node.key, state);
    if (node.value.type === "FunctionExpression" && !node.value.id) {
      state = {
        ...state,
        scope: state.scope_map.get(node.value)
      };
      const chunks = node.kind !== "init" ? [c(`${node.kind} `)] : [];
      if (node.value.async) {
        chunks.push(c("async "));
      }
      if (node.value.generator) {
        chunks.push(c("*"));
      }
      push_array(chunks, node.computed ? [c("["), ...key, c("]")] : key);
      chunks.push(c("("));
      push_array(
        chunks,
        join(
          node.value.params.map(
            (param) => handle(param, state)
          ),
          c(", ")
        )
      );
      chunks.push(c(") "));
      push_array(chunks, handle(node.value.body, state));
      return chunks;
    }
    if (node.computed) {
      return [c("["), ...key, c("]: "), ...value];
    }
    return [...key, c(": "), ...value];
  },
  ObjectPattern(node, state) {
    const chunks = [c("{ ")];
    for (let i = 0; i < node.properties.length; i += 1) {
      push_array(chunks, handle(node.properties[i], state));
      if (i < node.properties.length - 1)
        chunks.push(c(", "));
    }
    chunks.push(c(" }"));
    return chunks;
  },
  SequenceExpression(node, state) {
    const expressions = node.expressions.map((e) => handle(e, state));
    return [c("("), ...join(expressions, c(", ")), c(")")];
  },
  UnaryExpression(node, state) {
    const chunks = [c(node.operator)];
    if (node.operator.length > 1) {
      chunks.push(c(" "));
    }
    if (EXPRESSIONS_PRECEDENCE[node.argument.type] < EXPRESSIONS_PRECEDENCE.UnaryExpression) {
      chunks.push(c("("));
      push_array(chunks, handle(node.argument, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node.argument, state));
    }
    return chunks;
  },
  UpdateExpression(node, state) {
    return node.prefix ? [c(node.operator), ...handle(node.argument, state)] : [...handle(node.argument, state), c(node.operator)];
  },
  AssignmentExpression(node, state) {
    return [
      ...handle(node.left, state),
      c(` ${node.operator || "="} `),
      ...handle(node.right, state)
    ];
  },
  BinaryExpression(node, state) {
    const chunks = [];
    if (needs_parens(node.left, node, false)) {
      chunks.push(c("("));
      push_array(chunks, handle(node.left, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node.left, state));
    }
    chunks.push(c(` ${node.operator} `));
    if (needs_parens(node.right, node, true)) {
      chunks.push(c("("));
      push_array(chunks, handle(node.right, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node.right, state));
    }
    return chunks;
  },
  ConditionalExpression(node, state) {
    const chunks = [];
    if (EXPRESSIONS_PRECEDENCE[node.test.type] > EXPRESSIONS_PRECEDENCE.ConditionalExpression) {
      push_array(chunks, handle(node.test, state));
    } else {
      chunks.push(c("("));
      push_array(chunks, handle(node.test, state));
      chunks.push(c(")"));
    }
    const child_state = { ...state, indent: state.indent + "	" };
    const consequent = handle(node.consequent, child_state);
    const alternate = handle(node.alternate, child_state);
    const multiple_lines = has_newline(consequent) || has_newline(alternate) || get_length(chunks) + get_length(consequent) + get_length(alternate) > 50;
    if (multiple_lines) {
      chunks.push(c(`
${state.indent}? `));
      push_array(chunks, consequent);
      chunks.push(c(`
${state.indent}: `));
      push_array(chunks, alternate);
    } else {
      chunks.push(c(` ? `));
      push_array(chunks, consequent);
      chunks.push(c(` : `));
      push_array(chunks, alternate);
    }
    return chunks;
  },
  NewExpression(node, state) {
    const chunks = [c("new ")];
    if (EXPRESSIONS_PRECEDENCE[node.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression || has_call_expression(node.callee)) {
      chunks.push(c("("));
      push_array(chunks, handle(node.callee, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node.callee, state));
    }
    const args = node.arguments.map(
      (arg) => handle(arg, {
        ...state,
        indent: state.indent + "	"
      })
    );
    const separator = args.some(has_newline) ? c(",\n" + state.indent) : c(", ");
    chunks.push(c("("));
    push_array(chunks, join(args, separator));
    chunks.push(c(")"));
    return chunks;
  },
  ChainExpression(node, state) {
    return handle(node.expression, state);
  },
  CallExpression(node, state) {
    const chunks = [];
    if (EXPRESSIONS_PRECEDENCE[node.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression) {
      chunks.push(c("("));
      push_array(chunks, handle(node.callee, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node.callee, state));
    }
    if (
      /** @type {SimpleCallExpression} */
      node.optional
    ) {
      chunks.push(c("?."));
    }
    let has_inline_comment = false;
    let arg_chunks = [];
    outer:
      for (const arg of node.arguments) {
        const chunks2 = [];
        while (state.comments.length) {
          const comment = state.comments.shift();
          if (comment.type === "Line") {
            has_inline_comment = true;
            break outer;
          }
          chunks2.push(
            c(
              comment.type === "Block" ? `/*${comment.value}*/ ` : `//${comment.value}`
            )
          );
        }
        push_array(chunks2, handle(arg, state));
        arg_chunks.push(chunks2);
      }
    const multiple_lines = has_inline_comment || arg_chunks.slice(0, -1).some(has_newline);
    if (multiple_lines) {
      const args = node.arguments.map((arg, i) => {
        const chunks2 = handle(arg, {
          ...state,
          indent: `${state.indent}	`
        });
        if (i < node.arguments.length - 1)
          chunks2.push(c(","));
        while (state.comments.length) {
          const comment = state.comments.shift();
          chunks2.push(
            c(
              comment.type === "Block" ? ` /*${comment.value}*/ ` : ` //${comment.value}`
            )
          );
        }
        return chunks2;
      });
      chunks.push(c(`(
${state.indent}	`));
      push_array(chunks, join(args, c(`
${state.indent}	`)));
      chunks.push(c(`
${state.indent})`));
    } else {
      chunks.push(c("("));
      push_array(chunks, join(arg_chunks, c(", ")));
      chunks.push(c(")"));
    }
    return chunks;
  },
  MemberExpression(node, state) {
    const chunks = [];
    if (EXPRESSIONS_PRECEDENCE[node.object.type] < EXPRESSIONS_PRECEDENCE.MemberExpression) {
      chunks.push(c("("));
      push_array(chunks, handle(node.object, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node.object, state));
    }
    if (node.computed) {
      if (node.optional) {
        chunks.push(c("?."));
      }
      chunks.push(c("["));
      push_array(chunks, handle(node.property, state));
      chunks.push(c("]"));
    } else {
      chunks.push(c(node.optional ? "?." : "."));
      push_array(chunks, handle(node.property, state));
    }
    return chunks;
  },
  MetaProperty(node, state) {
    return [
      ...handle(node.meta, state),
      c("."),
      ...handle(node.property, state)
    ];
  },
  Identifier(node, state) {
    let name49 = node.name;
    if (name49[0] === "@") {
      name49 = state.getName(name49.slice(1));
    } else if (node.name[0] === "#") {
      const owner = state.scope.find_owner(node.name);
      if (!owner) {
        throw new Error(`Could not find owner for node`);
      }
      if (!state.deconflicted.has(owner)) {
        state.deconflicted.set(owner, /* @__PURE__ */ new Map());
      }
      const deconflict_map = state.deconflicted.get(owner);
      if (!deconflict_map.has(node.name)) {
        deconflict_map.set(
          node.name,
          deconflict(node.name.slice(1), owner.references)
        );
      }
      name49 = deconflict_map.get(node.name);
    }
    return [c(name49, node)];
  },
  Literal(node, state) {
    if (typeof node.value === "string") {
      return [
        // TODO do we need to handle weird unicode characters somehow?
        // str.replace(/\\u(\d{4})/g, (m, n) => String.fromCharCode(+n))
        c(
          (node.raw || JSON.stringify(node.value)).replace(
            re,
            (_m, _i, at2, hash2, name49) => {
              if (at2)
                return "@" + name49;
              if (hash2)
                return "#" + name49;
              throw new Error(`this shouldn't happen`);
            }
          ),
          node
        )
      ];
    }
    return [c(node.raw || String(node.value), node)];
  },
  PropertyDefinition(node, state) {
    const chunks = [];
    if (node.static) {
      chunks.push(c("static "));
    }
    if (node.computed) {
      chunks.push(c("["), ...handle(node.key, state), c("]"));
    } else {
      chunks.push(...handle(node.key, state));
    }
    if (node.value) {
      chunks.push(c(" = "));
      chunks.push(...handle(node.value, state));
    }
    chunks.push(c(";"));
    return chunks;
  },
  StaticBlock(node, state) {
    const chunks = [c("static ")];
    push_array(chunks, handlers.BlockStatement(node, state));
    return chunks;
  },
  PrivateIdentifier(node, state) {
    const chunks = [c("#")];
    push_array(chunks, [c(node.name, node)]);
    return chunks;
  }
};
handlers.ForOfStatement = handlers.ForInStatement;
handlers.FunctionExpression = handlers.FunctionDeclaration;
handlers.ClassExpression = handlers.ClassDeclaration;
handlers.ClassBody = handlers.BlockStatement;
handlers.SpreadElement = handlers.RestElement;
handlers.ArrayPattern = handlers.ArrayExpression;
handlers.LogicalExpression = handlers.BinaryExpression;
handlers.AssignmentPattern = handlers.AssignmentExpression;

// node_modules/code-red/src/print/index.js
var import_sourcemap_codec = __toESM(require_sourcemap_codec_umd(), 1);
var btoa = () => {
  throw new Error(
    "Unsupported environment: `window.btoa` or `Buffer` should be supported."
  );
};
if (typeof window !== "undefined" && typeof window.btoa === "function") {
  btoa = (str) => window.btoa(unescape(encodeURIComponent(str)));
} else if (typeof Buffer === "function") {
  btoa = (str) => Buffer.from(str, "utf-8").toString("base64");
}
function print(node, opts = {}) {
  if (Array.isArray(node)) {
    return print(
      {
        type: "Program",
        body: node,
        sourceType: "module"
      },
      opts
    );
  }
  const {
    getName = (
      /** @param {string} x */
      (x2) => {
        throw new Error(`Unhandled sigil @${x2}`);
      }
    )
  } = opts;
  let { map: scope_map, scope } = analyze(node);
  const deconflicted = /* @__PURE__ */ new WeakMap();
  const chunks = handle(node, {
    indent: "",
    getName,
    scope,
    scope_map,
    deconflicted,
    comments: []
  });
  let code2 = "";
  let current_column = 0;
  let mappings = [];
  let current_line = [];
  for (let i = 0; i < chunks.length; i += 1) {
    const chunk = chunks[i];
    code2 += chunk.content;
    if (chunk.loc) {
      current_line.push([
        current_column,
        0,
        // source index is always zero
        chunk.loc.start.line - 1,
        chunk.loc.start.column
      ]);
    }
    for (let i2 = 0; i2 < chunk.content.length; i2 += 1) {
      if (chunk.content[i2] === "\n") {
        mappings.push(current_line);
        current_line = [];
        current_column = 0;
      } else {
        current_column += 1;
      }
    }
    if (chunk.loc) {
      current_line.push([
        current_column,
        0,
        // source index is always zero
        chunk.loc.end.line - 1,
        chunk.loc.end.column
      ]);
    }
  }
  mappings.push(current_line);
  const map = {
    version: 3,
    /** @type {string[]} */
    names: [],
    sources: [opts.sourceMapSource || null],
    sourcesContent: [opts.sourceMapContent || null],
    mappings: opts.sourceMapEncodeMappings == void 0 || opts.sourceMapEncodeMappings ? (0, import_sourcemap_codec.encode)(mappings) : mappings
  };
  Object.defineProperties(map, {
    toString: {
      enumerable: false,
      value: function toString3() {
        return JSON.stringify(this);
      }
    },
    toUrl: {
      enumerable: false,
      value: function toUrl() {
        return "data:application/json;charset=utf-8;base64," + btoa(this.toString());
      }
    }
  });
  return {
    code: code2,
    map
  };
}

// node_modules/code-red/src/index.js
var sigils = {
  "@": "AT",
  "#": "HASH"
};
var join2 = (strings) => {
  let str = strings[0];
  for (let i = 1; i < strings.length; i += 1) {
    str += `_${id}_${i - 1}_${strings[i]}`;
  }
  return str.replace(
    /([@#])(\w+)/g,
    (_m, sigil, name49) => `_${id}_${sigils[sigil]}_${name49}`
  );
};
var flatten_body = (array, target) => {
  for (let i = 0; i < array.length; i += 1) {
    const statement = array[i];
    if (Array.isArray(statement)) {
      flatten_body(statement, target);
      continue;
    }
    if (statement.type === "ExpressionStatement") {
      if (statement.expression === EMPTY)
        continue;
      if (Array.isArray(statement.expression)) {
        let node = statement.expression[0];
        while (Array.isArray(node))
          node = node[0];
        if (node)
          node.leadingComments = statement.leadingComments;
        flatten_body(statement.expression, target);
        continue;
      }
      if (/(Expression|Literal)$/.test(statement.expression.type)) {
        target.push(statement);
        continue;
      }
      if (statement.leadingComments)
        statement.expression.leadingComments = statement.leadingComments;
      if (statement.trailingComments)
        statement.expression.trailingComments = statement.trailingComments;
      target.push(statement.expression);
      continue;
    }
    target.push(statement);
  }
  return target;
};
var flatten_properties = (array, target) => {
  for (let i = 0; i < array.length; i += 1) {
    const property2 = array[i];
    if (property2.value === EMPTY)
      continue;
    if (property2.key === property2.value && Array.isArray(property2.key)) {
      flatten_properties(property2.key, target);
      continue;
    }
    target.push(property2);
  }
  return target;
};
var flatten2 = (nodes, target) => {
  for (let i = 0; i < nodes.length; i += 1) {
    const node = nodes[i];
    if (node === EMPTY)
      continue;
    if (Array.isArray(node)) {
      flatten2(node, target);
      continue;
    }
    target.push(node);
  }
  return target;
};
var EMPTY = { type: "Empty" };
var acorn_opts = (comments, raw) => {
  const { onComment } = get_comment_handlers(comments, raw);
  return {
    ecmaVersion: 2022,
    sourceType: "module",
    allowAwaitOutsideFunction: true,
    allowImportExportEverywhere: true,
    allowReturnOutsideFunction: true,
    onComment
  };
};
var inject = (raw, node, values, comments) => {
  comments.forEach((comment) => {
    comment.value = comment.value.replace(
      re,
      (m, i) => +i in values ? values[+i] : m
    );
  });
  const { enter, leave } = get_comment_handlers(comments, raw);
  return walk(node, {
    enter,
    /** @param {any} node */
    leave(node2) {
      if (node2.type === "Identifier") {
        re.lastIndex = 0;
        const match = re.exec(node2.name);
        if (match) {
          if (match[1]) {
            if (+match[1] in values) {
              let value = values[+match[1]];
              if (typeof value === "string") {
                value = {
                  type: "Identifier",
                  name: value,
                  leadingComments: node2.leadingComments,
                  trailingComments: node2.trailingComments
                };
              } else if (typeof value === "number") {
                value = {
                  type: "Literal",
                  value,
                  leadingComments: node2.leadingComments,
                  trailingComments: node2.trailingComments
                };
              }
              this.replace(value || EMPTY);
            }
          } else {
            node2.name = `${match[2] ? `@` : `#`}${match[4]}`;
          }
        }
      }
      if (node2.type === "Literal") {
        if (typeof node2.value === "string") {
          re.lastIndex = 0;
          const new_value = (
            /** @type {string} */
            node2.value.replace(
              re,
              (m, i) => +i in values ? values[+i] : m
            )
          );
          const has_changed = new_value !== node2.value;
          node2.value = new_value;
          if (has_changed && node2.raw) {
            node2.raw = `${node2.raw[0]}${JSON.stringify(node2.value).slice(
              1,
              -1
            )}${node2.raw[node2.raw.length - 1]}`;
          }
        }
      }
      if (node2.type === "TemplateElement") {
        re.lastIndex = 0;
        node2.value.raw = /** @type {string} */
        node2.value.raw.replace(
          re,
          (m, i) => +i in values ? values[+i] : m
        );
      }
      if (node2.type === "Program" || node2.type === "BlockStatement") {
        node2.body = flatten_body(node2.body, []);
      }
      if (node2.type === "ObjectExpression" || node2.type === "ObjectPattern") {
        node2.properties = flatten_properties(node2.properties, []);
      }
      if (node2.type === "ArrayExpression" || node2.type === "ArrayPattern") {
        node2.elements = flatten2(node2.elements, []);
      }
      if (node2.type === "FunctionExpression" || node2.type === "FunctionDeclaration" || node2.type === "ArrowFunctionExpression") {
        node2.params = flatten2(node2.params, []);
      }
      if (node2.type === "CallExpression" || node2.type === "NewExpression") {
        node2.arguments = flatten2(node2.arguments, []);
      }
      if (node2.type === "ImportDeclaration" || node2.type === "ExportNamedDeclaration") {
        node2.specifiers = flatten2(node2.specifiers, []);
      }
      if (node2.type === "ForStatement") {
        node2.init = node2.init === EMPTY ? null : node2.init;
        node2.test = node2.test === EMPTY ? null : node2.test;
        node2.update = node2.update === EMPTY ? null : node2.update;
      }
      leave(node2);
    }
  });
};
function b(strings, ...values) {
  const str = join2(strings);
  const comments = [];
  try {
    let ast = (
      /** @type {any} */
      parse3(str, acorn_opts(comments, str))
    );
    ast = inject(str, ast, values, comments);
    return ast.body;
  } catch (err) {
    handle_error(str, err);
  }
}
function x(strings, ...values) {
  const str = join2(strings);
  const comments = [];
  try {
    let expression = (
      /** @type {Expression & { start: Number, end: number }} */
      parseExpressionAt2(str, 0, acorn_opts(comments, str))
    );
    const match = /\S+/.exec(str.slice(expression.end));
    if (match) {
      throw new Error(`Unexpected token '${match[0]}'`);
    }
    expression = /** @type {Expression & { start: Number, end: number }} */
    inject(str, expression, values, comments);
    return expression;
  } catch (err) {
    handle_error(str, err);
  }
}
function p(strings, ...values) {
  const str = `{${join2(strings)}}`;
  const comments = [];
  try {
    let expression = (
      /** @type {any} */
      parseExpressionAt2(str, 0, acorn_opts(comments, str))
    );
    expression = inject(str, expression, values, comments);
    return expression.properties[0];
  } catch (err) {
    handle_error(str, err);
  }
}
function handle_error(str, err) {
  re.lastIndex = 0;
  str = str.replace(re, (m, i, at2, hash2, name49) => {
    if (at2)
      return `@${name49}`;
    if (hash2)
      return `#${name49}`;
    return "${...}";
  });
  console.log(`failed to parse:
${str}`);
  throw err;
}
var parse4 = (source, opts) => {
  const comments = [];
  const { onComment, enter, leave } = get_comment_handlers(comments, source);
  const ast = (
    /** @type {any} */
    parse3(source, { onComment, ...opts })
  );
  walk(ast, { enter, leave });
  return ast;
};
var parseExpressionAt3 = (source, index, opts) => {
  const comments = [];
  const { onComment, enter, leave } = get_comment_handlers(comments, source);
  const ast = (
    /** @type {any} */
    parseExpressionAt2(source, index, { onComment, ...opts })
  );
  walk(ast, { enter, leave });
  return ast;
};

// node_modules/svelte/src/compiler/parse/acorn.js
var parse5 = (source) => parse4(source, {
  sourceType: "module",
  ecmaVersion: 13,
  locations: true
});
var parse_expression_at = (source, index) => parseExpressionAt3(source, index, {
  sourceType: "module",
  ecmaVersion: 13,
  locations: true
});

// node_modules/svelte/src/compiler/parse/read/expression.js
function read_expression(parser) {
  try {
    const node = parse_expression_at(parser.template, parser.index);
    let num_parens = 0;
    for (let i = parser.index; i < node.start; i += 1) {
      if (parser.template[i] === "(")
        num_parens += 1;
    }
    let index = node.end;
    while (num_parens > 0) {
      const char = parser.template[index];
      if (char === ")") {
        num_parens -= 1;
      } else if (!regex_whitespace.test(char)) {
        parser.error(errors_default.unexpected_token(")"), index);
      }
      index += 1;
    }
    parser.index = index;
    return node;
  } catch (err) {
    parser.acorn_error(err);
  }
}

// node_modules/svelte/src/compiler/parse/read/script.js
var regex_closing_script_tag = /<\/script\s*>/;
var regex_starts_with_closing_script_tag = /^<\/script\s*>/;
function get_context(parser, attributes, start) {
  const context = attributes.find((attribute) => attribute.name === "context");
  if (!context)
    return "default";
  if (context.value.length !== 1 || context.value[0].type !== "Text") {
    parser.error(errors_default.invalid_script_context_attribute, start);
  }
  const value = context.value[0].data;
  if (value !== "module") {
    parser.error(errors_default.invalid_script_context_value, context.start);
  }
  return value;
}
function read_script(parser, start, attributes) {
  const script_start = parser.index;
  const data2 = parser.read_until(regex_closing_script_tag, errors_default.unclosed_script);
  if (parser.index >= parser.template.length) {
    parser.error(errors_default.unclosed_script);
  }
  const source = parser.template.slice(0, script_start).replace(regex_not_newline_characters, " ") + data2;
  parser.read(regex_starts_with_closing_script_tag);
  let ast;
  try {
    ast = parse5(source);
  } catch (err) {
    parser.acorn_error(err);
  }
  ast.start = script_start;
  return {
    type: "Script",
    start,
    end: parser.index,
    context: get_context(parser, attributes, start),
    content: ast
  };
}

// node_modules/css-tree/lib/tokenizer/types.js
var types_exports = {};
__export(types_exports, {
  AtKeyword: () => AtKeyword,
  BadString: () => BadString,
  BadUrl: () => BadUrl,
  CDC: () => CDC,
  CDO: () => CDO,
  Colon: () => Colon,
  Comma: () => Comma,
  Comment: () => Comment,
  Delim: () => Delim,
  Dimension: () => Dimension,
  EOF: () => EOF,
  Function: () => Function2,
  Hash: () => Hash,
  Ident: () => Ident,
  LeftCurlyBracket: () => LeftCurlyBracket,
  LeftParenthesis: () => LeftParenthesis,
  LeftSquareBracket: () => LeftSquareBracket,
  Number: () => Number2,
  Percentage: () => Percentage,
  RightCurlyBracket: () => RightCurlyBracket,
  RightParenthesis: () => RightParenthesis,
  RightSquareBracket: () => RightSquareBracket,
  Semicolon: () => Semicolon,
  String: () => String2,
  Url: () => Url,
  WhiteSpace: () => WhiteSpace
});
var EOF = 0;
var Ident = 1;
var Function2 = 2;
var AtKeyword = 3;
var Hash = 4;
var String2 = 5;
var BadString = 6;
var Url = 7;
var BadUrl = 8;
var Delim = 9;
var Number2 = 10;
var Percentage = 11;
var Dimension = 12;
var WhiteSpace = 13;
var CDO = 14;
var CDC = 15;
var Colon = 16;
var Semicolon = 17;
var Comma = 18;
var LeftSquareBracket = 19;
var RightSquareBracket = 20;
var LeftParenthesis = 21;
var RightParenthesis = 22;
var LeftCurlyBracket = 23;
var RightCurlyBracket = 24;
var Comment = 25;

// node_modules/css-tree/lib/tokenizer/char-code-definitions.js
var EOF2 = 0;
function isDigit(code2) {
  return code2 >= 48 && code2 <= 57;
}
function isHexDigit2(code2) {
  return isDigit(code2) || // 0 .. 9
  code2 >= 65 && code2 <= 70 || // A .. F
  code2 >= 97 && code2 <= 102;
}
function isUppercaseLetter(code2) {
  return code2 >= 65 && code2 <= 90;
}
function isLowercaseLetter(code2) {
  return code2 >= 97 && code2 <= 122;
}
function isLetter(code2) {
  return isUppercaseLetter(code2) || isLowercaseLetter(code2);
}
function isNonAscii(code2) {
  return code2 >= 128;
}
function isNameStart(code2) {
  return isLetter(code2) || isNonAscii(code2) || code2 === 95;
}
function isName(code2) {
  return isNameStart(code2) || isDigit(code2) || code2 === 45;
}
function isNonPrintable(code2) {
  return code2 >= 0 && code2 <= 8 || code2 === 11 || code2 >= 14 && code2 <= 31 || code2 === 127;
}
function isNewline(code2) {
  return code2 === 10 || code2 === 13 || code2 === 12;
}
function isWhiteSpace(code2) {
  return isNewline(code2) || code2 === 32 || code2 === 9;
}
function isValidEscape(first, second) {
  if (first !== 92) {
    return false;
  }
  if (isNewline(second) || second === EOF2) {
    return false;
  }
  return true;
}
function isIdentifierStart2(first, second, third) {
  if (first === 45) {
    return isNameStart(second) || second === 45 || isValidEscape(second, third);
  }
  if (isNameStart(first)) {
    return true;
  }
  if (first === 92) {
    return isValidEscape(first, second);
  }
  return false;
}
function isNumberStart(first, second, third) {
  if (first === 43 || first === 45) {
    if (isDigit(second)) {
      return 2;
    }
    return second === 46 && isDigit(third) ? 3 : 0;
  }
  if (first === 46) {
    return isDigit(second) ? 2 : 0;
  }
  if (isDigit(first)) {
    return 1;
  }
  return 0;
}
function isBOM(code2) {
  if (code2 === 65279) {
    return 1;
  }
  if (code2 === 65534) {
    return 1;
  }
  return 0;
}
var CATEGORY = new Array(128);
var EofCategory = 128;
var WhiteSpaceCategory = 130;
var DigitCategory = 131;
var NameStartCategory = 132;
var NonPrintableCategory = 133;
for (let i = 0; i < CATEGORY.length; i++) {
  CATEGORY[i] = isWhiteSpace(i) && WhiteSpaceCategory || isDigit(i) && DigitCategory || isNameStart(i) && NameStartCategory || isNonPrintable(i) && NonPrintableCategory || i || EofCategory;
}
function charCodeCategory(code2) {
  return code2 < 128 ? CATEGORY[code2] : NameStartCategory;
}

// node_modules/css-tree/lib/tokenizer/utils.js
function getCharCode(source, offset2) {
  return offset2 < source.length ? source.charCodeAt(offset2) : 0;
}
function getNewlineLength(source, offset2, code2) {
  if (code2 === 13 && getCharCode(source, offset2 + 1) === 10) {
    return 2;
  }
  return 1;
}
function cmpChar(testStr, offset2, referenceCode) {
  let code2 = testStr.charCodeAt(offset2);
  if (isUppercaseLetter(code2)) {
    code2 = code2 | 32;
  }
  return code2 === referenceCode;
}
function cmpStr(testStr, start, end, referenceStr) {
  if (end - start !== referenceStr.length) {
    return false;
  }
  if (start < 0 || end > testStr.length) {
    return false;
  }
  for (let i = start; i < end; i++) {
    const referenceCode = referenceStr.charCodeAt(i - start);
    let testCode = testStr.charCodeAt(i);
    if (isUppercaseLetter(testCode)) {
      testCode = testCode | 32;
    }
    if (testCode !== referenceCode) {
      return false;
    }
  }
  return true;
}
function findWhiteSpaceStart(source, offset2) {
  for (; offset2 >= 0; offset2--) {
    if (!isWhiteSpace(source.charCodeAt(offset2))) {
      break;
    }
  }
  return offset2 + 1;
}
function findWhiteSpaceEnd(source, offset2) {
  for (; offset2 < source.length; offset2++) {
    if (!isWhiteSpace(source.charCodeAt(offset2))) {
      break;
    }
  }
  return offset2;
}
function findDecimalNumberEnd(source, offset2) {
  for (; offset2 < source.length; offset2++) {
    if (!isDigit(source.charCodeAt(offset2))) {
      break;
    }
  }
  return offset2;
}
function consumeEscaped(source, offset2) {
  offset2 += 2;
  if (isHexDigit2(getCharCode(source, offset2 - 1))) {
    for (const maxOffset = Math.min(source.length, offset2 + 5); offset2 < maxOffset; offset2++) {
      if (!isHexDigit2(getCharCode(source, offset2))) {
        break;
      }
    }
    const code2 = getCharCode(source, offset2);
    if (isWhiteSpace(code2)) {
      offset2 += getNewlineLength(source, offset2, code2);
    }
  }
  return offset2;
}
function consumeName(source, offset2) {
  for (; offset2 < source.length; offset2++) {
    const code2 = source.charCodeAt(offset2);
    if (isName(code2)) {
      continue;
    }
    if (isValidEscape(code2, getCharCode(source, offset2 + 1))) {
      offset2 = consumeEscaped(source, offset2) - 1;
      continue;
    }
    break;
  }
  return offset2;
}
function consumeNumber(source, offset2) {
  let code2 = source.charCodeAt(offset2);
  if (code2 === 43 || code2 === 45) {
    code2 = source.charCodeAt(offset2 += 1);
  }
  if (isDigit(code2)) {
    offset2 = findDecimalNumberEnd(source, offset2 + 1);
    code2 = source.charCodeAt(offset2);
  }
  if (code2 === 46 && isDigit(source.charCodeAt(offset2 + 1))) {
    offset2 += 2;
    offset2 = findDecimalNumberEnd(source, offset2);
  }
  if (cmpChar(
    source,
    offset2,
    101
    /* e */
  )) {
    let sign = 0;
    code2 = source.charCodeAt(offset2 + 1);
    if (code2 === 45 || code2 === 43) {
      sign = 1;
      code2 = source.charCodeAt(offset2 + 2);
    }
    if (isDigit(code2)) {
      offset2 = findDecimalNumberEnd(source, offset2 + 1 + sign + 1);
    }
  }
  return offset2;
}
function consumeBadUrlRemnants(source, offset2) {
  for (; offset2 < source.length; offset2++) {
    const code2 = source.charCodeAt(offset2);
    if (code2 === 41) {
      offset2++;
      break;
    }
    if (isValidEscape(code2, getCharCode(source, offset2 + 1))) {
      offset2 = consumeEscaped(source, offset2);
    }
  }
  return offset2;
}
function decodeEscaped(escaped2) {
  if (escaped2.length === 1 && !isHexDigit2(escaped2.charCodeAt(0))) {
    return escaped2[0];
  }
  let code2 = parseInt(escaped2, 16);
  if (code2 === 0 || // If this number is zero,
  code2 >= 55296 && code2 <= 57343 || // or is for a surrogate,
  code2 > 1114111) {
    code2 = 65533;
  }
  return String.fromCodePoint(code2);
}

// node_modules/css-tree/lib/tokenizer/names.js
var names_default = [
  "EOF-token",
  "ident-token",
  "function-token",
  "at-keyword-token",
  "hash-token",
  "string-token",
  "bad-string-token",
  "url-token",
  "bad-url-token",
  "delim-token",
  "number-token",
  "percentage-token",
  "dimension-token",
  "whitespace-token",
  "CDO-token",
  "CDC-token",
  "colon-token",
  "semicolon-token",
  "comma-token",
  "[-token",
  "]-token",
  "(-token",
  ")-token",
  "{-token",
  "}-token"
];

// node_modules/css-tree/lib/tokenizer/adopt-buffer.js
var MIN_SIZE = 16 * 1024;
function adoptBuffer(buffer = null, size) {
  if (buffer === null || buffer.length < size) {
    return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
  }
  return buffer;
}

// node_modules/css-tree/lib/tokenizer/OffsetToLocation.js
var N = 10;
var F = 12;
var R = 13;
function computeLinesAndColumns(host) {
  const source = host.source;
  const sourceLength = source.length;
  const startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;
  const lines = adoptBuffer(host.lines, sourceLength);
  const columns = adoptBuffer(host.columns, sourceLength);
  let line = host.startLine;
  let column = host.startColumn;
  for (let i = startOffset; i < sourceLength; i++) {
    const code2 = source.charCodeAt(i);
    lines[i] = line;
    columns[i] = column++;
    if (code2 === N || code2 === R || code2 === F) {
      if (code2 === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
        i++;
        lines[i] = line;
        columns[i] = column;
      }
      line++;
      column = 1;
    }
  }
  lines[sourceLength] = line;
  columns[sourceLength] = column;
  host.lines = lines;
  host.columns = columns;
  host.computed = true;
}
var OffsetToLocation = class {
  constructor() {
    this.lines = null;
    this.columns = null;
    this.computed = false;
  }
  setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {
    this.source = source;
    this.startOffset = startOffset;
    this.startLine = startLine;
    this.startColumn = startColumn;
    this.computed = false;
  }
  getLocation(offset2, filename) {
    if (!this.computed) {
      computeLinesAndColumns(this);
    }
    return {
      source: filename,
      offset: this.startOffset + offset2,
      line: this.lines[offset2],
      column: this.columns[offset2]
    };
  }
  getLocationRange(start, end, filename) {
    if (!this.computed) {
      computeLinesAndColumns(this);
    }
    return {
      source: filename,
      start: {
        offset: this.startOffset + start,
        line: this.lines[start],
        column: this.columns[start]
      },
      end: {
        offset: this.startOffset + end,
        line: this.lines[end],
        column: this.columns[end]
      }
    };
  }
};

// node_modules/css-tree/lib/tokenizer/TokenStream.js
var OFFSET_MASK = 16777215;
var TYPE_SHIFT = 24;
var balancePair = /* @__PURE__ */ new Map([
  [Function2, RightParenthesis],
  [LeftParenthesis, RightParenthesis],
  [LeftSquareBracket, RightSquareBracket],
  [LeftCurlyBracket, RightCurlyBracket]
]);
var TokenStream = class {
  constructor(source, tokenize3) {
    this.setSource(source, tokenize3);
  }
  reset() {
    this.eof = false;
    this.tokenIndex = -1;
    this.tokenType = 0;
    this.tokenStart = this.firstCharOffset;
    this.tokenEnd = this.firstCharOffset;
  }
  setSource(source = "", tokenize3 = () => {
  }) {
    source = String(source || "");
    const sourceLength = source.length;
    const offsetAndType = adoptBuffer(this.offsetAndType, source.length + 1);
    const balance = adoptBuffer(this.balance, source.length + 1);
    let tokenCount = 0;
    let balanceCloseType = 0;
    let balanceStart = 0;
    let firstCharOffset = -1;
    this.offsetAndType = null;
    this.balance = null;
    tokenize3(source, (type, start, end) => {
      switch (type) {
        default:
          balance[tokenCount] = sourceLength;
          break;
        case balanceCloseType: {
          let balancePrev = balanceStart & OFFSET_MASK;
          balanceStart = balance[balancePrev];
          balanceCloseType = balanceStart >> TYPE_SHIFT;
          balance[tokenCount] = balancePrev;
          balance[balancePrev++] = tokenCount;
          for (; balancePrev < tokenCount; balancePrev++) {
            if (balance[balancePrev] === sourceLength) {
              balance[balancePrev] = tokenCount;
            }
          }
          break;
        }
        case LeftParenthesis:
        case Function2:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balance[tokenCount] = balanceStart;
          balanceCloseType = balancePair.get(type);
          balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
          break;
      }
      offsetAndType[tokenCount++] = type << TYPE_SHIFT | end;
      if (firstCharOffset === -1) {
        firstCharOffset = start;
      }
    });
    offsetAndType[tokenCount] = EOF << TYPE_SHIFT | sourceLength;
    balance[tokenCount] = sourceLength;
    balance[sourceLength] = sourceLength;
    while (balanceStart !== 0) {
      const balancePrev = balanceStart & OFFSET_MASK;
      balanceStart = balance[balancePrev];
      balance[balancePrev] = sourceLength;
    }
    this.source = source;
    this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
    this.tokenCount = tokenCount;
    this.offsetAndType = offsetAndType;
    this.balance = balance;
    this.reset();
    this.next();
  }
  lookupType(offset2) {
    offset2 += this.tokenIndex;
    if (offset2 < this.tokenCount) {
      return this.offsetAndType[offset2] >> TYPE_SHIFT;
    }
    return EOF;
  }
  lookupOffset(offset2) {
    offset2 += this.tokenIndex;
    if (offset2 < this.tokenCount) {
      return this.offsetAndType[offset2 - 1] & OFFSET_MASK;
    }
    return this.source.length;
  }
  lookupValue(offset2, referenceStr) {
    offset2 += this.tokenIndex;
    if (offset2 < this.tokenCount) {
      return cmpStr(
        this.source,
        this.offsetAndType[offset2 - 1] & OFFSET_MASK,
        this.offsetAndType[offset2] & OFFSET_MASK,
        referenceStr
      );
    }
    return false;
  }
  getTokenStart(tokenIndex) {
    if (tokenIndex === this.tokenIndex) {
      return this.tokenStart;
    }
    if (tokenIndex > 0) {
      return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
    }
    return this.firstCharOffset;
  }
  substrToCursor(start) {
    return this.source.substring(start, this.tokenStart);
  }
  isBalanceEdge(pos) {
    return this.balance[this.tokenIndex] < pos;
  }
  isDelim(code2, offset2) {
    if (offset2) {
      return this.lookupType(offset2) === Delim && this.source.charCodeAt(this.lookupOffset(offset2)) === code2;
    }
    return this.tokenType === Delim && this.source.charCodeAt(this.tokenStart) === code2;
  }
  skip(tokenCount) {
    let next = this.tokenIndex + tokenCount;
    if (next < this.tokenCount) {
      this.tokenIndex = next;
      this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
      next = this.offsetAndType[next];
      this.tokenType = next >> TYPE_SHIFT;
      this.tokenEnd = next & OFFSET_MASK;
    } else {
      this.tokenIndex = this.tokenCount;
      this.next();
    }
  }
  next() {
    let next = this.tokenIndex + 1;
    if (next < this.tokenCount) {
      this.tokenIndex = next;
      this.tokenStart = this.tokenEnd;
      next = this.offsetAndType[next];
      this.tokenType = next >> TYPE_SHIFT;
      this.tokenEnd = next & OFFSET_MASK;
    } else {
      this.eof = true;
      this.tokenIndex = this.tokenCount;
      this.tokenType = EOF;
      this.tokenStart = this.tokenEnd = this.source.length;
    }
  }
  skipSC() {
    while (this.tokenType === WhiteSpace || this.tokenType === Comment) {
      this.next();
    }
  }
  skipUntilBalanced(startToken, stopConsume) {
    let cursor = startToken;
    let balanceEnd;
    let offset2;
    loop:
      for (; cursor < this.tokenCount; cursor++) {
        balanceEnd = this.balance[cursor];
        if (balanceEnd < startToken) {
          break loop;
        }
        offset2 = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;
        switch (stopConsume(this.source.charCodeAt(offset2))) {
          case 1:
            break loop;
          case 2:
            cursor++;
            break loop;
          default:
            if (this.balance[balanceEnd] === cursor) {
              cursor = balanceEnd;
            }
        }
      }
    this.skip(cursor - this.tokenIndex);
  }
  forEachToken(fn) {
    for (let i = 0, offset2 = this.firstCharOffset; i < this.tokenCount; i++) {
      const start = offset2;
      const item = this.offsetAndType[i];
      const end = item & OFFSET_MASK;
      const type = item >> TYPE_SHIFT;
      offset2 = end;
      fn(type, start, end, i);
    }
  }
  dump() {
    const tokens = new Array(this.tokenCount);
    this.forEachToken((type, start, end, index) => {
      tokens[index] = {
        idx: index,
        type: names_default[type],
        chunk: this.source.substring(start, end),
        balance: this.balance[index]
      };
    });
    return tokens;
  }
};

// node_modules/css-tree/lib/tokenizer/index.js
function tokenize(source, onToken) {
  function getCharCode2(offset3) {
    return offset3 < sourceLength ? source.charCodeAt(offset3) : 0;
  }
  function consumeNumericToken() {
    offset2 = consumeNumber(source, offset2);
    if (isIdentifierStart2(getCharCode2(offset2), getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
      type = Dimension;
      offset2 = consumeName(source, offset2);
      return;
    }
    if (getCharCode2(offset2) === 37) {
      type = Percentage;
      offset2++;
      return;
    }
    type = Number2;
  }
  function consumeIdentLikeToken() {
    const nameStartOffset = offset2;
    offset2 = consumeName(source, offset2);
    if (cmpStr(source, nameStartOffset, offset2, "url") && getCharCode2(offset2) === 40) {
      offset2 = findWhiteSpaceEnd(source, offset2 + 1);
      if (getCharCode2(offset2) === 34 || getCharCode2(offset2) === 39) {
        type = Function2;
        offset2 = nameStartOffset + 4;
        return;
      }
      consumeUrlToken();
      return;
    }
    if (getCharCode2(offset2) === 40) {
      type = Function2;
      offset2++;
      return;
    }
    type = Ident;
  }
  function consumeStringToken(endingCodePoint) {
    if (!endingCodePoint) {
      endingCodePoint = getCharCode2(offset2++);
    }
    type = String2;
    for (; offset2 < source.length; offset2++) {
      const code2 = source.charCodeAt(offset2);
      switch (charCodeCategory(code2)) {
        case endingCodePoint:
          offset2++;
          return;
        case WhiteSpaceCategory:
          if (isNewline(code2)) {
            offset2 += getNewlineLength(source, offset2, code2);
            type = BadString;
            return;
          }
          break;
        case 92:
          if (offset2 === source.length - 1) {
            break;
          }
          const nextCode = getCharCode2(offset2 + 1);
          if (isNewline(nextCode)) {
            offset2 += getNewlineLength(source, offset2 + 1, nextCode);
          } else if (isValidEscape(code2, nextCode)) {
            offset2 = consumeEscaped(source, offset2) - 1;
          }
          break;
      }
    }
  }
  function consumeUrlToken() {
    type = Url;
    offset2 = findWhiteSpaceEnd(source, offset2);
    for (; offset2 < source.length; offset2++) {
      const code2 = source.charCodeAt(offset2);
      switch (charCodeCategory(code2)) {
        case 41:
          offset2++;
          return;
        case WhiteSpaceCategory:
          offset2 = findWhiteSpaceEnd(source, offset2);
          if (getCharCode2(offset2) === 41 || offset2 >= source.length) {
            if (offset2 < source.length) {
              offset2++;
            }
            return;
          }
          offset2 = consumeBadUrlRemnants(source, offset2);
          type = BadUrl;
          return;
        case 34:
        case 39:
        case 40:
        case NonPrintableCategory:
          offset2 = consumeBadUrlRemnants(source, offset2);
          type = BadUrl;
          return;
        case 92:
          if (isValidEscape(code2, getCharCode2(offset2 + 1))) {
            offset2 = consumeEscaped(source, offset2) - 1;
            break;
          }
          offset2 = consumeBadUrlRemnants(source, offset2);
          type = BadUrl;
          return;
      }
    }
  }
  source = String(source || "");
  const sourceLength = source.length;
  let start = isBOM(getCharCode2(0));
  let offset2 = start;
  let type;
  while (offset2 < sourceLength) {
    const code2 = source.charCodeAt(offset2);
    switch (charCodeCategory(code2)) {
      case WhiteSpaceCategory:
        type = WhiteSpace;
        offset2 = findWhiteSpaceEnd(source, offset2 + 1);
        break;
      case 34:
        consumeStringToken();
        break;
      case 35:
        if (isName(getCharCode2(offset2 + 1)) || isValidEscape(getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
          type = Hash;
          offset2 = consumeName(source, offset2 + 1);
        } else {
          type = Delim;
          offset2++;
        }
        break;
      case 39:
        consumeStringToken();
        break;
      case 40:
        type = LeftParenthesis;
        offset2++;
        break;
      case 41:
        type = RightParenthesis;
        offset2++;
        break;
      case 43:
        if (isNumberStart(code2, getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
          consumeNumericToken();
        } else {
          type = Delim;
          offset2++;
        }
        break;
      case 44:
        type = Comma;
        offset2++;
        break;
      case 45:
        if (isNumberStart(code2, getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
          consumeNumericToken();
        } else {
          if (getCharCode2(offset2 + 1) === 45 && getCharCode2(offset2 + 2) === 62) {
            type = CDC;
            offset2 = offset2 + 3;
          } else {
            if (isIdentifierStart2(code2, getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
              consumeIdentLikeToken();
            } else {
              type = Delim;
              offset2++;
            }
          }
        }
        break;
      case 46:
        if (isNumberStart(code2, getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
          consumeNumericToken();
        } else {
          type = Delim;
          offset2++;
        }
        break;
      case 47:
        if (getCharCode2(offset2 + 1) === 42) {
          type = Comment;
          offset2 = source.indexOf("*/", offset2 + 2);
          offset2 = offset2 === -1 ? source.length : offset2 + 2;
        } else {
          type = Delim;
          offset2++;
        }
        break;
      case 58:
        type = Colon;
        offset2++;
        break;
      case 59:
        type = Semicolon;
        offset2++;
        break;
      case 60:
        if (getCharCode2(offset2 + 1) === 33 && getCharCode2(offset2 + 2) === 45 && getCharCode2(offset2 + 3) === 45) {
          type = CDO;
          offset2 = offset2 + 4;
        } else {
          type = Delim;
          offset2++;
        }
        break;
      case 64:
        if (isIdentifierStart2(getCharCode2(offset2 + 1), getCharCode2(offset2 + 2), getCharCode2(offset2 + 3))) {
          type = AtKeyword;
          offset2 = consumeName(source, offset2 + 1);
        } else {
          type = Delim;
          offset2++;
        }
        break;
      case 91:
        type = LeftSquareBracket;
        offset2++;
        break;
      case 92:
        if (isValidEscape(code2, getCharCode2(offset2 + 1))) {
          consumeIdentLikeToken();
        } else {
          type = Delim;
          offset2++;
        }
        break;
      case 93:
        type = RightSquareBracket;
        offset2++;
        break;
      case 123:
        type = LeftCurlyBracket;
        offset2++;
        break;
      case 125:
        type = RightCurlyBracket;
        offset2++;
        break;
      case DigitCategory:
        consumeNumericToken();
        break;
      case NameStartCategory:
        consumeIdentLikeToken();
        break;
      default:
        type = Delim;
        offset2++;
    }
    onToken(type, start, start = offset2);
  }
}

// node_modules/css-tree/lib/utils/List.js
var releasedCursors = null;
var List = class _List {
  static createItem(data2) {
    return {
      prev: null,
      next: null,
      data: data2
    };
  }
  constructor() {
    this.head = null;
    this.tail = null;
    this.cursor = null;
  }
  createItem(data2) {
    return _List.createItem(data2);
  }
  // cursor helpers
  allocateCursor(prev, next) {
    let cursor;
    if (releasedCursors !== null) {
      cursor = releasedCursors;
      releasedCursors = releasedCursors.cursor;
      cursor.prev = prev;
      cursor.next = next;
      cursor.cursor = this.cursor;
    } else {
      cursor = {
        prev,
        next,
        cursor: this.cursor
      };
    }
    this.cursor = cursor;
    return cursor;
  }
  releaseCursor() {
    const { cursor } = this;
    this.cursor = cursor.cursor;
    cursor.prev = null;
    cursor.next = null;
    cursor.cursor = releasedCursors;
    releasedCursors = cursor;
  }
  updateCursors(prevOld, prevNew, nextOld, nextNew) {
    let { cursor } = this;
    while (cursor !== null) {
      if (cursor.prev === prevOld) {
        cursor.prev = prevNew;
      }
      if (cursor.next === nextOld) {
        cursor.next = nextNew;
      }
      cursor = cursor.cursor;
    }
  }
  *[Symbol.iterator]() {
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      yield cursor.data;
    }
  }
  // getters
  get size() {
    let size = 0;
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      size++;
    }
    return size;
  }
  get isEmpty() {
    return this.head === null;
  }
  get first() {
    return this.head && this.head.data;
  }
  get last() {
    return this.tail && this.tail.data;
  }
  // convertors
  fromArray(array) {
    let cursor = null;
    this.head = null;
    for (let data2 of array) {
      const item = _List.createItem(data2);
      if (cursor !== null) {
        cursor.next = item;
      } else {
        this.head = item;
      }
      item.prev = cursor;
      cursor = item;
    }
    this.tail = cursor;
    return this;
  }
  toArray() {
    return [...this];
  }
  toJSON() {
    return [...this];
  }
  // array-like methods
  forEach(fn, thisArg = this) {
    const cursor = this.allocateCursor(null, this.head);
    while (cursor.next !== null) {
      const item = cursor.next;
      cursor.next = item.next;
      fn.call(thisArg, item.data, item, this);
    }
    this.releaseCursor();
  }
  forEachRight(fn, thisArg = this) {
    const cursor = this.allocateCursor(this.tail, null);
    while (cursor.prev !== null) {
      const item = cursor.prev;
      cursor.prev = item.prev;
      fn.call(thisArg, item.data, item, this);
    }
    this.releaseCursor();
  }
  reduce(fn, initialValue, thisArg = this) {
    let cursor = this.allocateCursor(null, this.head);
    let acc = initialValue;
    let item;
    while (cursor.next !== null) {
      item = cursor.next;
      cursor.next = item.next;
      acc = fn.call(thisArg, acc, item.data, item, this);
    }
    this.releaseCursor();
    return acc;
  }
  reduceRight(fn, initialValue, thisArg = this) {
    let cursor = this.allocateCursor(this.tail, null);
    let acc = initialValue;
    let item;
    while (cursor.prev !== null) {
      item = cursor.prev;
      cursor.prev = item.prev;
      acc = fn.call(thisArg, acc, item.data, item, this);
    }
    this.releaseCursor();
    return acc;
  }
  some(fn, thisArg = this) {
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      if (fn.call(thisArg, cursor.data, cursor, this)) {
        return true;
      }
    }
    return false;
  }
  map(fn, thisArg = this) {
    const result = new _List();
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      result.appendData(fn.call(thisArg, cursor.data, cursor, this));
    }
    return result;
  }
  filter(fn, thisArg = this) {
    const result = new _List();
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      if (fn.call(thisArg, cursor.data, cursor, this)) {
        result.appendData(cursor.data);
      }
    }
    return result;
  }
  nextUntil(start, fn, thisArg = this) {
    if (start === null) {
      return;
    }
    const cursor = this.allocateCursor(null, start);
    while (cursor.next !== null) {
      const item = cursor.next;
      cursor.next = item.next;
      if (fn.call(thisArg, item.data, item, this)) {
        break;
      }
    }
    this.releaseCursor();
  }
  prevUntil(start, fn, thisArg = this) {
    if (start === null) {
      return;
    }
    const cursor = this.allocateCursor(start, null);
    while (cursor.prev !== null) {
      const item = cursor.prev;
      cursor.prev = item.prev;
      if (fn.call(thisArg, item.data, item, this)) {
        break;
      }
    }
    this.releaseCursor();
  }
  // mutation
  clear() {
    this.head = null;
    this.tail = null;
  }
  copy() {
    const result = new _List();
    for (let data2 of this) {
      result.appendData(data2);
    }
    return result;
  }
  prepend(item) {
    this.updateCursors(null, item, this.head, item);
    if (this.head !== null) {
      this.head.prev = item;
      item.next = this.head;
    } else {
      this.tail = item;
    }
    this.head = item;
    return this;
  }
  prependData(data2) {
    return this.prepend(_List.createItem(data2));
  }
  append(item) {
    return this.insert(item);
  }
  appendData(data2) {
    return this.insert(_List.createItem(data2));
  }
  insert(item, before = null) {
    if (before !== null) {
      this.updateCursors(before.prev, item, before, item);
      if (before.prev === null) {
        if (this.head !== before) {
          throw new Error("before doesn't belong to list");
        }
        this.head = item;
        before.prev = item;
        item.next = before;
        this.updateCursors(null, item);
      } else {
        before.prev.next = item;
        item.prev = before.prev;
        before.prev = item;
        item.next = before;
      }
    } else {
      this.updateCursors(this.tail, item, null, item);
      if (this.tail !== null) {
        this.tail.next = item;
        item.prev = this.tail;
      } else {
        this.head = item;
      }
      this.tail = item;
    }
    return this;
  }
  insertData(data2, before) {
    return this.insert(_List.createItem(data2), before);
  }
  remove(item) {
    this.updateCursors(item, item.prev, item, item.next);
    if (item.prev !== null) {
      item.prev.next = item.next;
    } else {
      if (this.head !== item) {
        throw new Error("item doesn't belong to list");
      }
      this.head = item.next;
    }
    if (item.next !== null) {
      item.next.prev = item.prev;
    } else {
      if (this.tail !== item) {
        throw new Error("item doesn't belong to list");
      }
      this.tail = item.prev;
    }
    item.prev = null;
    item.next = null;
    return item;
  }
  push(data2) {
    this.insert(_List.createItem(data2));
  }
  pop() {
    return this.tail !== null ? this.remove(this.tail) : null;
  }
  unshift(data2) {
    this.prepend(_List.createItem(data2));
  }
  shift() {
    return this.head !== null ? this.remove(this.head) : null;
  }
  prependList(list2) {
    return this.insertList(list2, this.head);
  }
  appendList(list2) {
    return this.insertList(list2);
  }
  insertList(list2, before) {
    if (list2.head === null) {
      return this;
    }
    if (before !== void 0 && before !== null) {
      this.updateCursors(before.prev, list2.tail, before, list2.head);
      if (before.prev !== null) {
        before.prev.next = list2.head;
        list2.head.prev = before.prev;
      } else {
        this.head = list2.head;
      }
      before.prev = list2.tail;
      list2.tail.next = before;
    } else {
      this.updateCursors(this.tail, list2.tail, null, list2.head);
      if (this.tail !== null) {
        this.tail.next = list2.head;
        list2.head.prev = this.tail;
      } else {
        this.head = list2.head;
      }
      this.tail = list2.tail;
    }
    list2.head = null;
    list2.tail = null;
    return this;
  }
  replace(oldItem, newItemOrList) {
    if ("head" in newItemOrList) {
      this.insertList(newItemOrList, oldItem);
    } else {
      this.insert(newItemOrList, oldItem);
    }
    this.remove(oldItem);
  }
};

// node_modules/css-tree/lib/utils/create-custom-error.js
function createCustomError(name49, message) {
  const error2 = Object.create(SyntaxError.prototype);
  const errorStack = new Error();
  return Object.assign(error2, {
    name: name49,
    message,
    get stack() {
      return (errorStack.stack || "").replace(/^(.+\n){1,3}/, `${name49}: ${message}
`);
    }
  });
}

// node_modules/css-tree/lib/parser/SyntaxError.js
var MAX_LINE_LENGTH = 100;
var OFFSET_CORRECTION = 60;
var TAB_REPLACEMENT = "    ";
function sourceFragment({ source, line, column }, extraLines) {
  function processLines(start, end) {
    return lines.slice(start, end).map(
      (line2, idx) => String(start + idx + 1).padStart(maxNumLength) + " |" + line2
    ).join("\n");
  }
  const lines = source.split(/\r\n?|\n|\f/);
  const startLine = Math.max(1, line - extraLines) - 1;
  const endLine = Math.min(line + extraLines, lines.length + 1);
  const maxNumLength = Math.max(4, String(endLine).length) + 1;
  let cutLeft = 0;
  column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
  if (column > MAX_LINE_LENGTH) {
    cutLeft = column - OFFSET_CORRECTION + 3;
    column = OFFSET_CORRECTION - 2;
  }
  for (let i = startLine; i <= endLine; i++) {
    if (i >= 0 && i < lines.length) {
      lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
      lines[i] = (cutLeft > 0 && lines[i].length > cutLeft ? "…" : "") + lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? "…" : "");
    }
  }
  return [
    processLines(startLine, line),
    new Array(column + maxNumLength + 2).join("-") + "^",
    processLines(line, endLine)
  ].filter(Boolean).join("\n");
}
function SyntaxError2(message, source, offset2, line, column) {
  const error2 = Object.assign(createCustomError("SyntaxError", message), {
    source,
    offset: offset2,
    line,
    column,
    sourceFragment(extraLines) {
      return sourceFragment({ source, line, column }, isNaN(extraLines) ? 0 : extraLines);
    },
    get formattedMessage() {
      return `Parse error: ${message}
` + sourceFragment({ source, line, column }, 2);
    }
  });
  return error2;
}

// node_modules/css-tree/lib/parser/sequence.js
function readSequence(recognizer) {
  const children = this.createList();
  let space = false;
  const context = {
    recognizer
  };
  while (!this.eof) {
    switch (this.tokenType) {
      case Comment:
        this.next();
        continue;
      case WhiteSpace:
        space = true;
        this.next();
        continue;
    }
    let child = recognizer.getNode.call(this, context);
    if (child === void 0) {
      break;
    }
    if (space) {
      if (recognizer.onWhiteSpace) {
        recognizer.onWhiteSpace.call(this, child, children, context);
      }
      space = false;
    }
    children.push(child);
  }
  if (space && recognizer.onWhiteSpace) {
    recognizer.onWhiteSpace.call(this, null, children, context);
  }
  return children;
}

// node_modules/css-tree/lib/parser/create.js
var NOOP = () => {
};
var EXCLAMATIONMARK = 33;
var NUMBERSIGN = 35;
var SEMICOLON = 59;
var LEFTCURLYBRACKET = 123;
var NULL = 0;
function createParseContext(name49) {
  return function() {
    return this[name49]();
  };
}
function fetchParseValues(dict) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const name49 in dict) {
    const item = dict[name49];
    const fn = item.parse || item;
    if (fn) {
      result[name49] = fn;
    }
  }
  return result;
}
function processConfig(config) {
  const parseConfig = {
    context: /* @__PURE__ */ Object.create(null),
    scope: Object.assign(/* @__PURE__ */ Object.create(null), config.scope),
    atrule: fetchParseValues(config.atrule),
    pseudo: fetchParseValues(config.pseudo),
    node: fetchParseValues(config.node)
  };
  for (const name49 in config.parseContext) {
    switch (typeof config.parseContext[name49]) {
      case "function":
        parseConfig.context[name49] = config.parseContext[name49];
        break;
      case "string":
        parseConfig.context[name49] = createParseContext(config.parseContext[name49]);
        break;
    }
  }
  return {
    config: parseConfig,
    ...parseConfig,
    ...parseConfig.node
  };
}
function createParser(config) {
  let source = "";
  let filename = "<unknown>";
  let needPositions = false;
  let onParseError = NOOP;
  let onParseErrorThrow = false;
  const locationMap = new OffsetToLocation();
  const parser = Object.assign(new TokenStream(), processConfig(config || {}), {
    parseAtrulePrelude: true,
    parseRulePrelude: true,
    parseValue: true,
    parseCustomProperty: false,
    readSequence,
    consumeUntilBalanceEnd: () => 0,
    consumeUntilLeftCurlyBracket(code2) {
      return code2 === LEFTCURLYBRACKET ? 1 : 0;
    },
    consumeUntilLeftCurlyBracketOrSemicolon(code2) {
      return code2 === LEFTCURLYBRACKET || code2 === SEMICOLON ? 1 : 0;
    },
    consumeUntilExclamationMarkOrSemicolon(code2) {
      return code2 === EXCLAMATIONMARK || code2 === SEMICOLON ? 1 : 0;
    },
    consumeUntilSemicolonIncluded(code2) {
      return code2 === SEMICOLON ? 2 : 0;
    },
    createList() {
      return new List();
    },
    createSingleNodeList(node) {
      return new List().appendData(node);
    },
    getFirstListNode(list2) {
      return list2 && list2.first;
    },
    getLastListNode(list2) {
      return list2 && list2.last;
    },
    parseWithFallback(consumer, fallback) {
      const startToken = this.tokenIndex;
      try {
        return consumer.call(this);
      } catch (e) {
        if (onParseErrorThrow) {
          throw e;
        }
        const fallbackNode = fallback.call(this, startToken);
        onParseErrorThrow = true;
        onParseError(e, fallbackNode);
        onParseErrorThrow = false;
        return fallbackNode;
      }
    },
    lookupNonWSType(offset2) {
      let type;
      do {
        type = this.lookupType(offset2++);
        if (type !== WhiteSpace) {
          return type;
        }
      } while (type !== NULL);
      return NULL;
    },
    charCodeAt(offset2) {
      return offset2 >= 0 && offset2 < source.length ? source.charCodeAt(offset2) : 0;
    },
    substring(offsetStart, offsetEnd) {
      return source.substring(offsetStart, offsetEnd);
    },
    substrToCursor(start) {
      return this.source.substring(start, this.tokenStart);
    },
    cmpChar(offset2, charCode) {
      return cmpChar(source, offset2, charCode);
    },
    cmpStr(offsetStart, offsetEnd, str) {
      return cmpStr(source, offsetStart, offsetEnd, str);
    },
    consume(tokenType2) {
      const start = this.tokenStart;
      this.eat(tokenType2);
      return this.substrToCursor(start);
    },
    consumeFunctionName() {
      const name49 = source.substring(this.tokenStart, this.tokenEnd - 1);
      this.eat(Function2);
      return name49;
    },
    consumeNumber(type) {
      const number2 = source.substring(this.tokenStart, consumeNumber(source, this.tokenStart));
      this.eat(type);
      return number2;
    },
    eat(tokenType2) {
      if (this.tokenType !== tokenType2) {
        const tokenName = names_default[tokenType2].slice(0, -6).replace(/-/g, " ").replace(/^./, (m) => m.toUpperCase());
        let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
        let offset2 = this.tokenStart;
        switch (tokenType2) {
          case Ident:
            if (this.tokenType === Function2 || this.tokenType === Url) {
              offset2 = this.tokenEnd - 1;
              message = "Identifier is expected but function found";
            } else {
              message = "Identifier is expected";
            }
            break;
          case Hash:
            if (this.isDelim(NUMBERSIGN)) {
              this.next();
              offset2++;
              message = "Name is expected";
            }
            break;
          case Percentage:
            if (this.tokenType === Number2) {
              offset2 = this.tokenEnd;
              message = "Percent sign is expected";
            }
            break;
        }
        this.error(message, offset2);
      }
      this.next();
    },
    eatIdent(name49) {
      if (this.tokenType !== Ident || this.lookupValue(0, name49) === false) {
        this.error(`Identifier "${name49}" is expected`);
      }
      this.next();
    },
    eatDelim(code2) {
      if (!this.isDelim(code2)) {
        this.error(`Delim "${String.fromCharCode(code2)}" is expected`);
      }
      this.next();
    },
    getLocation(start, end) {
      if (needPositions) {
        return locationMap.getLocationRange(
          start,
          end,
          filename
        );
      }
      return null;
    },
    getLocationFromList(list2) {
      if (needPositions) {
        const head = this.getFirstListNode(list2);
        const tail = this.getLastListNode(list2);
        return locationMap.getLocationRange(
          head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart,
          tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart,
          filename
        );
      }
      return null;
    },
    error(message, offset2) {
      const location = typeof offset2 !== "undefined" && offset2 < source.length ? locationMap.getLocation(offset2) : this.eof ? locationMap.getLocation(findWhiteSpaceStart(source, source.length - 1)) : locationMap.getLocation(this.tokenStart);
      throw new SyntaxError2(
        message || "Unexpected input",
        source,
        location.offset,
        location.line,
        location.column
      );
    }
  });
  const parse58 = function(source_, options) {
    source = source_;
    options = options || {};
    parser.setSource(source, tokenize);
    locationMap.setSource(
      source,
      options.offset,
      options.line,
      options.column
    );
    filename = options.filename || "<unknown>";
    needPositions = Boolean(options.positions);
    onParseError = typeof options.onParseError === "function" ? options.onParseError : NOOP;
    onParseErrorThrow = false;
    parser.parseAtrulePrelude = "parseAtrulePrelude" in options ? Boolean(options.parseAtrulePrelude) : true;
    parser.parseRulePrelude = "parseRulePrelude" in options ? Boolean(options.parseRulePrelude) : true;
    parser.parseValue = "parseValue" in options ? Boolean(options.parseValue) : true;
    parser.parseCustomProperty = "parseCustomProperty" in options ? Boolean(options.parseCustomProperty) : false;
    const { context = "default", onComment } = options;
    if (context in parser.context === false) {
      throw new Error("Unknown context `" + context + "`");
    }
    if (typeof onComment === "function") {
      parser.forEachToken((type, start, end) => {
        if (type === Comment) {
          const loc = parser.getLocation(start, end);
          const value = cmpStr(source, end - 2, end, "*/") ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
          onComment(value, loc);
        }
      });
    }
    const ast = parser.context[context].call(parser, options);
    if (!parser.eof) {
      parser.error();
    }
    return ast;
  };
  return Object.assign(parse58, {
    SyntaxError: SyntaxError2,
    config: parser.config
  });
}

// node_modules/css-tree/lib/generator/sourceMap.js
var import_source_map_generator = __toESM(require_source_map_generator(), 1);
var trackNodes = /* @__PURE__ */ new Set(["Atrule", "Selector", "Declaration"]);
function generateSourceMap(handlers3) {
  const map = new import_source_map_generator.SourceMapGenerator();
  const generated = {
    line: 1,
    column: 0
  };
  const original = {
    line: 0,
    // should be zero to add first mapping
    column: 0
  };
  const activatedGenerated = {
    line: 1,
    column: 0
  };
  const activatedMapping = {
    generated: activatedGenerated
  };
  let line = 1;
  let column = 0;
  let sourceMappingActive = false;
  const origHandlersNode = handlers3.node;
  handlers3.node = function(node) {
    if (node.loc && node.loc.start && trackNodes.has(node.type)) {
      const nodeLine = node.loc.start.line;
      const nodeColumn = node.loc.start.column - 1;
      if (original.line !== nodeLine || original.column !== nodeColumn) {
        original.line = nodeLine;
        original.column = nodeColumn;
        generated.line = line;
        generated.column = column;
        if (sourceMappingActive) {
          sourceMappingActive = false;
          if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
            map.addMapping(activatedMapping);
          }
        }
        sourceMappingActive = true;
        map.addMapping({
          source: node.loc.source,
          original,
          generated
        });
      }
    }
    origHandlersNode.call(this, node);
    if (sourceMappingActive && trackNodes.has(node.type)) {
      activatedGenerated.line = line;
      activatedGenerated.column = column;
    }
  };
  const origHandlersEmit = handlers3.emit;
  handlers3.emit = function(value, type, auto) {
    for (let i = 0; i < value.length; i++) {
      if (value.charCodeAt(i) === 10) {
        line++;
        column = 0;
      } else {
        column++;
      }
    }
    origHandlersEmit(value, type, auto);
  };
  const origHandlersResult = handlers3.result;
  handlers3.result = function() {
    if (sourceMappingActive) {
      map.addMapping(activatedMapping);
    }
    return {
      css: origHandlersResult(),
      map
    };
  };
  return handlers3;
}

// node_modules/css-tree/lib/generator/token-before.js
var token_before_exports = {};
__export(token_before_exports, {
  safe: () => safe,
  spec: () => spec
});
var PLUSSIGN = 43;
var HYPHENMINUS = 45;
var code = (type, value) => {
  if (type === Delim) {
    type = value;
  }
  if (typeof type === "string") {
    const charCode = type.charCodeAt(0);
    return charCode > 127 ? 32768 : charCode << 8;
  }
  return type;
};
var specPairs = [
  [Ident, Ident],
  [Ident, Function2],
  [Ident, Url],
  [Ident, BadUrl],
  [Ident, "-"],
  [Ident, Number2],
  [Ident, Percentage],
  [Ident, Dimension],
  [Ident, CDC],
  [Ident, LeftParenthesis],
  [AtKeyword, Ident],
  [AtKeyword, Function2],
  [AtKeyword, Url],
  [AtKeyword, BadUrl],
  [AtKeyword, "-"],
  [AtKeyword, Number2],
  [AtKeyword, Percentage],
  [AtKeyword, Dimension],
  [AtKeyword, CDC],
  [Hash, Ident],
  [Hash, Function2],
  [Hash, Url],
  [Hash, BadUrl],
  [Hash, "-"],
  [Hash, Number2],
  [Hash, Percentage],
  [Hash, Dimension],
  [Hash, CDC],
  [Dimension, Ident],
  [Dimension, Function2],
  [Dimension, Url],
  [Dimension, BadUrl],
  [Dimension, "-"],
  [Dimension, Number2],
  [Dimension, Percentage],
  [Dimension, Dimension],
  [Dimension, CDC],
  ["#", Ident],
  ["#", Function2],
  ["#", Url],
  ["#", BadUrl],
  ["#", "-"],
  ["#", Number2],
  ["#", Percentage],
  ["#", Dimension],
  ["#", CDC],
  // https://github.com/w3c/csswg-drafts/pull/6874
  ["-", Ident],
  ["-", Function2],
  ["-", Url],
  ["-", BadUrl],
  ["-", "-"],
  ["-", Number2],
  ["-", Percentage],
  ["-", Dimension],
  ["-", CDC],
  // https://github.com/w3c/csswg-drafts/pull/6874
  [Number2, Ident],
  [Number2, Function2],
  [Number2, Url],
  [Number2, BadUrl],
  [Number2, Number2],
  [Number2, Percentage],
  [Number2, Dimension],
  [Number2, "%"],
  [Number2, CDC],
  // https://github.com/w3c/csswg-drafts/pull/6874
  ["@", Ident],
  ["@", Function2],
  ["@", Url],
  ["@", BadUrl],
  ["@", "-"],
  ["@", CDC],
  // https://github.com/w3c/csswg-drafts/pull/6874
  [".", Number2],
  [".", Percentage],
  [".", Dimension],
  ["+", Number2],
  ["+", Percentage],
  ["+", Dimension],
  ["/", "*"]
];
var safePairs = specPairs.concat([
  [Ident, Hash],
  [Dimension, Hash],
  [Hash, Hash],
  [AtKeyword, LeftParenthesis],
  [AtKeyword, String2],
  [AtKeyword, Colon],
  [Percentage, Percentage],
  [Percentage, Dimension],
  [Percentage, Function2],
  [Percentage, "-"],
  [RightParenthesis, Ident],
  [RightParenthesis, Function2],
  [RightParenthesis, Percentage],
  [RightParenthesis, Dimension],
  [RightParenthesis, Hash],
  [RightParenthesis, "-"]
]);
function createMap(pairs) {
  const isWhiteSpaceRequired = new Set(
    pairs.map(([prev, next]) => code(prev) << 16 | code(next))
  );
  return function(prevCode, type, value) {
    const nextCode = code(type, value);
    const nextCharCode = value.charCodeAt(0);
    const emitWs = nextCharCode === HYPHENMINUS && type !== Ident && type !== Function2 && type !== CDC || nextCharCode === PLUSSIGN ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8) : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);
    if (emitWs) {
      this.emit(" ", WhiteSpace, true);
    }
    return nextCode;
  };
}
var spec = createMap(specPairs);
var safe = createMap(safePairs);

// node_modules/css-tree/lib/generator/create.js
var REVERSESOLIDUS = 92;
function processChildren(node, delimeter) {
  if (typeof delimeter === "function") {
    let prev = null;
    node.children.forEach((node2) => {
      if (prev !== null) {
        delimeter.call(this, prev);
      }
      this.node(node2);
      prev = node2;
    });
    return;
  }
  node.children.forEach(this.node, this);
}
function processChunk(chunk) {
  tokenize(chunk, (type, start, end) => {
    this.token(type, chunk.slice(start, end));
  });
}
function createGenerator(config) {
  const types2 = /* @__PURE__ */ new Map();
  for (let name49 in config.node) {
    const item = config.node[name49];
    const fn = item.generate || item;
    if (typeof fn === "function") {
      types2.set(name49, item.generate || item);
    }
  }
  return function(node, options) {
    let buffer = "";
    let prevCode = 0;
    let handlers3 = {
      node(node2) {
        if (types2.has(node2.type)) {
          types2.get(node2.type).call(publicApi, node2);
        } else {
          throw new Error("Unknown node type: " + node2.type);
        }
      },
      tokenBefore: safe,
      token(type, value) {
        prevCode = this.tokenBefore(prevCode, type, value);
        this.emit(value, type, false);
        if (type === Delim && value.charCodeAt(0) === REVERSESOLIDUS) {
          this.emit("\n", WhiteSpace, true);
        }
      },
      emit(value) {
        buffer += value;
      },
      result() {
        return buffer;
      }
    };
    if (options) {
      if (typeof options.decorator === "function") {
        handlers3 = options.decorator(handlers3);
      }
      if (options.sourceMap) {
        handlers3 = generateSourceMap(handlers3);
      }
      if (options.mode in token_before_exports) {
        handlers3.tokenBefore = token_before_exports[options.mode];
      }
    }
    const publicApi = {
      node: (node2) => handlers3.node(node2),
      children: processChildren,
      token: (type, value) => handlers3.token(type, value),
      tokenize: processChunk
    };
    handlers3.node(node);
    return handlers3.result();
  };
}

// node_modules/css-tree/lib/convertor/create.js
function createConvertor(walk4) {
  return {
    fromPlainObject(ast) {
      walk4(ast, {
        enter(node) {
          if (node.children && node.children instanceof List === false) {
            node.children = new List().fromArray(node.children);
          }
        }
      });
      return ast;
    },
    toPlainObject(ast) {
      walk4(ast, {
        leave(node) {
          if (node.children && node.children instanceof List) {
            node.children = node.children.toArray();
          }
        }
      });
      return ast;
    }
  };
}

// node_modules/css-tree/lib/walker/create.js
var { hasOwnProperty: hasOwnProperty3 } = Object.prototype;
var noop = function() {
};
function ensureFunction(value) {
  return typeof value === "function" ? value : noop;
}
function invokeForType(fn, type) {
  return function(node, item, list2) {
    if (node.type === type) {
      fn.call(this, node, item, list2);
    }
  };
}
function getWalkersFromStructure(name49, nodeType) {
  const structure49 = nodeType.structure;
  const walkers = [];
  for (const key in structure49) {
    if (hasOwnProperty3.call(structure49, key) === false) {
      continue;
    }
    let fieldTypes = structure49[key];
    const walker = {
      name: key,
      type: false,
      nullable: false
    };
    if (!Array.isArray(fieldTypes)) {
      fieldTypes = [fieldTypes];
    }
    for (const fieldType of fieldTypes) {
      if (fieldType === null) {
        walker.nullable = true;
      } else if (typeof fieldType === "string") {
        walker.type = "node";
      } else if (Array.isArray(fieldType)) {
        walker.type = "list";
      }
    }
    if (walker.type) {
      walkers.push(walker);
    }
  }
  if (walkers.length) {
    return {
      context: nodeType.walkContext,
      fields: walkers
    };
  }
  return null;
}
function getTypesFromConfig(config) {
  const types2 = {};
  for (const name49 in config.node) {
    if (hasOwnProperty3.call(config.node, name49)) {
      const nodeType = config.node[name49];
      if (!nodeType.structure) {
        throw new Error("Missed `structure` field in `" + name49 + "` node type definition");
      }
      types2[name49] = getWalkersFromStructure(name49, nodeType);
    }
  }
  return types2;
}
function createTypeIterator(config, reverse) {
  const fields = config.fields.slice();
  const contextName = config.context;
  const useContext = typeof contextName === "string";
  if (reverse) {
    fields.reverse();
  }
  return function(node, context, walk4, walkReducer) {
    let prevContextValue;
    if (useContext) {
      prevContextValue = context[contextName];
      context[contextName] = node;
    }
    for (const field of fields) {
      const ref2 = node[field.name];
      if (!field.nullable || ref2) {
        if (field.type === "list") {
          const breakWalk = reverse ? ref2.reduceRight(walkReducer, false) : ref2.reduce(walkReducer, false);
          if (breakWalk) {
            return true;
          }
        } else if (walk4(ref2)) {
          return true;
        }
      }
    }
    if (useContext) {
      context[contextName] = prevContextValue;
    }
  };
}
function createFastTraveralMap({
  StyleSheet,
  Atrule: Atrule2,
  Rule: Rule2,
  Block: Block3,
  DeclarationList
}) {
  return {
    Atrule: {
      StyleSheet,
      Atrule: Atrule2,
      Rule: Rule2,
      Block: Block3
    },
    Rule: {
      StyleSheet,
      Atrule: Atrule2,
      Rule: Rule2,
      Block: Block3
    },
    Declaration: {
      StyleSheet,
      Atrule: Atrule2,
      Rule: Rule2,
      Block: Block3,
      DeclarationList
    }
  };
}
function createWalker(config) {
  const types2 = getTypesFromConfig(config);
  const iteratorsNatural = {};
  const iteratorsReverse = {};
  const breakWalk = Symbol("break-walk");
  const skipNode = Symbol("skip-node");
  for (const name49 in types2) {
    if (hasOwnProperty3.call(types2, name49) && types2[name49] !== null) {
      iteratorsNatural[name49] = createTypeIterator(types2[name49], false);
      iteratorsReverse[name49] = createTypeIterator(types2[name49], true);
    }
  }
  const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
  const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);
  const walk4 = function(root, options) {
    function walkNode(node, item, list2) {
      const enterRet = enter.call(context, node, item, list2);
      if (enterRet === breakWalk) {
        return true;
      }
      if (enterRet === skipNode) {
        return false;
      }
      if (iterators.hasOwnProperty(node.type)) {
        if (iterators[node.type](node, context, walkNode, walkReducer)) {
          return true;
        }
      }
      if (leave.call(context, node, item, list2) === breakWalk) {
        return true;
      }
      return false;
    }
    let enter = noop;
    let leave = noop;
    let iterators = iteratorsNatural;
    let walkReducer = (ret, data2, item, list2) => ret || walkNode(data2, item, list2);
    const context = {
      break: breakWalk,
      skip: skipNode,
      root,
      stylesheet: null,
      atrule: null,
      atrulePrelude: null,
      rule: null,
      selector: null,
      block: null,
      declaration: null,
      function: null
    };
    if (typeof options === "function") {
      enter = options;
    } else if (options) {
      enter = ensureFunction(options.enter);
      leave = ensureFunction(options.leave);
      if (options.reverse) {
        iterators = iteratorsReverse;
      }
      if (options.visit) {
        if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
          iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];
        } else if (!types2.hasOwnProperty(options.visit)) {
          throw new Error("Bad value `" + options.visit + "` for `visit` option (should be: " + Object.keys(types2).sort().join(", ") + ")");
        }
        enter = invokeForType(enter, options.visit);
        leave = invokeForType(leave, options.visit);
      }
    }
    if (enter === noop && leave === noop) {
      throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
    }
    walkNode(root);
  };
  walk4.break = breakWalk;
  walk4.skip = skipNode;
  walk4.find = function(ast, fn) {
    let found = null;
    walk4(ast, function(node, item, list2) {
      if (fn.call(this, node, item, list2)) {
        found = node;
        return breakWalk;
      }
    });
    return found;
  };
  walk4.findLast = function(ast, fn) {
    let found = null;
    walk4(ast, {
      reverse: true,
      enter(node, item, list2) {
        if (fn.call(this, node, item, list2)) {
          found = node;
          return breakWalk;
        }
      }
    });
    return found;
  };
  walk4.findAll = function(ast, fn) {
    const found = [];
    walk4(ast, function(node, item, list2) {
      if (fn.call(this, node, item, list2)) {
        found.push(node);
      }
    });
    return found;
  };
  return walk4;
}

// node_modules/css-tree/lib/definition-syntax/generate.js
function noop2(value) {
  return value;
}
function generateMultiplier(multiplier) {
  const { min, max, comma } = multiplier;
  if (min === 0 && max === 0) {
    return comma ? "#?" : "*";
  }
  if (min === 0 && max === 1) {
    return "?";
  }
  if (min === 1 && max === 0) {
    return comma ? "#" : "+";
  }
  if (min === 1 && max === 1) {
    return "";
  }
  return (comma ? "#" : "") + (min === max ? "{" + min + "}" : "{" + min + "," + (max !== 0 ? max : "") + "}");
}
function generateTypeOpts(node) {
  switch (node.type) {
    case "Range":
      return " [" + (node.min === null ? "-∞" : node.min) + "," + (node.max === null ? "∞" : node.max) + "]";
    default:
      throw new Error("Unknown node type `" + node.type + "`");
  }
}
function generateSequence(node, decorate, forceBraces, compact) {
  const combinator = node.combinator === " " || compact ? node.combinator : " " + node.combinator + " ";
  const result = node.terms.map((term) => internalGenerate(term, decorate, forceBraces, compact)).join(combinator);
  if (node.explicit || forceBraces) {
    return (compact || result[0] === "," ? "[" : "[ ") + result + (compact ? "]" : " ]");
  }
  return result;
}
function internalGenerate(node, decorate, forceBraces, compact) {
  let result;
  switch (node.type) {
    case "Group":
      result = generateSequence(node, decorate, forceBraces, compact) + (node.disallowEmpty ? "!" : "");
      break;
    case "Multiplier":
      return internalGenerate(node.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node), node);
    case "Type":
      result = "<" + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : "") + ">";
      break;
    case "Property":
      result = "<'" + node.name + "'>";
      break;
    case "Keyword":
      result = node.name;
      break;
    case "AtKeyword":
      result = "@" + node.name;
      break;
    case "Function":
      result = node.name + "(";
      break;
    case "String":
    case "Token":
      result = node.value;
      break;
    case "Comma":
      result = ",";
      break;
    default:
      throw new Error("Unknown node type `" + node.type + "`");
  }
  return decorate(result, node);
}
function generate(node, options) {
  let decorate = noop2;
  let forceBraces = false;
  let compact = false;
  if (typeof options === "function") {
    decorate = options;
  } else if (options) {
    forceBraces = Boolean(options.forceBraces);
    compact = Boolean(options.compact);
    if (typeof options.decorate === "function") {
      decorate = options.decorate;
    }
  }
  return internalGenerate(node, decorate, forceBraces, compact);
}

// node_modules/css-tree/lib/lexer/error.js
var defaultLoc = { offset: 0, line: 1, column: 1 };
function locateMismatch(matchResult, node) {
  const tokens = matchResult.tokens;
  const longestMatch = matchResult.longestMatch;
  const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
  const badNode = mismatchNode !== node ? mismatchNode : null;
  let mismatchOffset = 0;
  let mismatchLength = 0;
  let entries = 0;
  let css = "";
  let start;
  let end;
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i].value;
    if (i === longestMatch) {
      mismatchLength = token.length;
      mismatchOffset = css.length;
    }
    if (badNode !== null && tokens[i].node === badNode) {
      if (i <= longestMatch) {
        entries++;
      } else {
        entries = 0;
      }
    }
    css += token;
  }
  if (longestMatch === tokens.length || entries > 1) {
    start = fromLoc(badNode || node, "end") || buildLoc(defaultLoc, css);
    end = buildLoc(start);
  } else {
    start = fromLoc(badNode, "start") || buildLoc(fromLoc(node, "start") || defaultLoc, css.slice(0, mismatchOffset));
    end = fromLoc(badNode, "end") || buildLoc(start, css.substr(mismatchOffset, mismatchLength));
  }
  return {
    css,
    mismatchOffset,
    mismatchLength,
    start,
    end
  };
}
function fromLoc(node, point) {
  const value = node && node.loc && node.loc[point];
  if (value) {
    return "line" in value ? buildLoc(value) : value;
  }
  return null;
}
function buildLoc({ offset: offset2, line, column }, extra) {
  const loc = {
    offset: offset2,
    line,
    column
  };
  if (extra) {
    const lines = extra.split(/\n|\r\n?|\f/);
    loc.offset += extra.length;
    loc.line += lines.length - 1;
    loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
  }
  return loc;
}
var SyntaxReferenceError = function(type, referenceName) {
  const error2 = createCustomError(
    "SyntaxReferenceError",
    type + (referenceName ? " `" + referenceName + "`" : "")
  );
  error2.reference = referenceName;
  return error2;
};
var SyntaxMatchError = function(message, syntax, node, matchResult) {
  const error2 = createCustomError("SyntaxMatchError", message);
  const {
    css,
    mismatchOffset,
    mismatchLength,
    start,
    end
  } = locateMismatch(matchResult, node);
  error2.rawMessage = message;
  error2.syntax = syntax ? generate(syntax) : "<generic>";
  error2.css = css;
  error2.mismatchOffset = mismatchOffset;
  error2.mismatchLength = mismatchLength;
  error2.message = message + "\n  syntax: " + error2.syntax + "\n   value: " + (css || "<empty string>") + "\n  --------" + new Array(error2.mismatchOffset + 1).join("-") + "^";
  Object.assign(error2, start);
  error2.loc = {
    source: node && node.loc && node.loc.source || "<unknown>",
    start,
    end
  };
  return error2;
};

// node_modules/css-tree/lib/utils/names.js
var keywords2 = /* @__PURE__ */ new Map();
var properties = /* @__PURE__ */ new Map();
var HYPHENMINUS2 = 45;
var keyword = getKeywordDescriptor;
var property = getPropertyDescriptor;
function isCustomProperty(str, offset2) {
  offset2 = offset2 || 0;
  return str.length - offset2 >= 2 && str.charCodeAt(offset2) === HYPHENMINUS2 && str.charCodeAt(offset2 + 1) === HYPHENMINUS2;
}
function getVendorPrefix(str, offset2) {
  offset2 = offset2 || 0;
  if (str.length - offset2 >= 3) {
    if (str.charCodeAt(offset2) === HYPHENMINUS2 && str.charCodeAt(offset2 + 1) !== HYPHENMINUS2) {
      const secondDashIndex = str.indexOf("-", offset2 + 2);
      if (secondDashIndex !== -1) {
        return str.substring(offset2, secondDashIndex + 1);
      }
    }
  }
  return "";
}
function getKeywordDescriptor(keyword2) {
  if (keywords2.has(keyword2)) {
    return keywords2.get(keyword2);
  }
  const name49 = keyword2.toLowerCase();
  let descriptor = keywords2.get(name49);
  if (descriptor === void 0) {
    const custom = isCustomProperty(name49, 0);
    const vendor = !custom ? getVendorPrefix(name49, 0) : "";
    descriptor = Object.freeze({
      basename: name49.substr(vendor.length),
      name: name49,
      prefix: vendor,
      vendor,
      custom
    });
  }
  keywords2.set(keyword2, descriptor);
  return descriptor;
}
function getPropertyDescriptor(property2) {
  if (properties.has(property2)) {
    return properties.get(property2);
  }
  let name49 = property2;
  let hack = property2[0];
  if (hack === "/") {
    hack = property2[1] === "/" ? "//" : "/";
  } else if (hack !== "_" && hack !== "*" && hack !== "$" && hack !== "#" && hack !== "+" && hack !== "&") {
    hack = "";
  }
  const custom = isCustomProperty(name49, hack.length);
  if (!custom) {
    name49 = name49.toLowerCase();
    if (properties.has(name49)) {
      const descriptor2 = properties.get(name49);
      properties.set(property2, descriptor2);
      return descriptor2;
    }
  }
  const vendor = !custom ? getVendorPrefix(name49, hack.length) : "";
  const prefix = name49.substr(0, hack.length + vendor.length);
  const descriptor = Object.freeze({
    basename: name49.substr(prefix.length),
    name: name49.substr(hack.length),
    hack,
    vendor,
    prefix,
    custom
  });
  properties.set(property2, descriptor);
  return descriptor;
}

// node_modules/css-tree/lib/lexer/generic-const.js
var cssWideKeywords = [
  "initial",
  "inherit",
  "unset",
  "revert",
  "revert-layer"
];

// node_modules/css-tree/lib/lexer/generic-an-plus-b.js
var PLUSSIGN2 = 43;
var HYPHENMINUS3 = 45;
var N2 = 110;
var DISALLOW_SIGN = true;
var ALLOW_SIGN = false;
function isDelim(token, code2) {
  return token !== null && token.type === Delim && token.value.charCodeAt(0) === code2;
}
function skipSC(token, offset2, getNextToken) {
  while (token !== null && (token.type === WhiteSpace || token.type === Comment)) {
    token = getNextToken(++offset2);
  }
  return offset2;
}
function checkInteger(token, valueOffset, disallowSign, offset2) {
  if (!token) {
    return 0;
  }
  const code2 = token.value.charCodeAt(valueOffset);
  if (code2 === PLUSSIGN2 || code2 === HYPHENMINUS3) {
    if (disallowSign) {
      return 0;
    }
    valueOffset++;
  }
  for (; valueOffset < token.value.length; valueOffset++) {
    if (!isDigit(token.value.charCodeAt(valueOffset))) {
      return 0;
    }
  }
  return offset2 + 1;
}
function consumeB(token, offset_, getNextToken) {
  let sign = false;
  let offset2 = skipSC(token, offset_, getNextToken);
  token = getNextToken(offset2);
  if (token === null) {
    return offset_;
  }
  if (token.type !== Number2) {
    if (isDelim(token, PLUSSIGN2) || isDelim(token, HYPHENMINUS3)) {
      sign = true;
      offset2 = skipSC(getNextToken(++offset2), offset2, getNextToken);
      token = getNextToken(offset2);
      if (token === null || token.type !== Number2) {
        return 0;
      }
    } else {
      return offset_;
    }
  }
  if (!sign) {
    const code2 = token.value.charCodeAt(0);
    if (code2 !== PLUSSIGN2 && code2 !== HYPHENMINUS3) {
      return 0;
    }
  }
  return checkInteger(token, sign ? 0 : 1, sign, offset2);
}
function anPlusB(token, getNextToken) {
  let offset2 = 0;
  if (!token) {
    return 0;
  }
  if (token.type === Number2) {
    return checkInteger(token, 0, ALLOW_SIGN, offset2);
  } else if (token.type === Ident && token.value.charCodeAt(0) === HYPHENMINUS3) {
    if (!cmpChar(token.value, 1, N2)) {
      return 0;
    }
    switch (token.value.length) {
      case 2:
        return consumeB(getNextToken(++offset2), offset2, getNextToken);
      case 3:
        if (token.value.charCodeAt(2) !== HYPHENMINUS3) {
          return 0;
        }
        offset2 = skipSC(getNextToken(++offset2), offset2, getNextToken);
        token = getNextToken(offset2);
        return checkInteger(token, 0, DISALLOW_SIGN, offset2);
      default:
        if (token.value.charCodeAt(2) !== HYPHENMINUS3) {
          return 0;
        }
        return checkInteger(token, 3, DISALLOW_SIGN, offset2);
    }
  } else if (token.type === Ident || isDelim(token, PLUSSIGN2) && getNextToken(offset2 + 1).type === Ident) {
    if (token.type !== Ident) {
      token = getNextToken(++offset2);
    }
    if (token === null || !cmpChar(token.value, 0, N2)) {
      return 0;
    }
    switch (token.value.length) {
      case 1:
        return consumeB(getNextToken(++offset2), offset2, getNextToken);
      case 2:
        if (token.value.charCodeAt(1) !== HYPHENMINUS3) {
          return 0;
        }
        offset2 = skipSC(getNextToken(++offset2), offset2, getNextToken);
        token = getNextToken(offset2);
        return checkInteger(token, 0, DISALLOW_SIGN, offset2);
      default:
        if (token.value.charCodeAt(1) !== HYPHENMINUS3) {
          return 0;
        }
        return checkInteger(token, 2, DISALLOW_SIGN, offset2);
    }
  } else if (token.type === Dimension) {
    let code2 = token.value.charCodeAt(0);
    let sign = code2 === PLUSSIGN2 || code2 === HYPHENMINUS3 ? 1 : 0;
    let i = sign;
    for (; i < token.value.length; i++) {
      if (!isDigit(token.value.charCodeAt(i))) {
        break;
      }
    }
    if (i === sign) {
      return 0;
    }
    if (!cmpChar(token.value, i, N2)) {
      return 0;
    }
    if (i + 1 === token.value.length) {
      return consumeB(getNextToken(++offset2), offset2, getNextToken);
    } else {
      if (token.value.charCodeAt(i + 1) !== HYPHENMINUS3) {
        return 0;
      }
      if (i + 2 === token.value.length) {
        offset2 = skipSC(getNextToken(++offset2), offset2, getNextToken);
        token = getNextToken(offset2);
        return checkInteger(token, 0, DISALLOW_SIGN, offset2);
      } else {
        return checkInteger(token, i + 2, DISALLOW_SIGN, offset2);
      }
    }
  }
  return 0;
}

// node_modules/css-tree/lib/lexer/generic-urange.js
var PLUSSIGN3 = 43;
var HYPHENMINUS4 = 45;
var QUESTIONMARK = 63;
var U = 117;
function isDelim2(token, code2) {
  return token !== null && token.type === Delim && token.value.charCodeAt(0) === code2;
}
function startsWith(token, code2) {
  return token.value.charCodeAt(0) === code2;
}
function hexSequence(token, offset2, allowDash) {
  let hexlen = 0;
  for (let pos = offset2; pos < token.value.length; pos++) {
    const code2 = token.value.charCodeAt(pos);
    if (code2 === HYPHENMINUS4 && allowDash && hexlen !== 0) {
      hexSequence(token, offset2 + hexlen + 1, false);
      return 6;
    }
    if (!isHexDigit2(code2)) {
      return 0;
    }
    if (++hexlen > 6) {
      return 0;
    }
    ;
  }
  return hexlen;
}
function withQuestionMarkSequence(consumed, length2, getNextToken) {
  if (!consumed) {
    return 0;
  }
  while (isDelim2(getNextToken(length2), QUESTIONMARK)) {
    if (++consumed > 6) {
      return 0;
    }
    length2++;
  }
  return length2;
}
function urange(token, getNextToken) {
  let length2 = 0;
  if (token === null || token.type !== Ident || !cmpChar(token.value, 0, U)) {
    return 0;
  }
  token = getNextToken(++length2);
  if (token === null) {
    return 0;
  }
  if (isDelim2(token, PLUSSIGN3)) {
    token = getNextToken(++length2);
    if (token === null) {
      return 0;
    }
    if (token.type === Ident) {
      return withQuestionMarkSequence(hexSequence(token, 0, true), ++length2, getNextToken);
    }
    if (isDelim2(token, QUESTIONMARK)) {
      return withQuestionMarkSequence(1, ++length2, getNextToken);
    }
    return 0;
  }
  if (token.type === Number2) {
    const consumedHexLength = hexSequence(token, 1, true);
    if (consumedHexLength === 0) {
      return 0;
    }
    token = getNextToken(++length2);
    if (token === null) {
      return length2;
    }
    if (token.type === Dimension || token.type === Number2) {
      if (!startsWith(token, HYPHENMINUS4) || !hexSequence(token, 1, false)) {
        return 0;
      }
      return length2 + 1;
    }
    return withQuestionMarkSequence(consumedHexLength, length2, getNextToken);
  }
  if (token.type === Dimension) {
    return withQuestionMarkSequence(hexSequence(token, 1, true), ++length2, getNextToken);
  }
  return 0;
}

// node_modules/css-tree/lib/lexer/generic.js
var calcFunctionNames = ["calc(", "-moz-calc(", "-webkit-calc("];
var balancePair2 = /* @__PURE__ */ new Map([
  [Function2, RightParenthesis],
  [LeftParenthesis, RightParenthesis],
  [LeftSquareBracket, RightSquareBracket],
  [LeftCurlyBracket, RightCurlyBracket]
]);
function charCodeAt(str, index) {
  return index < str.length ? str.charCodeAt(index) : 0;
}
function eqStr(actual, expected) {
  return cmpStr(actual, 0, actual.length, expected);
}
function eqStrAny(actual, expected) {
  for (let i = 0; i < expected.length; i++) {
    if (eqStr(actual, expected[i])) {
      return true;
    }
  }
  return false;
}
function isPostfixIeHack(str, offset2) {
  if (offset2 !== str.length - 2) {
    return false;
  }
  return charCodeAt(str, offset2) === 92 && // U+005C REVERSE SOLIDUS (\)
  isDigit(charCodeAt(str, offset2 + 1));
}
function outOfRange(opts, value, numEnd) {
  if (opts && opts.type === "Range") {
    const num = Number(
      numEnd !== void 0 && numEnd !== value.length ? value.substr(0, numEnd) : value
    );
    if (isNaN(num)) {
      return true;
    }
    if (opts.min !== null && num < opts.min && typeof opts.min !== "string") {
      return true;
    }
    if (opts.max !== null && num > opts.max && typeof opts.max !== "string") {
      return true;
    }
  }
  return false;
}
function consumeFunction(token, getNextToken) {
  let balanceCloseType = 0;
  let balanceStash = [];
  let length2 = 0;
  scan:
    do {
      switch (token.type) {
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          if (balanceStash.length === 0) {
            length2++;
            break scan;
          }
          break;
        case Function2:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair2.get(token.type);
          break;
      }
      length2++;
    } while (token = getNextToken(length2));
  return length2;
}
function calc(next) {
  return function(token, getNextToken, opts) {
    if (token === null) {
      return 0;
    }
    if (token.type === Function2 && eqStrAny(token.value, calcFunctionNames)) {
      return consumeFunction(token, getNextToken);
    }
    return next(token, getNextToken, opts);
  };
}
function tokenType(expectedTokenType) {
  return function(token) {
    if (token === null || token.type !== expectedTokenType) {
      return 0;
    }
    return 1;
  };
}
function customIdent(token) {
  if (token === null || token.type !== Ident) {
    return 0;
  }
  const name49 = token.value.toLowerCase();
  if (eqStrAny(name49, cssWideKeywords)) {
    return 0;
  }
  if (eqStr(name49, "default")) {
    return 0;
  }
  return 1;
}
function customPropertyName(token) {
  if (token === null || token.type !== Ident) {
    return 0;
  }
  if (charCodeAt(token.value, 0) !== 45 || charCodeAt(token.value, 1) !== 45) {
    return 0;
  }
  return 1;
}
function hexColor(token) {
  if (token === null || token.type !== Hash) {
    return 0;
  }
  const length2 = token.value.length;
  if (length2 !== 4 && length2 !== 5 && length2 !== 7 && length2 !== 9) {
    return 0;
  }
  for (let i = 1; i < length2; i++) {
    if (!isHexDigit2(charCodeAt(token.value, i))) {
      return 0;
    }
  }
  return 1;
}
function idSelector(token) {
  if (token === null || token.type !== Hash) {
    return 0;
  }
  if (!isIdentifierStart2(charCodeAt(token.value, 1), charCodeAt(token.value, 2), charCodeAt(token.value, 3))) {
    return 0;
  }
  return 1;
}
function declarationValue(token, getNextToken) {
  if (!token) {
    return 0;
  }
  let balanceCloseType = 0;
  let balanceStash = [];
  let length2 = 0;
  scan:
    do {
      switch (token.type) {
        case BadString:
        case BadUrl:
          break scan;
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          break;
        case Semicolon:
          if (balanceCloseType === 0) {
            break scan;
          }
          break;
        case Delim:
          if (balanceCloseType === 0 && token.value === "!") {
            break scan;
          }
          break;
        case Function2:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair2.get(token.type);
          break;
      }
      length2++;
    } while (token = getNextToken(length2));
  return length2;
}
function anyValue(token, getNextToken) {
  if (!token) {
    return 0;
  }
  let balanceCloseType = 0;
  let balanceStash = [];
  let length2 = 0;
  scan:
    do {
      switch (token.type) {
        case BadString:
        case BadUrl:
          break scan;
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          break;
        case Function2:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair2.get(token.type);
          break;
      }
      length2++;
    } while (token = getNextToken(length2));
  return length2;
}
function dimension(type) {
  if (type) {
    type = new Set(type);
  }
  return function(token, getNextToken, opts) {
    if (token === null || token.type !== Dimension) {
      return 0;
    }
    const numberEnd = consumeNumber(token.value, 0);
    if (type !== null) {
      const reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
      const unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);
      if (type.has(unit.toLowerCase()) === false) {
        return 0;
      }
    }
    if (outOfRange(opts, token.value, numberEnd)) {
      return 0;
    }
    return 1;
  };
}
function percentage(token, getNextToken, opts) {
  if (token === null || token.type !== Percentage) {
    return 0;
  }
  if (outOfRange(opts, token.value, token.value.length - 1)) {
    return 0;
  }
  return 1;
}
function zero(next) {
  if (typeof next !== "function") {
    next = function() {
      return 0;
    };
  }
  return function(token, getNextToken, opts) {
    if (token !== null && token.type === Number2) {
      if (Number(token.value) === 0) {
        return 1;
      }
    }
    return next(token, getNextToken, opts);
  };
}
function number(token, getNextToken, opts) {
  if (token === null) {
    return 0;
  }
  const numberEnd = consumeNumber(token.value, 0);
  const isNumber = numberEnd === token.value.length;
  if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
    return 0;
  }
  if (outOfRange(opts, token.value, numberEnd)) {
    return 0;
  }
  return 1;
}
function integer(token, getNextToken, opts) {
  if (token === null || token.type !== Number2) {
    return 0;
  }
  let i = charCodeAt(token.value, 0) === 43 || // U+002B PLUS SIGN (+)
  charCodeAt(token.value, 0) === 45 ? 1 : 0;
  for (; i < token.value.length; i++) {
    if (!isDigit(charCodeAt(token.value, i))) {
      return 0;
    }
  }
  if (outOfRange(opts, token.value, i)) {
    return 0;
  }
  return 1;
}
var tokenTypes = {
  "ident-token": tokenType(Ident),
  "function-token": tokenType(Function2),
  "at-keyword-token": tokenType(AtKeyword),
  "hash-token": tokenType(Hash),
  "string-token": tokenType(String2),
  "bad-string-token": tokenType(BadString),
  "url-token": tokenType(Url),
  "bad-url-token": tokenType(BadUrl),
  "delim-token": tokenType(Delim),
  "number-token": tokenType(Number2),
  "percentage-token": tokenType(Percentage),
  "dimension-token": tokenType(Dimension),
  "whitespace-token": tokenType(WhiteSpace),
  "CDO-token": tokenType(CDO),
  "CDC-token": tokenType(CDC),
  "colon-token": tokenType(Colon),
  "semicolon-token": tokenType(Semicolon),
  "comma-token": tokenType(Comma),
  "[-token": tokenType(LeftSquareBracket),
  "]-token": tokenType(RightSquareBracket),
  "(-token": tokenType(LeftParenthesis),
  ")-token": tokenType(RightParenthesis),
  "{-token": tokenType(LeftCurlyBracket),
  "}-token": tokenType(RightCurlyBracket)
};
var productionTypes = {
  // token type aliases
  "string": tokenType(String2),
  "ident": tokenType(Ident),
  // percentage
  "percentage": calc(percentage),
  // numeric
  "zero": zero(),
  "number": calc(number),
  "integer": calc(integer),
  // complex types
  "custom-ident": customIdent,
  "custom-property-name": customPropertyName,
  "hex-color": hexColor,
  "id-selector": idSelector,
  // element( <id-selector> )
  "an-plus-b": anPlusB,
  "urange": urange,
  "declaration-value": declarationValue,
  "any-value": anyValue
};
function createDemensionTypes(units) {
  const {
    angle: angle2,
    decibel: decibel2,
    frequency: frequency2,
    flex: flex2,
    length: length2,
    resolution: resolution2,
    semitones: semitones2,
    time: time2
  } = units || {};
  return {
    "dimension": calc(dimension(null)),
    "angle": calc(dimension(angle2)),
    "decibel": calc(dimension(decibel2)),
    "frequency": calc(dimension(frequency2)),
    "flex": calc(dimension(flex2)),
    "length": calc(zero(dimension(length2))),
    "resolution": calc(dimension(resolution2)),
    "semitones": calc(dimension(semitones2)),
    "time": calc(dimension(time2))
  };
}
function createGenericTypes(units) {
  return {
    ...tokenTypes,
    ...productionTypes,
    ...createDemensionTypes(units)
  };
}

// node_modules/css-tree/lib/lexer/units.js
var units_exports = {};
__export(units_exports, {
  angle: () => angle,
  decibel: () => decibel,
  flex: () => flex,
  frequency: () => frequency,
  length: () => length,
  resolution: () => resolution,
  semitones: () => semitones,
  time: () => time
});
var length = [
  // absolute length units https://www.w3.org/TR/css-values-3/#lengths
  "cm",
  "mm",
  "q",
  "in",
  "pt",
  "pc",
  "px",
  // font-relative length units https://drafts.csswg.org/css-values-4/#font-relative-lengths
  "em",
  "rem",
  "ex",
  "rex",
  "cap",
  "rcap",
  "ch",
  "rch",
  "ic",
  "ric",
  "lh",
  "rlh",
  // viewport-percentage lengths https://drafts.csswg.org/css-values-4/#viewport-relative-lengths
  "vw",
  "svw",
  "lvw",
  "dvw",
  "vh",
  "svh",
  "lvh",
  "dvh",
  "vi",
  "svi",
  "lvi",
  "dvi",
  "vb",
  "svb",
  "lvb",
  "dvb",
  "vmin",
  "svmin",
  "lvmin",
  "dvmin",
  "vmax",
  "svmax",
  "lvmax",
  "dvmax",
  // container relative lengths https://drafts.csswg.org/css-contain-3/#container-lengths
  "cqw",
  "cqh",
  "cqi",
  "cqb",
  "cqmin",
  "cqmax"
];
var angle = ["deg", "grad", "rad", "turn"];
var time = ["s", "ms"];
var frequency = ["hz", "khz"];
var resolution = ["dpi", "dpcm", "dppx", "x"];
var flex = ["fr"];
var decibel = ["db"];
var semitones = ["st"];

// node_modules/css-tree/lib/definition-syntax/index.js
var definition_syntax_exports = {};
__export(definition_syntax_exports, {
  SyntaxError: () => SyntaxError3,
  generate: () => generate,
  parse: () => parse6,
  walk: () => walk2
});

// node_modules/css-tree/lib/definition-syntax/SyntaxError.js
function SyntaxError3(message, input, offset2) {
  return Object.assign(createCustomError("SyntaxError", message), {
    input,
    offset: offset2,
    rawMessage: message,
    message: message + "\n  " + input + "\n--" + new Array((offset2 || input.length) + 1).join("-") + "^"
  });
}

// node_modules/css-tree/lib/definition-syntax/tokenizer.js
var TAB = 9;
var N3 = 10;
var F2 = 12;
var R2 = 13;
var SPACE = 32;
var Tokenizer = class {
  constructor(str) {
    this.str = str;
    this.pos = 0;
  }
  charCodeAt(pos) {
    return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
  }
  charCode() {
    return this.charCodeAt(this.pos);
  }
  nextCharCode() {
    return this.charCodeAt(this.pos + 1);
  }
  nextNonWsCode(pos) {
    return this.charCodeAt(this.findWsEnd(pos));
  }
  findWsEnd(pos) {
    for (; pos < this.str.length; pos++) {
      const code2 = this.str.charCodeAt(pos);
      if (code2 !== R2 && code2 !== N3 && code2 !== F2 && code2 !== SPACE && code2 !== TAB) {
        break;
      }
    }
    return pos;
  }
  substringToPos(end) {
    return this.str.substring(this.pos, this.pos = end);
  }
  eat(code2) {
    if (this.charCode() !== code2) {
      this.error("Expect `" + String.fromCharCode(code2) + "`");
    }
    this.pos++;
  }
  peek() {
    return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
  }
  error(message) {
    throw new SyntaxError3(message, this.str, this.pos);
  }
};

// node_modules/css-tree/lib/definition-syntax/parse.js
var TAB2 = 9;
var N4 = 10;
var F3 = 12;
var R3 = 13;
var SPACE2 = 32;
var EXCLAMATIONMARK2 = 33;
var NUMBERSIGN2 = 35;
var AMPERSAND = 38;
var APOSTROPHE = 39;
var LEFTPARENTHESIS = 40;
var RIGHTPARENTHESIS = 41;
var ASTERISK = 42;
var PLUSSIGN4 = 43;
var COMMA = 44;
var HYPERMINUS = 45;
var LESSTHANSIGN = 60;
var GREATERTHANSIGN = 62;
var QUESTIONMARK2 = 63;
var COMMERCIALAT = 64;
var LEFTSQUAREBRACKET = 91;
var RIGHTSQUAREBRACKET = 93;
var LEFTCURLYBRACKET2 = 123;
var VERTICALLINE = 124;
var RIGHTCURLYBRACKET = 125;
var INFINITY = 8734;
var NAME_CHAR = new Uint8Array(128).map(
  (_, idx) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0
);
var COMBINATOR_PRECEDENCE = {
  " ": 1,
  "&&": 2,
  "||": 3,
  "|": 4
};
function scanSpaces(tokenizer2) {
  return tokenizer2.substringToPos(
    tokenizer2.findWsEnd(tokenizer2.pos)
  );
}
function scanWord(tokenizer2) {
  let end = tokenizer2.pos;
  for (; end < tokenizer2.str.length; end++) {
    const code2 = tokenizer2.str.charCodeAt(end);
    if (code2 >= 128 || NAME_CHAR[code2] === 0) {
      break;
    }
  }
  if (tokenizer2.pos === end) {
    tokenizer2.error("Expect a keyword");
  }
  return tokenizer2.substringToPos(end);
}
function scanNumber(tokenizer2) {
  let end = tokenizer2.pos;
  for (; end < tokenizer2.str.length; end++) {
    const code2 = tokenizer2.str.charCodeAt(end);
    if (code2 < 48 || code2 > 57) {
      break;
    }
  }
  if (tokenizer2.pos === end) {
    tokenizer2.error("Expect a number");
  }
  return tokenizer2.substringToPos(end);
}
function scanString(tokenizer2) {
  const end = tokenizer2.str.indexOf("'", tokenizer2.pos + 1);
  if (end === -1) {
    tokenizer2.pos = tokenizer2.str.length;
    tokenizer2.error("Expect an apostrophe");
  }
  return tokenizer2.substringToPos(end + 1);
}
function readMultiplierRange(tokenizer2) {
  let min = null;
  let max = null;
  tokenizer2.eat(LEFTCURLYBRACKET2);
  min = scanNumber(tokenizer2);
  if (tokenizer2.charCode() === COMMA) {
    tokenizer2.pos++;
    if (tokenizer2.charCode() !== RIGHTCURLYBRACKET) {
      max = scanNumber(tokenizer2);
    }
  } else {
    max = min;
  }
  tokenizer2.eat(RIGHTCURLYBRACKET);
  return {
    min: Number(min),
    max: max ? Number(max) : 0
  };
}
function readMultiplier(tokenizer2) {
  let range = null;
  let comma = false;
  switch (tokenizer2.charCode()) {
    case ASTERISK:
      tokenizer2.pos++;
      range = {
        min: 0,
        max: 0
      };
      break;
    case PLUSSIGN4:
      tokenizer2.pos++;
      range = {
        min: 1,
        max: 0
      };
      break;
    case QUESTIONMARK2:
      tokenizer2.pos++;
      range = {
        min: 0,
        max: 1
      };
      break;
    case NUMBERSIGN2:
      tokenizer2.pos++;
      comma = true;
      if (tokenizer2.charCode() === LEFTCURLYBRACKET2) {
        range = readMultiplierRange(tokenizer2);
      } else if (tokenizer2.charCode() === QUESTIONMARK2) {
        tokenizer2.pos++;
        range = {
          min: 0,
          max: 0
        };
      } else {
        range = {
          min: 1,
          max: 0
        };
      }
      break;
    case LEFTCURLYBRACKET2:
      range = readMultiplierRange(tokenizer2);
      break;
    default:
      return null;
  }
  return {
    type: "Multiplier",
    comma,
    min: range.min,
    max: range.max,
    term: null
  };
}
function maybeMultiplied(tokenizer2, node) {
  const multiplier = readMultiplier(tokenizer2);
  if (multiplier !== null) {
    multiplier.term = node;
    if (tokenizer2.charCode() === NUMBERSIGN2 && tokenizer2.charCodeAt(tokenizer2.pos - 1) === PLUSSIGN4) {
      return maybeMultiplied(tokenizer2, multiplier);
    }
    return multiplier;
  }
  return node;
}
function maybeToken(tokenizer2) {
  const ch = tokenizer2.peek();
  if (ch === "") {
    return null;
  }
  return {
    type: "Token",
    value: ch
  };
}
function readProperty(tokenizer2) {
  let name49;
  tokenizer2.eat(LESSTHANSIGN);
  tokenizer2.eat(APOSTROPHE);
  name49 = scanWord(tokenizer2);
  tokenizer2.eat(APOSTROPHE);
  tokenizer2.eat(GREATERTHANSIGN);
  return maybeMultiplied(tokenizer2, {
    type: "Property",
    name: name49
  });
}
function readTypeRange(tokenizer2) {
  let min = null;
  let max = null;
  let sign = 1;
  tokenizer2.eat(LEFTSQUAREBRACKET);
  if (tokenizer2.charCode() === HYPERMINUS) {
    tokenizer2.peek();
    sign = -1;
  }
  if (sign == -1 && tokenizer2.charCode() === INFINITY) {
    tokenizer2.peek();
  } else {
    min = sign * Number(scanNumber(tokenizer2));
    if (NAME_CHAR[tokenizer2.charCode()] !== 0) {
      min += scanWord(tokenizer2);
    }
  }
  scanSpaces(tokenizer2);
  tokenizer2.eat(COMMA);
  scanSpaces(tokenizer2);
  if (tokenizer2.charCode() === INFINITY) {
    tokenizer2.peek();
  } else {
    sign = 1;
    if (tokenizer2.charCode() === HYPERMINUS) {
      tokenizer2.peek();
      sign = -1;
    }
    max = sign * Number(scanNumber(tokenizer2));
    if (NAME_CHAR[tokenizer2.charCode()] !== 0) {
      max += scanWord(tokenizer2);
    }
  }
  tokenizer2.eat(RIGHTSQUAREBRACKET);
  return {
    type: "Range",
    min,
    max
  };
}
function readType(tokenizer2) {
  let name49;
  let opts = null;
  tokenizer2.eat(LESSTHANSIGN);
  name49 = scanWord(tokenizer2);
  if (tokenizer2.charCode() === LEFTPARENTHESIS && tokenizer2.nextCharCode() === RIGHTPARENTHESIS) {
    tokenizer2.pos += 2;
    name49 += "()";
  }
  if (tokenizer2.charCodeAt(tokenizer2.findWsEnd(tokenizer2.pos)) === LEFTSQUAREBRACKET) {
    scanSpaces(tokenizer2);
    opts = readTypeRange(tokenizer2);
  }
  tokenizer2.eat(GREATERTHANSIGN);
  return maybeMultiplied(tokenizer2, {
    type: "Type",
    name: name49,
    opts
  });
}
function readKeywordOrFunction(tokenizer2) {
  const name49 = scanWord(tokenizer2);
  if (tokenizer2.charCode() === LEFTPARENTHESIS) {
    tokenizer2.pos++;
    return {
      type: "Function",
      name: name49
    };
  }
  return maybeMultiplied(tokenizer2, {
    type: "Keyword",
    name: name49
  });
}
function regroupTerms(terms, combinators) {
  function createGroup(terms2, combinator2) {
    return {
      type: "Group",
      terms: terms2,
      combinator: combinator2,
      disallowEmpty: false,
      explicit: false
    };
  }
  let combinator;
  combinators = Object.keys(combinators).sort((a, b2) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b2]);
  while (combinators.length > 0) {
    combinator = combinators.shift();
    let i = 0;
    let subgroupStart = 0;
    for (; i < terms.length; i++) {
      const term = terms[i];
      if (term.type === "Combinator") {
        if (term.value === combinator) {
          if (subgroupStart === -1) {
            subgroupStart = i - 1;
          }
          terms.splice(i, 1);
          i--;
        } else {
          if (subgroupStart !== -1 && i - subgroupStart > 1) {
            terms.splice(
              subgroupStart,
              i - subgroupStart,
              createGroup(terms.slice(subgroupStart, i), combinator)
            );
            i = subgroupStart + 1;
          }
          subgroupStart = -1;
        }
      }
    }
    if (subgroupStart !== -1 && combinators.length) {
      terms.splice(
        subgroupStart,
        i - subgroupStart,
        createGroup(terms.slice(subgroupStart, i), combinator)
      );
    }
  }
  return combinator;
}
function readImplicitGroup(tokenizer2) {
  const terms = [];
  const combinators = {};
  let token;
  let prevToken = null;
  let prevTokenPos = tokenizer2.pos;
  while (token = peek(tokenizer2)) {
    if (token.type !== "Spaces") {
      if (token.type === "Combinator") {
        if (prevToken === null || prevToken.type === "Combinator") {
          tokenizer2.pos = prevTokenPos;
          tokenizer2.error("Unexpected combinator");
        }
        combinators[token.value] = true;
      } else if (prevToken !== null && prevToken.type !== "Combinator") {
        combinators[" "] = true;
        terms.push({
          type: "Combinator",
          value: " "
        });
      }
      terms.push(token);
      prevToken = token;
      prevTokenPos = tokenizer2.pos;
    }
  }
  if (prevToken !== null && prevToken.type === "Combinator") {
    tokenizer2.pos -= prevTokenPos;
    tokenizer2.error("Unexpected combinator");
  }
  return {
    type: "Group",
    terms,
    combinator: regroupTerms(terms, combinators) || " ",
    disallowEmpty: false,
    explicit: false
  };
}
function readGroup(tokenizer2) {
  let result;
  tokenizer2.eat(LEFTSQUAREBRACKET);
  result = readImplicitGroup(tokenizer2);
  tokenizer2.eat(RIGHTSQUAREBRACKET);
  result.explicit = true;
  if (tokenizer2.charCode() === EXCLAMATIONMARK2) {
    tokenizer2.pos++;
    result.disallowEmpty = true;
  }
  return result;
}
function peek(tokenizer2) {
  let code2 = tokenizer2.charCode();
  if (code2 < 128 && NAME_CHAR[code2] === 1) {
    return readKeywordOrFunction(tokenizer2);
  }
  switch (code2) {
    case RIGHTSQUAREBRACKET:
      break;
    case LEFTSQUAREBRACKET:
      return maybeMultiplied(tokenizer2, readGroup(tokenizer2));
    case LESSTHANSIGN:
      return tokenizer2.nextCharCode() === APOSTROPHE ? readProperty(tokenizer2) : readType(tokenizer2);
    case VERTICALLINE:
      return {
        type: "Combinator",
        value: tokenizer2.substringToPos(
          tokenizer2.pos + (tokenizer2.nextCharCode() === VERTICALLINE ? 2 : 1)
        )
      };
    case AMPERSAND:
      tokenizer2.pos++;
      tokenizer2.eat(AMPERSAND);
      return {
        type: "Combinator",
        value: "&&"
      };
    case COMMA:
      tokenizer2.pos++;
      return {
        type: "Comma"
      };
    case APOSTROPHE:
      return maybeMultiplied(tokenizer2, {
        type: "String",
        value: scanString(tokenizer2)
      });
    case SPACE2:
    case TAB2:
    case N4:
    case R3:
    case F3:
      return {
        type: "Spaces",
        value: scanSpaces(tokenizer2)
      };
    case COMMERCIALAT:
      code2 = tokenizer2.nextCharCode();
      if (code2 < 128 && NAME_CHAR[code2] === 1) {
        tokenizer2.pos++;
        return {
          type: "AtKeyword",
          name: scanWord(tokenizer2)
        };
      }
      return maybeToken(tokenizer2);
    case ASTERISK:
    case PLUSSIGN4:
    case QUESTIONMARK2:
    case NUMBERSIGN2:
    case EXCLAMATIONMARK2:
      break;
    case LEFTCURLYBRACKET2:
      code2 = tokenizer2.nextCharCode();
      if (code2 < 48 || code2 > 57) {
        return maybeToken(tokenizer2);
      }
      break;
    default:
      return maybeToken(tokenizer2);
  }
}
function parse6(source) {
  const tokenizer2 = new Tokenizer(source);
  const result = readImplicitGroup(tokenizer2);
  if (tokenizer2.pos !== source.length) {
    tokenizer2.error("Unexpected input");
  }
  if (result.terms.length === 1 && result.terms[0].type === "Group") {
    return result.terms[0];
  }
  return result;
}

// node_modules/css-tree/lib/definition-syntax/walk.js
var noop3 = function() {
};
function ensureFunction2(value) {
  return typeof value === "function" ? value : noop3;
}
function walk2(node, options, context) {
  function walk4(node2) {
    enter.call(context, node2);
    switch (node2.type) {
      case "Group":
        node2.terms.forEach(walk4);
        break;
      case "Multiplier":
        walk4(node2.term);
        break;
      case "Type":
      case "Property":
      case "Keyword":
      case "AtKeyword":
      case "Function":
      case "String":
      case "Token":
      case "Comma":
        break;
      default:
        throw new Error("Unknown type: " + node2.type);
    }
    leave.call(context, node2);
  }
  let enter = noop3;
  let leave = noop3;
  if (typeof options === "function") {
    enter = options;
  } else if (options) {
    enter = ensureFunction2(options.enter);
    leave = ensureFunction2(options.leave);
  }
  if (enter === noop3 && leave === noop3) {
    throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
  }
  walk4(node, context);
}

// node_modules/css-tree/lib/lexer/prepare-tokens.js
var astToTokens = {
  decorator(handlers3) {
    const tokens = [];
    let curNode = null;
    return {
      ...handlers3,
      node(node) {
        const tmp = curNode;
        curNode = node;
        handlers3.node.call(this, node);
        curNode = tmp;
      },
      emit(value, type, auto) {
        tokens.push({
          type,
          value,
          node: auto ? null : curNode
        });
      },
      result() {
        return tokens;
      }
    };
  }
};
function stringToTokens(str) {
  const tokens = [];
  tokenize(
    str,
    (type, start, end) => tokens.push({
      type,
      value: str.slice(start, end),
      node: null
    })
  );
  return tokens;
}
function prepare_tokens_default(value, syntax) {
  if (typeof value === "string") {
    return stringToTokens(value);
  }
  return syntax.generate(value, astToTokens);
}

// node_modules/css-tree/lib/lexer/match-graph.js
var MATCH = { type: "Match" };
var MISMATCH = { type: "Mismatch" };
var DISALLOW_EMPTY = { type: "DisallowEmpty" };
var LEFTPARENTHESIS2 = 40;
var RIGHTPARENTHESIS2 = 41;
function createCondition(match, thenBranch, elseBranch) {
  if (thenBranch === MATCH && elseBranch === MISMATCH) {
    return match;
  }
  if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
    return match;
  }
  if (match.type === "If" && match.else === MISMATCH && thenBranch === MATCH) {
    thenBranch = match.then;
    match = match.match;
  }
  return {
    type: "If",
    match,
    then: thenBranch,
    else: elseBranch
  };
}
function isFunctionType(name49) {
  return name49.length > 2 && name49.charCodeAt(name49.length - 2) === LEFTPARENTHESIS2 && name49.charCodeAt(name49.length - 1) === RIGHTPARENTHESIS2;
}
function isEnumCapatible(term) {
  return term.type === "Keyword" || term.type === "AtKeyword" || term.type === "Function" || term.type === "Type" && isFunctionType(term.name);
}
function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
  switch (combinator) {
    case " ": {
      let result = MATCH;
      for (let i = terms.length - 1; i >= 0; i--) {
        const term = terms[i];
        result = createCondition(
          term,
          result,
          MISMATCH
        );
      }
      ;
      return result;
    }
    case "|": {
      let result = MISMATCH;
      let map = null;
      for (let i = terms.length - 1; i >= 0; i--) {
        let term = terms[i];
        if (isEnumCapatible(term)) {
          if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
            map = /* @__PURE__ */ Object.create(null);
            result = createCondition(
              {
                type: "Enum",
                map
              },
              MATCH,
              result
            );
          }
          if (map !== null) {
            const key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
            if (key in map === false) {
              map[key] = term;
              continue;
            }
          }
        }
        map = null;
        result = createCondition(
          term,
          MATCH,
          result
        );
      }
      ;
      return result;
    }
    case "&&": {
      if (terms.length > 5) {
        return {
          type: "MatchOnce",
          terms,
          all: true
        };
      }
      let result = MISMATCH;
      for (let i = terms.length - 1; i >= 0; i--) {
        const term = terms[i];
        let thenClause;
        if (terms.length > 1) {
          thenClause = buildGroupMatchGraph(
            combinator,
            terms.filter(function(newGroupTerm) {
              return newGroupTerm !== term;
            }),
            false
          );
        } else {
          thenClause = MATCH;
        }
        result = createCondition(
          term,
          thenClause,
          result
        );
      }
      ;
      return result;
    }
    case "||": {
      if (terms.length > 5) {
        return {
          type: "MatchOnce",
          terms,
          all: false
        };
      }
      let result = atLeastOneTermMatched ? MATCH : MISMATCH;
      for (let i = terms.length - 1; i >= 0; i--) {
        const term = terms[i];
        let thenClause;
        if (terms.length > 1) {
          thenClause = buildGroupMatchGraph(
            combinator,
            terms.filter(function(newGroupTerm) {
              return newGroupTerm !== term;
            }),
            true
          );
        } else {
          thenClause = MATCH;
        }
        result = createCondition(
          term,
          thenClause,
          result
        );
      }
      ;
      return result;
    }
  }
}
function buildMultiplierMatchGraph(node) {
  let result = MATCH;
  let matchTerm = buildMatchGraphInternal(node.term);
  if (node.max === 0) {
    matchTerm = createCondition(
      matchTerm,
      DISALLOW_EMPTY,
      MISMATCH
    );
    result = createCondition(
      matchTerm,
      null,
      // will be a loop
      MISMATCH
    );
    result.then = createCondition(
      MATCH,
      MATCH,
      result
      // make a loop
    );
    if (node.comma) {
      result.then.else = createCondition(
        { type: "Comma", syntax: node },
        result,
        MISMATCH
      );
    }
  } else {
    for (let i = node.min || 1; i <= node.max; i++) {
      if (node.comma && result !== MATCH) {
        result = createCondition(
          { type: "Comma", syntax: node },
          result,
          MISMATCH
        );
      }
      result = createCondition(
        matchTerm,
        createCondition(
          MATCH,
          MATCH,
          result
        ),
        MISMATCH
      );
    }
  }
  if (node.min === 0) {
    result = createCondition(
      MATCH,
      MATCH,
      result
    );
  } else {
    for (let i = 0; i < node.min - 1; i++) {
      if (node.comma && result !== MATCH) {
        result = createCondition(
          { type: "Comma", syntax: node },
          result,
          MISMATCH
        );
      }
      result = createCondition(
        matchTerm,
        result,
        MISMATCH
      );
    }
  }
  return result;
}
function buildMatchGraphInternal(node) {
  if (typeof node === "function") {
    return {
      type: "Generic",
      fn: node
    };
  }
  switch (node.type) {
    case "Group": {
      let result = buildGroupMatchGraph(
        node.combinator,
        node.terms.map(buildMatchGraphInternal),
        false
      );
      if (node.disallowEmpty) {
        result = createCondition(
          result,
          DISALLOW_EMPTY,
          MISMATCH
        );
      }
      return result;
    }
    case "Multiplier":
      return buildMultiplierMatchGraph(node);
    case "Type":
    case "Property":
      return {
        type: node.type,
        name: node.name,
        syntax: node
      };
    case "Keyword":
      return {
        type: node.type,
        name: node.name.toLowerCase(),
        syntax: node
      };
    case "AtKeyword":
      return {
        type: node.type,
        name: "@" + node.name.toLowerCase(),
        syntax: node
      };
    case "Function":
      return {
        type: node.type,
        name: node.name.toLowerCase() + "(",
        syntax: node
      };
    case "String":
      if (node.value.length === 3) {
        return {
          type: "Token",
          value: node.value.charAt(1),
          syntax: node
        };
      }
      return {
        type: node.type,
        value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, "'"),
        syntax: node
      };
    case "Token":
      return {
        type: node.type,
        value: node.value,
        syntax: node
      };
    case "Comma":
      return {
        type: node.type,
        syntax: node
      };
    default:
      throw new Error("Unknown node type:", node.type);
  }
}
function buildMatchGraph(syntaxTree, ref2) {
  if (typeof syntaxTree === "string") {
    syntaxTree = parse6(syntaxTree);
  }
  return {
    type: "MatchGraph",
    match: buildMatchGraphInternal(syntaxTree),
    syntax: ref2 || null,
    source: syntaxTree
  };
}

// node_modules/css-tree/lib/lexer/match.js
var { hasOwnProperty: hasOwnProperty4 } = Object.prototype;
var STUB = 0;
var TOKEN = 1;
var OPEN_SYNTAX = 2;
var CLOSE_SYNTAX = 3;
var EXIT_REASON_MATCH = "Match";
var EXIT_REASON_MISMATCH = "Mismatch";
var EXIT_REASON_ITERATION_LIMIT = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
var ITERATION_LIMIT = 15e3;
var totalIterationCount = 0;
function reverseList(list2) {
  let prev = null;
  let next = null;
  let item = list2;
  while (item !== null) {
    next = item.prev;
    item.prev = prev;
    prev = item;
    item = next;
  }
  return prev;
}
function areStringsEqualCaseInsensitive(testStr, referenceStr) {
  if (testStr.length !== referenceStr.length) {
    return false;
  }
  for (let i = 0; i < testStr.length; i++) {
    const referenceCode = referenceStr.charCodeAt(i);
    let testCode = testStr.charCodeAt(i);
    if (testCode >= 65 && testCode <= 90) {
      testCode = testCode | 32;
    }
    if (testCode !== referenceCode) {
      return false;
    }
  }
  return true;
}
function isContextEdgeDelim(token) {
  if (token.type !== Delim) {
    return false;
  }
  return token.value !== "?";
}
function isCommaContextStart(token) {
  if (token === null) {
    return true;
  }
  return token.type === Comma || token.type === Function2 || token.type === LeftParenthesis || token.type === LeftSquareBracket || token.type === LeftCurlyBracket || isContextEdgeDelim(token);
}
function isCommaContextEnd(token) {
  if (token === null) {
    return true;
  }
  return token.type === RightParenthesis || token.type === RightSquareBracket || token.type === RightCurlyBracket || token.type === Delim && token.value === "/";
}
function internalMatch(tokens, state, syntaxes) {
  function moveToNextToken() {
    do {
      tokenIndex++;
      token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
    } while (token !== null && (token.type === WhiteSpace || token.type === Comment));
  }
  function getNextToken(offset2) {
    const nextIndex2 = tokenIndex + offset2;
    return nextIndex2 < tokens.length ? tokens[nextIndex2] : null;
  }
  function stateSnapshotFromSyntax(nextState, prev) {
    return {
      nextState,
      matchStack,
      syntaxStack,
      thenStack,
      tokenIndex,
      prev
    };
  }
  function pushThenStack(nextState) {
    thenStack = {
      nextState,
      matchStack,
      syntaxStack,
      prev: thenStack
    };
  }
  function pushElseStack(nextState) {
    elseStack = stateSnapshotFromSyntax(nextState, elseStack);
  }
  function addTokenToMatch() {
    matchStack = {
      type: TOKEN,
      syntax: state.syntax,
      token,
      prev: matchStack
    };
    moveToNextToken();
    syntaxStash = null;
    if (tokenIndex > longestMatch) {
      longestMatch = tokenIndex;
    }
  }
  function openSyntax() {
    syntaxStack = {
      syntax: state.syntax,
      opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
      prev: syntaxStack
    };
    matchStack = {
      type: OPEN_SYNTAX,
      syntax: state.syntax,
      token: matchStack.token,
      prev: matchStack
    };
  }
  function closeSyntax() {
    if (matchStack.type === OPEN_SYNTAX) {
      matchStack = matchStack.prev;
    } else {
      matchStack = {
        type: CLOSE_SYNTAX,
        syntax: syntaxStack.syntax,
        token: matchStack.token,
        prev: matchStack
      };
    }
    syntaxStack = syntaxStack.prev;
  }
  let syntaxStack = null;
  let thenStack = null;
  let elseStack = null;
  let syntaxStash = null;
  let iterationCount = 0;
  let exitReason = null;
  let token = null;
  let tokenIndex = -1;
  let longestMatch = 0;
  let matchStack = {
    type: STUB,
    syntax: null,
    token: null,
    prev: null
  };
  moveToNextToken();
  while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
    switch (state.type) {
      case "Match":
        if (thenStack === null) {
          if (token !== null) {
            if (tokenIndex !== tokens.length - 1 || token.value !== "\\0" && token.value !== "\\9") {
              state = MISMATCH;
              break;
            }
          }
          exitReason = EXIT_REASON_MATCH;
          break;
        }
        state = thenStack.nextState;
        if (state === DISALLOW_EMPTY) {
          if (thenStack.matchStack === matchStack) {
            state = MISMATCH;
            break;
          } else {
            state = MATCH;
          }
        }
        while (thenStack.syntaxStack !== syntaxStack) {
          closeSyntax();
        }
        thenStack = thenStack.prev;
        break;
      case "Mismatch":
        if (syntaxStash !== null && syntaxStash !== false) {
          if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
            elseStack = syntaxStash;
            syntaxStash = false;
          }
        } else if (elseStack === null) {
          exitReason = EXIT_REASON_MISMATCH;
          break;
        }
        state = elseStack.nextState;
        thenStack = elseStack.thenStack;
        syntaxStack = elseStack.syntaxStack;
        matchStack = elseStack.matchStack;
        tokenIndex = elseStack.tokenIndex;
        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
        elseStack = elseStack.prev;
        break;
      case "MatchGraph":
        state = state.match;
        break;
      case "If":
        if (state.else !== MISMATCH) {
          pushElseStack(state.else);
        }
        if (state.then !== MATCH) {
          pushThenStack(state.then);
        }
        state = state.match;
        break;
      case "MatchOnce":
        state = {
          type: "MatchOnceBuffer",
          syntax: state,
          index: 0,
          mask: 0
        };
        break;
      case "MatchOnceBuffer": {
        const terms = state.syntax.terms;
        if (state.index === terms.length) {
          if (state.mask === 0 || state.syntax.all) {
            state = MISMATCH;
            break;
          }
          state = MATCH;
          break;
        }
        if (state.mask === (1 << terms.length) - 1) {
          state = MATCH;
          break;
        }
        for (; state.index < terms.length; state.index++) {
          const matchFlag = 1 << state.index;
          if ((state.mask & matchFlag) === 0) {
            pushElseStack(state);
            pushThenStack({
              type: "AddMatchOnce",
              syntax: state.syntax,
              mask: state.mask | matchFlag
            });
            state = terms[state.index++];
            break;
          }
        }
        break;
      }
      case "AddMatchOnce":
        state = {
          type: "MatchOnceBuffer",
          syntax: state.syntax,
          index: 0,
          mask: state.mask
        };
        break;
      case "Enum":
        if (token !== null) {
          let name49 = token.value.toLowerCase();
          if (name49.indexOf("\\") !== -1) {
            name49 = name49.replace(/\\[09].*$/, "");
          }
          if (hasOwnProperty4.call(state.map, name49)) {
            state = state.map[name49];
            break;
          }
        }
        state = MISMATCH;
        break;
      case "Generic": {
        const opts = syntaxStack !== null ? syntaxStack.opts : null;
        const lastTokenIndex2 = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));
        if (!isNaN(lastTokenIndex2) && lastTokenIndex2 > tokenIndex) {
          while (tokenIndex < lastTokenIndex2) {
            addTokenToMatch();
          }
          state = MATCH;
        } else {
          state = MISMATCH;
        }
        break;
      }
      case "Type":
      case "Property": {
        const syntaxDict = state.type === "Type" ? "types" : "properties";
        const dictSyntax = hasOwnProperty4.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;
        if (!dictSyntax || !dictSyntax.match) {
          throw new Error(
            "Bad syntax reference: " + (state.type === "Type" ? "<" + state.name + ">" : "<'" + state.name + "'>")
          );
        }
        if (syntaxStash !== false && token !== null && state.type === "Type") {
          const lowPriorityMatching = (
            // https://drafts.csswg.org/css-values-4/#custom-idents
            // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
            // can only claim the keyword if no other unfulfilled production can claim it.
            state.name === "custom-ident" && token.type === Ident || // https://drafts.csswg.org/css-values-4/#lengths
            // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
            // it must parse as a <number>
            state.name === "length" && token.value === "0"
          );
          if (lowPriorityMatching) {
            if (syntaxStash === null) {
              syntaxStash = stateSnapshotFromSyntax(state, elseStack);
            }
            state = MISMATCH;
            break;
          }
        }
        openSyntax();
        state = dictSyntax.match;
        break;
      }
      case "Keyword": {
        const name49 = state.name;
        if (token !== null) {
          let keywordName = token.value;
          if (keywordName.indexOf("\\") !== -1) {
            keywordName = keywordName.replace(/\\[09].*$/, "");
          }
          if (areStringsEqualCaseInsensitive(keywordName, name49)) {
            addTokenToMatch();
            state = MATCH;
            break;
          }
        }
        state = MISMATCH;
        break;
      }
      case "AtKeyword":
      case "Function":
        if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
          addTokenToMatch();
          state = MATCH;
          break;
        }
        state = MISMATCH;
        break;
      case "Token":
        if (token !== null && token.value === state.value) {
          addTokenToMatch();
          state = MATCH;
          break;
        }
        state = MISMATCH;
        break;
      case "Comma":
        if (token !== null && token.type === Comma) {
          if (isCommaContextStart(matchStack.token)) {
            state = MISMATCH;
          } else {
            addTokenToMatch();
            state = isCommaContextEnd(token) ? MISMATCH : MATCH;
          }
        } else {
          state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
        }
        break;
      case "String":
        let string = "";
        let lastTokenIndex = tokenIndex;
        for (; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
          string += tokens[lastTokenIndex].value;
        }
        if (areStringsEqualCaseInsensitive(string, state.value)) {
          while (tokenIndex < lastTokenIndex) {
            addTokenToMatch();
          }
          state = MATCH;
        } else {
          state = MISMATCH;
        }
        break;
      default:
        throw new Error("Unknown node type: " + state.type);
    }
  }
  totalIterationCount += iterationCount;
  switch (exitReason) {
    case null:
      console.warn("[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations");
      exitReason = EXIT_REASON_ITERATION_LIMIT;
      matchStack = null;
      break;
    case EXIT_REASON_MATCH:
      while (syntaxStack !== null) {
        closeSyntax();
      }
      break;
    default:
      matchStack = null;
  }
  return {
    tokens,
    reason: exitReason,
    iterations: iterationCount,
    match: matchStack,
    longestMatch
  };
}
function matchAsTree(tokens, matchGraph, syntaxes) {
  const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});
  if (matchResult.match === null) {
    return matchResult;
  }
  let item = matchResult.match;
  let host = matchResult.match = {
    syntax: matchGraph.syntax || null,
    match: []
  };
  const hostStack = [host];
  item = reverseList(item).prev;
  while (item !== null) {
    switch (item.type) {
      case OPEN_SYNTAX:
        host.match.push(host = {
          syntax: item.syntax,
          match: []
        });
        hostStack.push(host);
        break;
      case CLOSE_SYNTAX:
        hostStack.pop();
        host = hostStack[hostStack.length - 1];
        break;
      default:
        host.match.push({
          syntax: item.syntax || null,
          token: item.token.value,
          node: item.token.node
        });
    }
    item = item.prev;
  }
  return matchResult;
}

// node_modules/css-tree/lib/lexer/trace.js
var trace_exports = {};
__export(trace_exports, {
  getTrace: () => getTrace,
  isKeyword: () => isKeyword,
  isProperty: () => isProperty,
  isType: () => isType
});
function getTrace(node) {
  function shouldPutToTrace(syntax) {
    if (syntax === null) {
      return false;
    }
    return syntax.type === "Type" || syntax.type === "Property" || syntax.type === "Keyword";
  }
  function hasMatch(matchNode) {
    if (Array.isArray(matchNode.match)) {
      for (let i = 0; i < matchNode.match.length; i++) {
        if (hasMatch(matchNode.match[i])) {
          if (shouldPutToTrace(matchNode.syntax)) {
            result.unshift(matchNode.syntax);
          }
          return true;
        }
      }
    } else if (matchNode.node === node) {
      result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];
      return true;
    }
    return false;
  }
  let result = null;
  if (this.matched !== null) {
    hasMatch(this.matched);
  }
  return result;
}
function isType(node, type) {
  return testNode(this, node, (match) => match.type === "Type" && match.name === type);
}
function isProperty(node, property2) {
  return testNode(this, node, (match) => match.type === "Property" && match.name === property2);
}
function isKeyword(node) {
  return testNode(this, node, (match) => match.type === "Keyword");
}
function testNode(match, node, fn) {
  const trace = getTrace.call(match, node);
  if (trace === null) {
    return false;
  }
  return trace.some(fn);
}

// node_modules/css-tree/lib/lexer/search.js
function getFirstMatchNode(matchNode) {
  if ("node" in matchNode) {
    return matchNode.node;
  }
  return getFirstMatchNode(matchNode.match[0]);
}
function getLastMatchNode(matchNode) {
  if ("node" in matchNode) {
    return matchNode.node;
  }
  return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
}
function matchFragments(lexer2, ast, match, type, name49) {
  function findFragments(matchNode) {
    if (matchNode.syntax !== null && matchNode.syntax.type === type && matchNode.syntax.name === name49) {
      const start = getFirstMatchNode(matchNode);
      const end = getLastMatchNode(matchNode);
      lexer2.syntax.walk(ast, function(node, item, list2) {
        if (node === start) {
          const nodes = new List();
          do {
            nodes.appendData(item.data);
            if (item.data === end) {
              break;
            }
            item = item.next;
          } while (item !== null);
          fragments.push({
            parent: list2,
            nodes
          });
        }
      });
    }
    if (Array.isArray(matchNode.match)) {
      matchNode.match.forEach(findFragments);
    }
  }
  const fragments = [];
  if (match.matched !== null) {
    findFragments(match.matched);
  }
  return fragments;
}

// node_modules/css-tree/lib/lexer/structure.js
var { hasOwnProperty: hasOwnProperty5 } = Object.prototype;
function isValidNumber(value) {
  return typeof value === "number" && isFinite(value) && Math.floor(value) === value && value >= 0;
}
function isValidLocation(loc) {
  return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
}
function createNodeStructureChecker(type, fields) {
  return function checkNode(node, warn) {
    if (!node || node.constructor !== Object) {
      return warn(node, "Type of node should be an Object");
    }
    for (let key in node) {
      let valid = true;
      if (hasOwnProperty5.call(node, key) === false) {
        continue;
      }
      if (key === "type") {
        if (node.type !== type) {
          warn(node, "Wrong node type `" + node.type + "`, expected `" + type + "`");
        }
      } else if (key === "loc") {
        if (node.loc === null) {
          continue;
        } else if (node.loc && node.loc.constructor === Object) {
          if (typeof node.loc.source !== "string") {
            key += ".source";
          } else if (!isValidLocation(node.loc.start)) {
            key += ".start";
          } else if (!isValidLocation(node.loc.end)) {
            key += ".end";
          } else {
            continue;
          }
        }
        valid = false;
      } else if (fields.hasOwnProperty(key)) {
        valid = false;
        for (let i = 0; !valid && i < fields[key].length; i++) {
          const fieldType = fields[key][i];
          switch (fieldType) {
            case String:
              valid = typeof node[key] === "string";
              break;
            case Boolean:
              valid = typeof node[key] === "boolean";
              break;
            case null:
              valid = node[key] === null;
              break;
            default:
              if (typeof fieldType === "string") {
                valid = node[key] && node[key].type === fieldType;
              } else if (Array.isArray(fieldType)) {
                valid = node[key] instanceof List;
              }
          }
        }
      } else {
        warn(node, "Unknown field `" + key + "` for " + type + " node type");
      }
      if (!valid) {
        warn(node, "Bad value for `" + type + "." + key + "`");
      }
    }
    for (const key in fields) {
      if (hasOwnProperty5.call(fields, key) && hasOwnProperty5.call(node, key) === false) {
        warn(node, "Field `" + type + "." + key + "` is missed");
      }
    }
  };
}
function processStructure(name49, nodeType) {
  const structure49 = nodeType.structure;
  const fields = {
    type: String,
    loc: true
  };
  const docs = {
    type: '"' + name49 + '"'
  };
  for (const key in structure49) {
    if (hasOwnProperty5.call(structure49, key) === false) {
      continue;
    }
    const docsTypes = [];
    const fieldTypes = fields[key] = Array.isArray(structure49[key]) ? structure49[key].slice() : [structure49[key]];
    for (let i = 0; i < fieldTypes.length; i++) {
      const fieldType = fieldTypes[i];
      if (fieldType === String || fieldType === Boolean) {
        docsTypes.push(fieldType.name);
      } else if (fieldType === null) {
        docsTypes.push("null");
      } else if (typeof fieldType === "string") {
        docsTypes.push("<" + fieldType + ">");
      } else if (Array.isArray(fieldType)) {
        docsTypes.push("List");
      } else {
        throw new Error("Wrong value `" + fieldType + "` in `" + name49 + "." + key + "` structure definition");
      }
    }
    docs[key] = docsTypes.join(" | ");
  }
  return {
    docs,
    check: createNodeStructureChecker(name49, fields)
  };
}
function getStructureFromConfig(config) {
  const structure49 = {};
  if (config.node) {
    for (const name49 in config.node) {
      if (hasOwnProperty5.call(config.node, name49)) {
        const nodeType = config.node[name49];
        if (nodeType.structure) {
          structure49[name49] = processStructure(name49, nodeType);
        } else {
          throw new Error("Missed `structure` field in `" + name49 + "` node type definition");
        }
      }
    }
  }
  return structure49;
}

// node_modules/css-tree/lib/lexer/Lexer.js
var cssWideKeywordsSyntax = buildMatchGraph(cssWideKeywords.join(" | "));
function dumpMapSyntax(map, compact, syntaxAsAst) {
  const result = {};
  for (const name49 in map) {
    if (map[name49].syntax) {
      result[name49] = syntaxAsAst ? map[name49].syntax : generate(map[name49].syntax, { compact });
    }
  }
  return result;
}
function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
  const result = {};
  for (const [name49, atrule] of Object.entries(map)) {
    result[name49] = {
      prelude: atrule.prelude && (syntaxAsAst ? atrule.prelude.syntax : generate(atrule.prelude.syntax, { compact })),
      descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
    };
  }
  return result;
}
function valueHasVar(tokens) {
  for (let i = 0; i < tokens.length; i++) {
    if (tokens[i].value.toLowerCase() === "var(") {
      return true;
    }
  }
  return false;
}
function buildMatchResult(matched, error2, iterations) {
  return {
    matched,
    iterations,
    error: error2,
    ...trace_exports
  };
}
function matchSyntax(lexer2, syntax, value, useCssWideKeywords) {
  const tokens = prepare_tokens_default(value, lexer2.syntax);
  let result;
  if (valueHasVar(tokens)) {
    return buildMatchResult(null, new Error("Matching for a tree with var() is not supported"));
  }
  if (useCssWideKeywords) {
    result = matchAsTree(tokens, lexer2.cssWideKeywordsSyntax, lexer2);
  }
  if (!useCssWideKeywords || !result.match) {
    result = matchAsTree(tokens, syntax.match, lexer2);
    if (!result.match) {
      return buildMatchResult(
        null,
        new SyntaxMatchError(result.reason, syntax.syntax, value, result),
        result.iterations
      );
    }
  }
  return buildMatchResult(result.match, null, result.iterations);
}
var Lexer = class {
  constructor(config, syntax, structure49) {
    this.cssWideKeywordsSyntax = cssWideKeywordsSyntax;
    this.syntax = syntax;
    this.generic = false;
    this.units = { ...units_exports };
    this.atrules = /* @__PURE__ */ Object.create(null);
    this.properties = /* @__PURE__ */ Object.create(null);
    this.types = /* @__PURE__ */ Object.create(null);
    this.structure = structure49 || getStructureFromConfig(config);
    if (config) {
      if (config.units) {
        for (const group of Object.keys(units_exports)) {
          if (Array.isArray(config.units[group])) {
            this.units[group] = config.units[group];
          }
        }
      }
      if (config.types) {
        for (const name49 in config.types) {
          this.addType_(name49, config.types[name49]);
        }
      }
      if (config.generic) {
        this.generic = true;
        for (const [name49, value] of Object.entries(createGenericTypes(this.units))) {
          this.addType_(name49, value);
        }
      }
      if (config.atrules) {
        for (const name49 in config.atrules) {
          this.addAtrule_(name49, config.atrules[name49]);
        }
      }
      if (config.properties) {
        for (const name49 in config.properties) {
          this.addProperty_(name49, config.properties[name49]);
        }
      }
    }
  }
  checkStructure(ast) {
    function collectWarning(node, message) {
      warns.push({ node, message });
    }
    const structure49 = this.structure;
    const warns = [];
    this.syntax.walk(ast, function(node) {
      if (structure49.hasOwnProperty(node.type)) {
        structure49[node.type].check(node, collectWarning);
      } else {
        collectWarning(node, "Unknown node type `" + node.type + "`");
      }
    });
    return warns.length ? warns : false;
  }
  createDescriptor(syntax, type, name49, parent = null) {
    const ref2 = {
      type,
      name: name49
    };
    const descriptor = {
      type,
      name: name49,
      parent,
      serializable: typeof syntax === "string" || syntax && typeof syntax.type === "string",
      syntax: null,
      match: null
    };
    if (typeof syntax === "function") {
      descriptor.match = buildMatchGraph(syntax, ref2);
    } else {
      if (typeof syntax === "string") {
        Object.defineProperty(descriptor, "syntax", {
          get() {
            Object.defineProperty(descriptor, "syntax", {
              value: parse6(syntax)
            });
            return descriptor.syntax;
          }
        });
      } else {
        descriptor.syntax = syntax;
      }
      Object.defineProperty(descriptor, "match", {
        get() {
          Object.defineProperty(descriptor, "match", {
            value: buildMatchGraph(descriptor.syntax, ref2)
          });
          return descriptor.match;
        }
      });
    }
    return descriptor;
  }
  addAtrule_(name49, syntax) {
    if (!syntax) {
      return;
    }
    this.atrules[name49] = {
      type: "Atrule",
      name: name49,
      prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, "AtrulePrelude", name49) : null,
      descriptors: syntax.descriptors ? Object.keys(syntax.descriptors).reduce(
        (map, descName) => {
          map[descName] = this.createDescriptor(syntax.descriptors[descName], "AtruleDescriptor", descName, name49);
          return map;
        },
        /* @__PURE__ */ Object.create(null)
      ) : null
    };
  }
  addProperty_(name49, syntax) {
    if (!syntax) {
      return;
    }
    this.properties[name49] = this.createDescriptor(syntax, "Property", name49);
  }
  addType_(name49, syntax) {
    if (!syntax) {
      return;
    }
    this.types[name49] = this.createDescriptor(syntax, "Type", name49);
  }
  checkAtruleName(atruleName) {
    if (!this.getAtrule(atruleName)) {
      return new SyntaxReferenceError("Unknown at-rule", "@" + atruleName);
    }
  }
  checkAtrulePrelude(atruleName, prelude) {
    const error2 = this.checkAtruleName(atruleName);
    if (error2) {
      return error2;
    }
    const atrule = this.getAtrule(atruleName);
    if (!atrule.prelude && prelude) {
      return new SyntaxError("At-rule `@" + atruleName + "` should not contain a prelude");
    }
    if (atrule.prelude && !prelude) {
      if (!matchSyntax(this, atrule.prelude, "", false).matched) {
        return new SyntaxError("At-rule `@" + atruleName + "` should contain a prelude");
      }
    }
  }
  checkAtruleDescriptorName(atruleName, descriptorName) {
    const error2 = this.checkAtruleName(atruleName);
    if (error2) {
      return error2;
    }
    const atrule = this.getAtrule(atruleName);
    const descriptor = keyword(descriptorName);
    if (!atrule.descriptors) {
      return new SyntaxError("At-rule `@" + atruleName + "` has no known descriptors");
    }
    if (!atrule.descriptors[descriptor.name] && !atrule.descriptors[descriptor.basename]) {
      return new SyntaxReferenceError("Unknown at-rule descriptor", descriptorName);
    }
  }
  checkPropertyName(propertyName) {
    if (!this.getProperty(propertyName)) {
      return new SyntaxReferenceError("Unknown property", propertyName);
    }
  }
  matchAtrulePrelude(atruleName, prelude) {
    const error2 = this.checkAtrulePrelude(atruleName, prelude);
    if (error2) {
      return buildMatchResult(null, error2);
    }
    const atrule = this.getAtrule(atruleName);
    if (!atrule.prelude) {
      return buildMatchResult(null, null);
    }
    return matchSyntax(this, atrule.prelude, prelude || "", false);
  }
  matchAtruleDescriptor(atruleName, descriptorName, value) {
    const error2 = this.checkAtruleDescriptorName(atruleName, descriptorName);
    if (error2) {
      return buildMatchResult(null, error2);
    }
    const atrule = this.getAtrule(atruleName);
    const descriptor = keyword(descriptorName);
    return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
  }
  matchDeclaration(node) {
    if (node.type !== "Declaration") {
      return buildMatchResult(null, new Error("Not a Declaration node"));
    }
    return this.matchProperty(node.property, node.value);
  }
  matchProperty(propertyName, value) {
    if (property(propertyName).custom) {
      return buildMatchResult(null, new Error("Lexer matching doesn't applicable for custom properties"));
    }
    const error2 = this.checkPropertyName(propertyName);
    if (error2) {
      return buildMatchResult(null, error2);
    }
    return matchSyntax(this, this.getProperty(propertyName), value, true);
  }
  matchType(typeName, value) {
    const typeSyntax = this.getType(typeName);
    if (!typeSyntax) {
      return buildMatchResult(null, new SyntaxReferenceError("Unknown type", typeName));
    }
    return matchSyntax(this, typeSyntax, value, false);
  }
  match(syntax, value) {
    if (typeof syntax !== "string" && (!syntax || !syntax.type)) {
      return buildMatchResult(null, new SyntaxReferenceError("Bad syntax"));
    }
    if (typeof syntax === "string" || !syntax.match) {
      syntax = this.createDescriptor(syntax, "Type", "anonymous");
    }
    return matchSyntax(this, syntax, value, false);
  }
  findValueFragments(propertyName, value, type, name49) {
    return matchFragments(this, value, this.matchProperty(propertyName, value), type, name49);
  }
  findDeclarationValueFragments(declaration, type, name49) {
    return matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name49);
  }
  findAllFragments(ast, type, name49) {
    const result = [];
    this.syntax.walk(ast, {
      visit: "Declaration",
      enter: (declaration) => {
        result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name49));
      }
    });
    return result;
  }
  getAtrule(atruleName, fallbackBasename = true) {
    const atrule = keyword(atruleName);
    const atruleEntry = atrule.vendor && fallbackBasename ? this.atrules[atrule.name] || this.atrules[atrule.basename] : this.atrules[atrule.name];
    return atruleEntry || null;
  }
  getAtrulePrelude(atruleName, fallbackBasename = true) {
    const atrule = this.getAtrule(atruleName, fallbackBasename);
    return atrule && atrule.prelude || null;
  }
  getAtruleDescriptor(atruleName, name49) {
    return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name49] || null : null;
  }
  getProperty(propertyName, fallbackBasename = true) {
    const property2 = property(propertyName);
    const propertyEntry = property2.vendor && fallbackBasename ? this.properties[property2.name] || this.properties[property2.basename] : this.properties[property2.name];
    return propertyEntry || null;
  }
  getType(name49) {
    return hasOwnProperty.call(this.types, name49) ? this.types[name49] : null;
  }
  validate() {
    function validate(syntax, name49, broken, descriptor) {
      if (broken.has(name49)) {
        return broken.get(name49);
      }
      broken.set(name49, false);
      if (descriptor.syntax !== null) {
        walk2(descriptor.syntax, function(node) {
          if (node.type !== "Type" && node.type !== "Property") {
            return;
          }
          const map = node.type === "Type" ? syntax.types : syntax.properties;
          const brokenMap = node.type === "Type" ? brokenTypes : brokenProperties;
          if (!hasOwnProperty.call(map, node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
            broken.set(name49, true);
          }
        }, this);
      }
    }
    let brokenTypes = /* @__PURE__ */ new Map();
    let brokenProperties = /* @__PURE__ */ new Map();
    for (const key in this.types) {
      validate(this, key, brokenTypes, this.types[key]);
    }
    for (const key in this.properties) {
      validate(this, key, brokenProperties, this.properties[key]);
    }
    brokenTypes = [...brokenTypes.keys()].filter((name49) => brokenTypes.get(name49));
    brokenProperties = [...brokenProperties.keys()].filter((name49) => brokenProperties.get(name49));
    if (brokenTypes.length || brokenProperties.length) {
      return {
        types: brokenTypes,
        properties: brokenProperties
      };
    }
    return null;
  }
  dump(syntaxAsAst, pretty) {
    return {
      generic: this.generic,
      units: this.units,
      types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
      properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
      atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
    };
  }
  toString() {
    return JSON.stringify(this.dump());
  }
};

// node_modules/css-tree/lib/syntax/config/mix.js
function appendOrSet(a, b2) {
  if (typeof b2 === "string" && /^\s*\|/.test(b2)) {
    return typeof a === "string" ? a + b2 : b2.replace(/^\s*\|\s*/, "");
  }
  return b2 || null;
}
function sliceProps(obj, props) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    if (value) {
      result[key] = {};
      for (const prop of Object.keys(value)) {
        if (props.includes(prop)) {
          result[key][prop] = value[prop];
        }
      }
    }
  }
  return result;
}
function mix(dest, src) {
  const result = { ...dest };
  for (const [prop, value] of Object.entries(src)) {
    switch (prop) {
      case "generic":
        result[prop] = Boolean(value);
        break;
      case "units":
        result[prop] = { ...dest[prop] };
        for (const [name49, patch] of Object.entries(value)) {
          result[prop][name49] = Array.isArray(patch) ? patch : [];
        }
        break;
      case "atrules":
        result[prop] = { ...dest[prop] };
        for (const [name49, atrule] of Object.entries(value)) {
          const exists = result[prop][name49] || {};
          const current2 = result[prop][name49] = {
            prelude: exists.prelude || null,
            descriptors: {
              ...exists.descriptors
            }
          };
          if (!atrule) {
            continue;
          }
          current2.prelude = atrule.prelude ? appendOrSet(current2.prelude, atrule.prelude) : current2.prelude || null;
          for (const [descriptorName, descriptorValue] of Object.entries(atrule.descriptors || {})) {
            current2.descriptors[descriptorName] = descriptorValue ? appendOrSet(current2.descriptors[descriptorName], descriptorValue) : null;
          }
          if (!Object.keys(current2.descriptors).length) {
            current2.descriptors = null;
          }
        }
        break;
      case "types":
      case "properties":
        result[prop] = { ...dest[prop] };
        for (const [name49, syntax] of Object.entries(value)) {
          result[prop][name49] = appendOrSet(result[prop][name49], syntax);
        }
        break;
      case "scope":
        result[prop] = { ...dest[prop] };
        for (const [name49, props] of Object.entries(value)) {
          result[prop][name49] = { ...result[prop][name49], ...props };
        }
        break;
      case "parseContext":
        result[prop] = {
          ...dest[prop],
          ...value
        };
        break;
      case "atrule":
      case "pseudo":
        result[prop] = {
          ...dest[prop],
          ...sliceProps(value, ["parse"])
        };
        break;
      case "node":
        result[prop] = {
          ...dest[prop],
          ...sliceProps(value, ["name", "structure", "parse", "generate", "walkContext"])
        };
        break;
    }
  }
  return result;
}

// node_modules/css-tree/lib/syntax/create.js
function createSyntax(config) {
  const parse58 = createParser(config);
  const walk4 = createWalker(config);
  const generate51 = createGenerator(config);
  const { fromPlainObject: fromPlainObject2, toPlainObject: toPlainObject2 } = createConvertor(walk4);
  const syntax = {
    lexer: null,
    createLexer: (config2) => new Lexer(config2, syntax, syntax.lexer.structure),
    tokenize,
    parse: parse58,
    generate: generate51,
    walk: walk4,
    find: walk4.find,
    findLast: walk4.findLast,
    findAll: walk4.findAll,
    fromPlainObject: fromPlainObject2,
    toPlainObject: toPlainObject2,
    fork(extension) {
      const base = mix({}, config);
      return createSyntax(
        typeof extension === "function" ? extension(base, Object.assign) : mix(base, extension)
      );
    }
  };
  syntax.lexer = new Lexer({
    generic: true,
    units: config.units,
    types: config.types,
    atrules: config.atrules,
    properties: config.properties,
    node: config.node
  }, syntax);
  return syntax;
}
var create_default = (config) => createSyntax(mix({}, config));

// node_modules/css-tree/dist/data.js
var data_default = {
  "generic": true,
  "units": {
    "angle": [
      "deg",
      "grad",
      "rad",
      "turn"
    ],
    "decibel": [
      "db"
    ],
    "flex": [
      "fr"
    ],
    "frequency": [
      "hz",
      "khz"
    ],
    "length": [
      "cm",
      "mm",
      "q",
      "in",
      "pt",
      "pc",
      "px",
      "em",
      "rem",
      "ex",
      "rex",
      "cap",
      "rcap",
      "ch",
      "rch",
      "ic",
      "ric",
      "lh",
      "rlh",
      "vw",
      "svw",
      "lvw",
      "dvw",
      "vh",
      "svh",
      "lvh",
      "dvh",
      "vi",
      "svi",
      "lvi",
      "dvi",
      "vb",
      "svb",
      "lvb",
      "dvb",
      "vmin",
      "svmin",
      "lvmin",
      "dvmin",
      "vmax",
      "svmax",
      "lvmax",
      "dvmax",
      "cqw",
      "cqh",
      "cqi",
      "cqb",
      "cqmin",
      "cqmax"
    ],
    "resolution": [
      "dpi",
      "dpcm",
      "dppx",
      "x"
    ],
    "semitones": [
      "st"
    ],
    "time": [
      "s",
      "ms"
    ]
  },
  "types": {
    "abs()": "abs( <calc-sum> )",
    "absolute-size": "xx-small|x-small|small|medium|large|x-large|xx-large|xxx-large",
    "acos()": "acos( <calc-sum> )",
    "alpha-value": "<number>|<percentage>",
    "angle-percentage": "<angle>|<percentage>",
    "angular-color-hint": "<angle-percentage>",
    "angular-color-stop": "<color>&&<color-stop-angle>?",
    "angular-color-stop-list": "[<angular-color-stop> [, <angular-color-hint>]?]# , <angular-color-stop>",
    "animateable-feature": "scroll-position|contents|<custom-ident>",
    "asin()": "asin( <calc-sum> )",
    "atan()": "atan( <calc-sum> )",
    "atan2()": "atan2( <calc-sum> , <calc-sum> )",
    "attachment": "scroll|fixed|local",
    "attr()": "attr( <attr-name> <type-or-unit>? [, <attr-fallback>]? )",
    "attr-matcher": "['~'|'|'|'^'|'$'|'*']? '='",
    "attr-modifier": "i|s",
    "attribute-selector": "'[' <wq-name> ']'|'[' <wq-name> <attr-matcher> [<string-token>|<ident-token>] <attr-modifier>? ']'",
    "auto-repeat": "repeat( [auto-fill|auto-fit] , [<line-names>? <fixed-size>]+ <line-names>? )",
    "auto-track-list": "[<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>? <auto-repeat> [<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>?",
    "axis": "block|inline|vertical|horizontal",
    "baseline-position": "[first|last]? baseline",
    "basic-shape": "<inset()>|<circle()>|<ellipse()>|<polygon()>|<path()>",
    "bg-image": "none|<image>",
    "bg-layer": "<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
    "bg-position": "[[left|center|right|top|bottom|<length-percentage>]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]|[center|[left|right] <length-percentage>?]&&[center|[top|bottom] <length-percentage>?]]",
    "bg-size": "[<length-percentage>|auto]{1,2}|cover|contain",
    "blur()": "blur( <length> )",
    "blend-mode": "normal|multiply|screen|overlay|darken|lighten|color-dodge|color-burn|hard-light|soft-light|difference|exclusion|hue|saturation|color|luminosity",
    "box": "border-box|padding-box|content-box",
    "brightness()": "brightness( <number-percentage> )",
    "calc()": "calc( <calc-sum> )",
    "calc-sum": "<calc-product> [['+'|'-'] <calc-product>]*",
    "calc-product": "<calc-value> ['*' <calc-value>|'/' <number>]*",
    "calc-value": "<number>|<dimension>|<percentage>|<calc-constant>|( <calc-sum> )",
    "calc-constant": "e|pi|infinity|-infinity|NaN",
    "cf-final-image": "<image>|<color>",
    "cf-mixing-image": "<percentage>?&&<image>",
    "circle()": "circle( [<shape-radius>]? [at <position>]? )",
    "clamp()": "clamp( <calc-sum>#{3} )",
    "class-selector": "'.' <ident-token>",
    "clip-source": "<url>",
    "color": "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<hex-color>|<named-color>|currentcolor|<deprecated-system-color>",
    "color-stop": "<color-stop-length>|<color-stop-angle>",
    "color-stop-angle": "<angle-percentage>{1,2}",
    "color-stop-length": "<length-percentage>{1,2}",
    "color-stop-list": "[<linear-color-stop> [, <linear-color-hint>]?]# , <linear-color-stop>",
    "combinator": "'>'|'+'|'~'|['||']",
    "common-lig-values": "[common-ligatures|no-common-ligatures]",
    "compat-auto": "searchfield|textarea|push-button|slider-horizontal|checkbox|radio|square-button|menulist|listbox|meter|progress-bar|button",
    "composite-style": "clear|copy|source-over|source-in|source-out|source-atop|destination-over|destination-in|destination-out|destination-atop|xor",
    "compositing-operator": "add|subtract|intersect|exclude",
    "compound-selector": "[<type-selector>? <subclass-selector>* [<pseudo-element-selector> <pseudo-class-selector>*]*]!",
    "compound-selector-list": "<compound-selector>#",
    "complex-selector": "<compound-selector> [<combinator>? <compound-selector>]*",
    "complex-selector-list": "<complex-selector>#",
    "conic-gradient()": "conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
    "contextual-alt-values": "[contextual|no-contextual]",
    "content-distribution": "space-between|space-around|space-evenly|stretch",
    "content-list": "[<string>|contents|<image>|<counter>|<quote>|<target>|<leader()>|<attr()>]+",
    "content-position": "center|start|end|flex-start|flex-end",
    "content-replacement": "<image>",
    "contrast()": "contrast( [<number-percentage>] )",
    "cos()": "cos( <calc-sum> )",
    "counter": "<counter()>|<counters()>",
    "counter()": "counter( <counter-name> , <counter-style>? )",
    "counter-name": "<custom-ident>",
    "counter-style": "<counter-style-name>|symbols( )",
    "counter-style-name": "<custom-ident>",
    "counters()": "counters( <counter-name> , <string> , <counter-style>? )",
    "cross-fade()": "cross-fade( <cf-mixing-image> , <cf-final-image>? )",
    "cubic-bezier-timing-function": "ease|ease-in|ease-out|ease-in-out|cubic-bezier( <number [0,1]> , <number> , <number [0,1]> , <number> )",
    "deprecated-system-color": "ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText",
    "discretionary-lig-values": "[discretionary-ligatures|no-discretionary-ligatures]",
    "display-box": "contents|none",
    "display-inside": "flow|flow-root|table|flex|grid|ruby",
    "display-internal": "table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption|ruby-base|ruby-text|ruby-base-container|ruby-text-container",
    "display-legacy": "inline-block|inline-list-item|inline-table|inline-flex|inline-grid",
    "display-listitem": "<display-outside>?&&[flow|flow-root]?&&list-item",
    "display-outside": "block|inline|run-in",
    "drop-shadow()": "drop-shadow( <length>{2,3} <color>? )",
    "east-asian-variant-values": "[jis78|jis83|jis90|jis04|simplified|traditional]",
    "east-asian-width-values": "[full-width|proportional-width]",
    "element()": "element( <custom-ident> , [first|start|last|first-except]? )|element( <id-selector> )",
    "ellipse()": "ellipse( [<shape-radius>{2}]? [at <position>]? )",
    "ending-shape": "circle|ellipse",
    "env()": "env( <custom-ident> , <declaration-value>? )",
    "exp()": "exp( <calc-sum> )",
    "explicit-track-list": "[<line-names>? <track-size>]+ <line-names>?",
    "family-name": "<string>|<custom-ident>+",
    "feature-tag-value": "<string> [<integer>|on|off]?",
    "feature-type": "@stylistic|@historical-forms|@styleset|@character-variant|@swash|@ornaments|@annotation",
    "feature-value-block": "<feature-type> '{' <feature-value-declaration-list> '}'",
    "feature-value-block-list": "<feature-value-block>+",
    "feature-value-declaration": "<custom-ident> : <integer>+ ;",
    "feature-value-declaration-list": "<feature-value-declaration>",
    "feature-value-name": "<custom-ident>",
    "fill-rule": "nonzero|evenodd",
    "filter-function": "<blur()>|<brightness()>|<contrast()>|<drop-shadow()>|<grayscale()>|<hue-rotate()>|<invert()>|<opacity()>|<saturate()>|<sepia()>",
    "filter-function-list": "[<filter-function>|<url>]+",
    "final-bg-layer": "<'background-color'>||<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
    "fixed-breadth": "<length-percentage>",
    "fixed-repeat": "repeat( [<integer [1,∞]>] , [<line-names>? <fixed-size>]+ <line-names>? )",
    "fixed-size": "<fixed-breadth>|minmax( <fixed-breadth> , <track-breadth> )|minmax( <inflexible-breadth> , <fixed-breadth> )",
    "font-stretch-absolute": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded|<percentage>",
    "font-variant-css21": "[normal|small-caps]",
    "font-weight-absolute": "normal|bold|<number [1,1000]>",
    "frequency-percentage": "<frequency>|<percentage>",
    "general-enclosed": "[<function-token> <any-value> )]|( <ident> <any-value> )",
    "generic-family": "serif|sans-serif|cursive|fantasy|monospace|-apple-system",
    "generic-name": "serif|sans-serif|cursive|fantasy|monospace",
    "geometry-box": "<shape-box>|fill-box|stroke-box|view-box",
    "gradient": "<linear-gradient()>|<repeating-linear-gradient()>|<radial-gradient()>|<repeating-radial-gradient()>|<conic-gradient()>|<repeating-conic-gradient()>|<-legacy-gradient>",
    "grayscale()": "grayscale( <number-percentage> )",
    "grid-line": "auto|<custom-ident>|[<integer>&&<custom-ident>?]|[span&&[<integer>||<custom-ident>]]",
    "historical-lig-values": "[historical-ligatures|no-historical-ligatures]",
    "hsl()": "hsl( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )",
    "hsla()": "hsla( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )",
    "hue": "<number>|<angle>",
    "hue-rotate()": "hue-rotate( <angle> )",
    "hwb()": "hwb( [<hue>|none] [<percentage>|none] [<percentage>|none] [/ [<alpha-value>|none]]? )",
    "hypot()": "hypot( <calc-sum># )",
    "image": "<url>|<image()>|<image-set()>|<element()>|<paint()>|<cross-fade()>|<gradient>",
    "image()": "image( <image-tags>? [<image-src>? , <color>?]! )",
    "image-set()": "image-set( <image-set-option># )",
    "image-set-option": "[<image>|<string>] [<resolution>||type( <string> )]",
    "image-src": "<url>|<string>",
    "image-tags": "ltr|rtl",
    "inflexible-breadth": "<length-percentage>|min-content|max-content|auto",
    "inset()": "inset( <length-percentage>{1,4} [round <'border-radius'>]? )",
    "invert()": "invert( <number-percentage> )",
    "keyframes-name": "<custom-ident>|<string>",
    "keyframe-block": "<keyframe-selector># { <declaration-list> }",
    "keyframe-block-list": "<keyframe-block>+",
    "keyframe-selector": "from|to|<percentage>",
    "lab()": "lab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )",
    "layer()": "layer( <layer-name> )",
    "layer-name": "<ident> ['.' <ident>]*",
    "lch()": "lch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )",
    "leader()": "leader( <leader-type> )",
    "leader-type": "dotted|solid|space|<string>",
    "length-percentage": "<length>|<percentage>",
    "line-names": "'[' <custom-ident>* ']'",
    "line-name-list": "[<line-names>|<name-repeat>]+",
    "line-style": "none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset",
    "line-width": "<length>|thin|medium|thick",
    "linear-color-hint": "<length-percentage>",
    "linear-color-stop": "<color> <color-stop-length>?",
    "linear-gradient()": "linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
    "log()": "log( <calc-sum> , <calc-sum>? )",
    "mask-layer": "<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||<geometry-box>||[<geometry-box>|no-clip]||<compositing-operator>||<masking-mode>",
    "mask-position": "[<length-percentage>|left|center|right] [<length-percentage>|top|center|bottom]?",
    "mask-reference": "none|<image>|<mask-source>",
    "mask-source": "<url>",
    "masking-mode": "alpha|luminance|match-source",
    "matrix()": "matrix( <number>#{6} )",
    "matrix3d()": "matrix3d( <number>#{16} )",
    "max()": "max( <calc-sum># )",
    "media-and": "<media-in-parens> [and <media-in-parens>]+",
    "media-condition": "<media-not>|<media-and>|<media-or>|<media-in-parens>",
    "media-condition-without-or": "<media-not>|<media-and>|<media-in-parens>",
    "media-feature": "( [<mf-plain>|<mf-boolean>|<mf-range>] )",
    "media-in-parens": "( <media-condition> )|<media-feature>|<general-enclosed>",
    "media-not": "not <media-in-parens>",
    "media-or": "<media-in-parens> [or <media-in-parens>]+",
    "media-query": "<media-condition>|[not|only]? <media-type> [and <media-condition-without-or>]?",
    "media-query-list": "<media-query>#",
    "media-type": "<ident>",
    "mf-boolean": "<mf-name>",
    "mf-name": "<ident>",
    "mf-plain": "<mf-name> : <mf-value>",
    "mf-range": "<mf-name> ['<'|'>']? '='? <mf-value>|<mf-value> ['<'|'>']? '='? <mf-name>|<mf-value> '<' '='? <mf-name> '<' '='? <mf-value>|<mf-value> '>' '='? <mf-name> '>' '='? <mf-value>",
    "mf-value": "<number>|<dimension>|<ident>|<ratio>",
    "min()": "min( <calc-sum># )",
    "minmax()": "minmax( [<length-percentage>|min-content|max-content|auto] , [<length-percentage>|<flex>|min-content|max-content|auto] )",
    "mod()": "mod( <calc-sum> , <calc-sum> )",
    "name-repeat": "repeat( [<integer [1,∞]>|auto-fill] , <line-names>+ )",
    "named-color": "transparent|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen|<-non-standard-color>",
    "namespace-prefix": "<ident>",
    "ns-prefix": "[<ident-token>|'*']? '|'",
    "number-percentage": "<number>|<percentage>",
    "numeric-figure-values": "[lining-nums|oldstyle-nums]",
    "numeric-fraction-values": "[diagonal-fractions|stacked-fractions]",
    "numeric-spacing-values": "[proportional-nums|tabular-nums]",
    "nth": "<an-plus-b>|even|odd",
    "opacity()": "opacity( [<number-percentage>] )",
    "overflow-position": "unsafe|safe",
    "outline-radius": "<length>|<percentage>",
    "page-body": "<declaration>? [; <page-body>]?|<page-margin-box> <page-body>",
    "page-margin-box": "<page-margin-box-type> '{' <declaration-list> '}'",
    "page-margin-box-type": "@top-left-corner|@top-left|@top-center|@top-right|@top-right-corner|@bottom-left-corner|@bottom-left|@bottom-center|@bottom-right|@bottom-right-corner|@left-top|@left-middle|@left-bottom|@right-top|@right-middle|@right-bottom",
    "page-selector-list": "[<page-selector>#]?",
    "page-selector": "<pseudo-page>+|<ident> <pseudo-page>*",
    "page-size": "A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger",
    "path()": "path( [<fill-rule> ,]? <string> )",
    "paint()": "paint( <ident> , <declaration-value>? )",
    "perspective()": "perspective( [<length [0,∞]>|none] )",
    "polygon()": "polygon( <fill-rule>? , [<length-percentage> <length-percentage>]# )",
    "position": "[[left|center|right]||[top|center|bottom]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]?|[[left|right] <length-percentage>]&&[[top|bottom] <length-percentage>]]",
    "pow()": "pow( <calc-sum> , <calc-sum> )",
    "pseudo-class-selector": "':' <ident-token>|':' <function-token> <any-value> ')'",
    "pseudo-element-selector": "':' <pseudo-class-selector>",
    "pseudo-page": ": [left|right|first|blank]",
    "quote": "open-quote|close-quote|no-open-quote|no-close-quote",
    "radial-gradient()": "radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
    "ratio": "<number [0,∞]> [/ <number [0,∞]>]?",
    "relative-selector": "<combinator>? <complex-selector>",
    "relative-selector-list": "<relative-selector>#",
    "relative-size": "larger|smaller",
    "rem()": "rem( <calc-sum> , <calc-sum> )",
    "repeat-style": "repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}",
    "repeating-conic-gradient()": "repeating-conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
    "repeating-linear-gradient()": "repeating-linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
    "repeating-radial-gradient()": "repeating-radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
    "reversed-counter-name": "reversed( <counter-name> )",
    "rgb()": "rgb( <percentage>{3} [/ <alpha-value>]? )|rgb( <number>{3} [/ <alpha-value>]? )|rgb( <percentage>#{3} , <alpha-value>? )|rgb( <number>#{3} , <alpha-value>? )",
    "rgba()": "rgba( <percentage>{3} [/ <alpha-value>]? )|rgba( <number>{3} [/ <alpha-value>]? )|rgba( <percentage>#{3} , <alpha-value>? )|rgba( <number>#{3} , <alpha-value>? )",
    "rotate()": "rotate( [<angle>|<zero>] )",
    "rotate3d()": "rotate3d( <number> , <number> , <number> , [<angle>|<zero>] )",
    "rotateX()": "rotateX( [<angle>|<zero>] )",
    "rotateY()": "rotateY( [<angle>|<zero>] )",
    "rotateZ()": "rotateZ( [<angle>|<zero>] )",
    "round()": "round( <rounding-strategy>? , <calc-sum> , <calc-sum> )",
    "rounding-strategy": "nearest|up|down|to-zero",
    "saturate()": "saturate( <number-percentage> )",
    "scale()": "scale( [<number>|<percentage>]#{1,2} )",
    "scale3d()": "scale3d( [<number>|<percentage>]#{3} )",
    "scaleX()": "scaleX( [<number>|<percentage>] )",
    "scaleY()": "scaleY( [<number>|<percentage>] )",
    "scaleZ()": "scaleZ( [<number>|<percentage>] )",
    "scroller": "root|nearest",
    "self-position": "center|start|end|self-start|self-end|flex-start|flex-end",
    "shape-radius": "<length-percentage>|closest-side|farthest-side",
    "sign()": "sign( <calc-sum> )",
    "skew()": "skew( [<angle>|<zero>] , [<angle>|<zero>]? )",
    "skewX()": "skewX( [<angle>|<zero>] )",
    "skewY()": "skewY( [<angle>|<zero>] )",
    "sepia()": "sepia( <number-percentage> )",
    "shadow": "inset?&&<length>{2,4}&&<color>?",
    "shadow-t": "[<length>{2,3}&&<color>?]",
    "shape": "rect( <top> , <right> , <bottom> , <left> )|rect( <top> <right> <bottom> <left> )",
    "shape-box": "<box>|margin-box",
    "side-or-corner": "[left|right]||[top|bottom]",
    "sin()": "sin( <calc-sum> )",
    "single-animation": "<time>||<easing-function>||<time>||<single-animation-iteration-count>||<single-animation-direction>||<single-animation-fill-mode>||<single-animation-play-state>||[none|<keyframes-name>]",
    "single-animation-direction": "normal|reverse|alternate|alternate-reverse",
    "single-animation-fill-mode": "none|forwards|backwards|both",
    "single-animation-iteration-count": "infinite|<number>",
    "single-animation-play-state": "running|paused",
    "single-animation-timeline": "auto|none|<timeline-name>|scroll( <axis>? <scroller>? )",
    "single-transition": "[none|<single-transition-property>]||<time>||<easing-function>||<time>",
    "single-transition-property": "all|<custom-ident>",
    "size": "closest-side|farthest-side|closest-corner|farthest-corner|<length>|<length-percentage>{2}",
    "sqrt()": "sqrt( <calc-sum> )",
    "step-position": "jump-start|jump-end|jump-none|jump-both|start|end",
    "step-timing-function": "step-start|step-end|steps( <integer> [, <step-position>]? )",
    "subclass-selector": "<id-selector>|<class-selector>|<attribute-selector>|<pseudo-class-selector>",
    "supports-condition": "not <supports-in-parens>|<supports-in-parens> [and <supports-in-parens>]*|<supports-in-parens> [or <supports-in-parens>]*",
    "supports-in-parens": "( <supports-condition> )|<supports-feature>|<general-enclosed>",
    "supports-feature": "<supports-decl>|<supports-selector-fn>",
    "supports-decl": "( <declaration> )",
    "supports-selector-fn": "selector( <complex-selector> )",
    "symbol": "<string>|<image>|<custom-ident>",
    "tan()": "tan( <calc-sum> )",
    "target": "<target-counter()>|<target-counters()>|<target-text()>",
    "target-counter()": "target-counter( [<string>|<url>] , <custom-ident> , <counter-style>? )",
    "target-counters()": "target-counters( [<string>|<url>] , <custom-ident> , <string> , <counter-style>? )",
    "target-text()": "target-text( [<string>|<url>] , [content|before|after|first-letter]? )",
    "time-percentage": "<time>|<percentage>",
    "timeline-name": "<custom-ident>|<string>",
    "easing-function": "linear|<cubic-bezier-timing-function>|<step-timing-function>",
    "track-breadth": "<length-percentage>|<flex>|min-content|max-content|auto",
    "track-list": "[<line-names>? [<track-size>|<track-repeat>]]+ <line-names>?",
    "track-repeat": "repeat( [<integer [1,∞]>] , [<line-names>? <track-size>]+ <line-names>? )",
    "track-size": "<track-breadth>|minmax( <inflexible-breadth> , <track-breadth> )|fit-content( <length-percentage> )",
    "transform-function": "<matrix()>|<translate()>|<translateX()>|<translateY()>|<scale()>|<scaleX()>|<scaleY()>|<rotate()>|<skew()>|<skewX()>|<skewY()>|<matrix3d()>|<translate3d()>|<translateZ()>|<scale3d()>|<scaleZ()>|<rotate3d()>|<rotateX()>|<rotateY()>|<rotateZ()>|<perspective()>",
    "transform-list": "<transform-function>+",
    "translate()": "translate( <length-percentage> , <length-percentage>? )",
    "translate3d()": "translate3d( <length-percentage> , <length-percentage> , <length> )",
    "translateX()": "translateX( <length-percentage> )",
    "translateY()": "translateY( <length-percentage> )",
    "translateZ()": "translateZ( <length> )",
    "type-or-unit": "string|color|url|integer|number|length|angle|time|frequency|cap|ch|em|ex|ic|lh|rlh|rem|vb|vi|vw|vh|vmin|vmax|mm|Q|cm|in|pt|pc|px|deg|grad|rad|turn|ms|s|Hz|kHz|%",
    "type-selector": "<wq-name>|<ns-prefix>? '*'",
    "var()": "var( <custom-property-name> , <declaration-value>? )",
    "viewport-length": "auto|<length-percentage>",
    "visual-box": "content-box|padding-box|border-box",
    "wq-name": "<ns-prefix>? <ident-token>",
    "-legacy-gradient": "<-webkit-gradient()>|<-legacy-linear-gradient>|<-legacy-repeating-linear-gradient>|<-legacy-radial-gradient>|<-legacy-repeating-radial-gradient>",
    "-legacy-linear-gradient": "-moz-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-linear-gradient( <-legacy-linear-gradient-arguments> )",
    "-legacy-repeating-linear-gradient": "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )",
    "-legacy-linear-gradient-arguments": "[<angle>|<side-or-corner>]? , <color-stop-list>",
    "-legacy-radial-gradient": "-moz-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-radial-gradient( <-legacy-radial-gradient-arguments> )",
    "-legacy-repeating-radial-gradient": "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )",
    "-legacy-radial-gradient-arguments": "[<position> ,]? [[[<-legacy-radial-gradient-shape>||<-legacy-radial-gradient-size>]|[<length>|<percentage>]{2}] ,]? <color-stop-list>",
    "-legacy-radial-gradient-size": "closest-side|closest-corner|farthest-side|farthest-corner|contain|cover",
    "-legacy-radial-gradient-shape": "circle|ellipse",
    "-non-standard-font": "-apple-system-body|-apple-system-headline|-apple-system-subheadline|-apple-system-caption1|-apple-system-caption2|-apple-system-footnote|-apple-system-short-body|-apple-system-short-headline|-apple-system-short-subheadline|-apple-system-short-caption1|-apple-system-short-footnote|-apple-system-tall-body",
    "-non-standard-color": "-moz-ButtonDefault|-moz-ButtonHoverFace|-moz-ButtonHoverText|-moz-CellHighlight|-moz-CellHighlightText|-moz-Combobox|-moz-ComboboxText|-moz-Dialog|-moz-DialogText|-moz-dragtargetzone|-moz-EvenTreeRow|-moz-Field|-moz-FieldText|-moz-html-CellHighlight|-moz-html-CellHighlightText|-moz-mac-accentdarkestshadow|-moz-mac-accentdarkshadow|-moz-mac-accentface|-moz-mac-accentlightesthighlight|-moz-mac-accentlightshadow|-moz-mac-accentregularhighlight|-moz-mac-accentregularshadow|-moz-mac-chrome-active|-moz-mac-chrome-inactive|-moz-mac-focusring|-moz-mac-menuselect|-moz-mac-menushadow|-moz-mac-menutextselect|-moz-MenuHover|-moz-MenuHoverText|-moz-MenuBarText|-moz-MenuBarHoverText|-moz-nativehyperlinktext|-moz-OddTreeRow|-moz-win-communicationstext|-moz-win-mediatext|-moz-activehyperlinktext|-moz-default-background-color|-moz-default-color|-moz-hyperlinktext|-moz-visitedhyperlinktext|-webkit-activelink|-webkit-focus-ring-color|-webkit-link|-webkit-text",
    "-non-standard-image-rendering": "optimize-contrast|-moz-crisp-edges|-o-crisp-edges|-webkit-optimize-contrast",
    "-non-standard-overflow": "-moz-scrollbars-none|-moz-scrollbars-horizontal|-moz-scrollbars-vertical|-moz-hidden-unscrollable",
    "-non-standard-width": "fill-available|min-intrinsic|intrinsic|-moz-available|-moz-fit-content|-moz-min-content|-moz-max-content|-webkit-min-content|-webkit-max-content",
    "-webkit-gradient()": "-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point>|, <-webkit-gradient-radius> , <-webkit-gradient-point>] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )",
    "-webkit-gradient-color-stop": "from( <color> )|color-stop( [<number-zero-one>|<percentage>] , <color> )|to( <color> )",
    "-webkit-gradient-point": "[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]",
    "-webkit-gradient-radius": "<length>|<percentage>",
    "-webkit-gradient-type": "linear|radial",
    "-webkit-mask-box-repeat": "repeat|stretch|round",
    "-webkit-mask-clip-style": "border|border-box|padding|padding-box|content|content-box|text",
    "-ms-filter-function-list": "<-ms-filter-function>+",
    "-ms-filter-function": "<-ms-filter-function-progid>|<-ms-filter-function-legacy>",
    "-ms-filter-function-progid": "'progid:' [<ident-token> '.']* [<ident-token>|<function-token> <any-value>? )]",
    "-ms-filter-function-legacy": "<ident-token>|<function-token> <any-value>? )",
    "-ms-filter": "<string>",
    "age": "child|young|old",
    "attr-name": "<wq-name>",
    "attr-fallback": "<any-value>",
    "bg-clip": "<box>|border|text",
    "bottom": "<length>|auto",
    "generic-voice": "[<age>? <gender> <integer>?]",
    "gender": "male|female|neutral",
    "left": "<length>|auto",
    "mask-image": "<mask-reference>#",
    "paint": "none|<color>|<url> [none|<color>]?|context-fill|context-stroke",
    "right": "<length>|auto",
    "scroll-timeline-axis": "block|inline|vertical|horizontal",
    "scroll-timeline-name": "none|<custom-ident>",
    "single-animation-composition": "replace|add|accumulate",
    "svg-length": "<percentage>|<length>|<number>",
    "svg-writing-mode": "lr-tb|rl-tb|tb-rl|lr|rl|tb",
    "top": "<length>|auto",
    "x": "<number>",
    "y": "<number>",
    "declaration": "<ident-token> : <declaration-value>? ['!' important]?",
    "declaration-list": "[<declaration>? ';']* <declaration>?",
    "url": "url( <string> <url-modifier>* )|<url-token>",
    "url-modifier": "<ident>|<function-token> <any-value> )",
    "number-zero-one": "<number [0,1]>",
    "number-one-or-greater": "<number [1,∞]>",
    "-non-standard-display": "-ms-inline-flexbox|-ms-grid|-ms-inline-grid|-webkit-flex|-webkit-inline-flex|-webkit-box|-webkit-inline-box|-moz-inline-stack|-moz-box|-moz-inline-box"
  },
  "properties": {
    "--*": "<declaration-value>",
    "-ms-accelerator": "false|true",
    "-ms-block-progression": "tb|rl|bt|lr",
    "-ms-content-zoom-chaining": "none|chained",
    "-ms-content-zooming": "none|zoom",
    "-ms-content-zoom-limit": "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
    "-ms-content-zoom-limit-max": "<percentage>",
    "-ms-content-zoom-limit-min": "<percentage>",
    "-ms-content-zoom-snap": "<'-ms-content-zoom-snap-type'>||<'-ms-content-zoom-snap-points'>",
    "-ms-content-zoom-snap-points": "snapInterval( <percentage> , <percentage> )|snapList( <percentage># )",
    "-ms-content-zoom-snap-type": "none|proximity|mandatory",
    "-ms-filter": "<string>",
    "-ms-flow-from": "[none|<custom-ident>]#",
    "-ms-flow-into": "[none|<custom-ident>]#",
    "-ms-grid-columns": "none|<track-list>|<auto-track-list>",
    "-ms-grid-rows": "none|<track-list>|<auto-track-list>",
    "-ms-high-contrast-adjust": "auto|none",
    "-ms-hyphenate-limit-chars": "auto|<integer>{1,3}",
    "-ms-hyphenate-limit-lines": "no-limit|<integer>",
    "-ms-hyphenate-limit-zone": "<percentage>|<length>",
    "-ms-ime-align": "auto|after",
    "-ms-overflow-style": "auto|none|scrollbar|-ms-autohiding-scrollbar",
    "-ms-scrollbar-3dlight-color": "<color>",
    "-ms-scrollbar-arrow-color": "<color>",
    "-ms-scrollbar-base-color": "<color>",
    "-ms-scrollbar-darkshadow-color": "<color>",
    "-ms-scrollbar-face-color": "<color>",
    "-ms-scrollbar-highlight-color": "<color>",
    "-ms-scrollbar-shadow-color": "<color>",
    "-ms-scrollbar-track-color": "<color>",
    "-ms-scroll-chaining": "chained|none",
    "-ms-scroll-limit": "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
    "-ms-scroll-limit-x-max": "auto|<length>",
    "-ms-scroll-limit-x-min": "<length>",
    "-ms-scroll-limit-y-max": "auto|<length>",
    "-ms-scroll-limit-y-min": "<length>",
    "-ms-scroll-rails": "none|railed",
    "-ms-scroll-snap-points-x": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
    "-ms-scroll-snap-points-y": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
    "-ms-scroll-snap-type": "none|proximity|mandatory",
    "-ms-scroll-snap-x": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
    "-ms-scroll-snap-y": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
    "-ms-scroll-translation": "none|vertical-to-horizontal",
    "-ms-text-autospace": "none|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space",
    "-ms-touch-select": "grippers|none",
    "-ms-user-select": "none|element|text",
    "-ms-wrap-flow": "auto|both|start|end|maximum|clear",
    "-ms-wrap-margin": "<length>",
    "-ms-wrap-through": "wrap|none",
    "-moz-appearance": "none|button|button-arrow-down|button-arrow-next|button-arrow-previous|button-arrow-up|button-bevel|button-focus|caret|checkbox|checkbox-container|checkbox-label|checkmenuitem|dualbutton|groupbox|listbox|listitem|menuarrow|menubar|menucheckbox|menuimage|menuitem|menuitemtext|menulist|menulist-button|menulist-text|menulist-textfield|menupopup|menuradio|menuseparator|meterbar|meterchunk|progressbar|progressbar-vertical|progresschunk|progresschunk-vertical|radio|radio-container|radio-label|radiomenuitem|range|range-thumb|resizer|resizerpanel|scale-horizontal|scalethumbend|scalethumb-horizontal|scalethumbstart|scalethumbtick|scalethumb-vertical|scale-vertical|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|separator|sheet|spinner|spinner-downbutton|spinner-textfield|spinner-upbutton|splitter|statusbar|statusbarpanel|tab|tabpanel|tabpanels|tab-scroll-arrow-back|tab-scroll-arrow-forward|textfield|textfield-multiline|toolbar|toolbarbutton|toolbarbutton-dropdown|toolbargripper|toolbox|tooltip|treeheader|treeheadercell|treeheadersortarrow|treeitem|treeline|treetwisty|treetwistyopen|treeview|-moz-mac-unified-toolbar|-moz-win-borderless-glass|-moz-win-browsertabbar-toolbox|-moz-win-communicationstext|-moz-win-communications-toolbox|-moz-win-exclude-glass|-moz-win-glass|-moz-win-mediatext|-moz-win-media-toolbox|-moz-window-button-box|-moz-window-button-box-maximized|-moz-window-button-close|-moz-window-button-maximize|-moz-window-button-minimize|-moz-window-button-restore|-moz-window-frame-bottom|-moz-window-frame-left|-moz-window-frame-right|-moz-window-titlebar|-moz-window-titlebar-maximized",
    "-moz-binding": "<url>|none",
    "-moz-border-bottom-colors": "<color>+|none",
    "-moz-border-left-colors": "<color>+|none",
    "-moz-border-right-colors": "<color>+|none",
    "-moz-border-top-colors": "<color>+|none",
    "-moz-context-properties": "none|[fill|fill-opacity|stroke|stroke-opacity]#",
    "-moz-float-edge": "border-box|content-box|margin-box|padding-box",
    "-moz-force-broken-image-icon": "0|1",
    "-moz-image-region": "<shape>|auto",
    "-moz-orient": "inline|block|horizontal|vertical",
    "-moz-outline-radius": "<outline-radius>{1,4} [/ <outline-radius>{1,4}]?",
    "-moz-outline-radius-bottomleft": "<outline-radius>",
    "-moz-outline-radius-bottomright": "<outline-radius>",
    "-moz-outline-radius-topleft": "<outline-radius>",
    "-moz-outline-radius-topright": "<outline-radius>",
    "-moz-stack-sizing": "ignore|stretch-to-fit",
    "-moz-text-blink": "none|blink",
    "-moz-user-focus": "ignore|normal|select-after|select-before|select-menu|select-same|select-all|none",
    "-moz-user-input": "auto|none|enabled|disabled",
    "-moz-user-modify": "read-only|read-write|write-only",
    "-moz-window-dragging": "drag|no-drag",
    "-moz-window-shadow": "default|menu|tooltip|sheet|none",
    "-webkit-appearance": "none|button|button-bevel|caps-lock-indicator|caret|checkbox|default-button|inner-spin-button|listbox|listitem|media-controls-background|media-controls-fullscreen-background|media-current-time-display|media-enter-fullscreen-button|media-exit-fullscreen-button|media-fullscreen-button|media-mute-button|media-overlay-play-button|media-play-button|media-seek-back-button|media-seek-forward-button|media-slider|media-sliderthumb|media-time-remaining-display|media-toggle-closed-captions-button|media-volume-slider|media-volume-slider-container|media-volume-sliderthumb|menulist|menulist-button|menulist-text|menulist-textfield|meter|progress-bar|progress-bar-value|push-button|radio|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbargripper-horizontal|scrollbargripper-vertical|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|searchfield-cancel-button|searchfield-decoration|searchfield-results-button|searchfield-results-decoration|slider-horizontal|slider-vertical|sliderthumb-horizontal|sliderthumb-vertical|square-button|textarea|textfield|-apple-pay-button",
    "-webkit-border-before": "<'border-width'>||<'border-style'>||<color>",
    "-webkit-border-before-color": "<color>",
    "-webkit-border-before-style": "<'border-style'>",
    "-webkit-border-before-width": "<'border-width'>",
    "-webkit-box-reflect": "[above|below|right|left]? <length>? <image>?",
    "-webkit-line-clamp": "none|<integer>",
    "-webkit-mask": "[<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||[<box>|border|padding|content|text]||[<box>|border|padding|content]]#",
    "-webkit-mask-attachment": "<attachment>#",
    "-webkit-mask-clip": "[<box>|border|padding|content|text]#",
    "-webkit-mask-composite": "<composite-style>#",
    "-webkit-mask-image": "<mask-reference>#",
    "-webkit-mask-origin": "[<box>|border|padding|content]#",
    "-webkit-mask-position": "<position>#",
    "-webkit-mask-position-x": "[<length-percentage>|left|center|right]#",
    "-webkit-mask-position-y": "[<length-percentage>|top|center|bottom]#",
    "-webkit-mask-repeat": "<repeat-style>#",
    "-webkit-mask-repeat-x": "repeat|no-repeat|space|round",
    "-webkit-mask-repeat-y": "repeat|no-repeat|space|round",
    "-webkit-mask-size": "<bg-size>#",
    "-webkit-overflow-scrolling": "auto|touch",
    "-webkit-tap-highlight-color": "<color>",
    "-webkit-text-fill-color": "<color>",
    "-webkit-text-stroke": "<length>||<color>",
    "-webkit-text-stroke-color": "<color>",
    "-webkit-text-stroke-width": "<length>",
    "-webkit-touch-callout": "default|none",
    "-webkit-user-modify": "read-only|read-write|read-write-plaintext-only",
    "accent-color": "auto|<color>",
    "align-content": "normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>",
    "align-items": "normal|stretch|<baseline-position>|[<overflow-position>? <self-position>]",
    "align-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? <self-position>",
    "align-tracks": "[normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>]#",
    "all": "initial|inherit|unset|revert|revert-layer",
    "animation": "<single-animation>#",
    "animation-composition": "<single-animation-composition>#",
    "animation-delay": "<time>#",
    "animation-direction": "<single-animation-direction>#",
    "animation-duration": "<time>#",
    "animation-fill-mode": "<single-animation-fill-mode>#",
    "animation-iteration-count": "<single-animation-iteration-count>#",
    "animation-name": "[none|<keyframes-name>]#",
    "animation-play-state": "<single-animation-play-state>#",
    "animation-timing-function": "<easing-function>#",
    "animation-timeline": "<single-animation-timeline>#",
    "appearance": "none|auto|textfield|menulist-button|<compat-auto>",
    "aspect-ratio": "auto|<ratio>",
    "azimuth": "<angle>|[[left-side|far-left|left|center-left|center|center-right|right|far-right|right-side]||behind]|leftwards|rightwards",
    "backdrop-filter": "none|<filter-function-list>",
    "backface-visibility": "visible|hidden",
    "background": "[<bg-layer> ,]* <final-bg-layer>",
    "background-attachment": "<attachment>#",
    "background-blend-mode": "<blend-mode>#",
    "background-clip": "<bg-clip>#",
    "background-color": "<color>",
    "background-image": "<bg-image>#",
    "background-origin": "<box>#",
    "background-position": "<bg-position>#",
    "background-position-x": "[center|[[left|right|x-start|x-end]? <length-percentage>?]!]#",
    "background-position-y": "[center|[[top|bottom|y-start|y-end]? <length-percentage>?]!]#",
    "background-repeat": "<repeat-style>#",
    "background-size": "<bg-size>#",
    "block-overflow": "clip|ellipsis|<string>",
    "block-size": "<'width'>",
    "border": "<line-width>||<line-style>||<color>",
    "border-block": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-block-color": "<'border-top-color'>{1,2}",
    "border-block-style": "<'border-top-style'>",
    "border-block-width": "<'border-top-width'>",
    "border-block-end": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-block-end-color": "<'border-top-color'>",
    "border-block-end-style": "<'border-top-style'>",
    "border-block-end-width": "<'border-top-width'>",
    "border-block-start": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-block-start-color": "<'border-top-color'>",
    "border-block-start-style": "<'border-top-style'>",
    "border-block-start-width": "<'border-top-width'>",
    "border-bottom": "<line-width>||<line-style>||<color>",
    "border-bottom-color": "<'border-top-color'>",
    "border-bottom-left-radius": "<length-percentage>{1,2}",
    "border-bottom-right-radius": "<length-percentage>{1,2}",
    "border-bottom-style": "<line-style>",
    "border-bottom-width": "<line-width>",
    "border-collapse": "collapse|separate",
    "border-color": "<color>{1,4}",
    "border-end-end-radius": "<length-percentage>{1,2}",
    "border-end-start-radius": "<length-percentage>{1,2}",
    "border-image": "<'border-image-source'>||<'border-image-slice'> [/ <'border-image-width'>|/ <'border-image-width'>? / <'border-image-outset'>]?||<'border-image-repeat'>",
    "border-image-outset": "[<length>|<number>]{1,4}",
    "border-image-repeat": "[stretch|repeat|round|space]{1,2}",
    "border-image-slice": "<number-percentage>{1,4}&&fill?",
    "border-image-source": "none|<image>",
    "border-image-width": "[<length-percentage>|<number>|auto]{1,4}",
    "border-inline": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-inline-end": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-inline-color": "<'border-top-color'>{1,2}",
    "border-inline-style": "<'border-top-style'>",
    "border-inline-width": "<'border-top-width'>",
    "border-inline-end-color": "<'border-top-color'>",
    "border-inline-end-style": "<'border-top-style'>",
    "border-inline-end-width": "<'border-top-width'>",
    "border-inline-start": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-inline-start-color": "<'border-top-color'>",
    "border-inline-start-style": "<'border-top-style'>",
    "border-inline-start-width": "<'border-top-width'>",
    "border-left": "<line-width>||<line-style>||<color>",
    "border-left-color": "<color>",
    "border-left-style": "<line-style>",
    "border-left-width": "<line-width>",
    "border-radius": "<length-percentage>{1,4} [/ <length-percentage>{1,4}]?",
    "border-right": "<line-width>||<line-style>||<color>",
    "border-right-color": "<color>",
    "border-right-style": "<line-style>",
    "border-right-width": "<line-width>",
    "border-spacing": "<length> <length>?",
    "border-start-end-radius": "<length-percentage>{1,2}",
    "border-start-start-radius": "<length-percentage>{1,2}",
    "border-style": "<line-style>{1,4}",
    "border-top": "<line-width>||<line-style>||<color>",
    "border-top-color": "<color>",
    "border-top-left-radius": "<length-percentage>{1,2}",
    "border-top-right-radius": "<length-percentage>{1,2}",
    "border-top-style": "<line-style>",
    "border-top-width": "<line-width>",
    "border-width": "<line-width>{1,4}",
    "bottom": "<length>|<percentage>|auto",
    "box-align": "start|center|end|baseline|stretch",
    "box-decoration-break": "slice|clone",
    "box-direction": "normal|reverse|inherit",
    "box-flex": "<number>",
    "box-flex-group": "<integer>",
    "box-lines": "single|multiple",
    "box-ordinal-group": "<integer>",
    "box-orient": "horizontal|vertical|inline-axis|block-axis|inherit",
    "box-pack": "start|center|end|justify",
    "box-shadow": "none|<shadow>#",
    "box-sizing": "content-box|border-box",
    "break-after": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
    "break-before": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
    "break-inside": "auto|avoid|avoid-page|avoid-column|avoid-region",
    "caption-side": "top|bottom|block-start|block-end|inline-start|inline-end",
    "caret": "<'caret-color'>||<'caret-shape'>",
    "caret-color": "auto|<color>",
    "caret-shape": "auto|bar|block|underscore",
    "clear": "none|left|right|both|inline-start|inline-end",
    "clip": "<shape>|auto",
    "clip-path": "<clip-source>|[<basic-shape>||<geometry-box>]|none",
    "color": "<color>",
    "print-color-adjust": "economy|exact",
    "color-scheme": "normal|[light|dark|<custom-ident>]+&&only?",
    "column-count": "<integer>|auto",
    "column-fill": "auto|balance|balance-all",
    "column-gap": "normal|<length-percentage>",
    "column-rule": "<'column-rule-width'>||<'column-rule-style'>||<'column-rule-color'>",
    "column-rule-color": "<color>",
    "column-rule-style": "<'border-style'>",
    "column-rule-width": "<'border-width'>",
    "column-span": "none|all",
    "column-width": "<length>|auto",
    "columns": "<'column-width'>||<'column-count'>",
    "contain": "none|strict|content|[[size||inline-size]||layout||style||paint]",
    "contain-intrinsic-size": "[none|<length>|auto <length>]{1,2}",
    "contain-intrinsic-block-size": "none|<length>|auto <length>",
    "contain-intrinsic-height": "none|<length>|auto <length>",
    "contain-intrinsic-inline-size": "none|<length>|auto <length>",
    "contain-intrinsic-width": "none|<length>|auto <length>",
    "content": "normal|none|[<content-replacement>|<content-list>] [/ [<string>|<counter>]+]?",
    "content-visibility": "visible|auto|hidden",
    "counter-increment": "[<counter-name> <integer>?]+|none",
    "counter-reset": "[<counter-name> <integer>?|<reversed-counter-name> <integer>?]+|none",
    "counter-set": "[<counter-name> <integer>?]+|none",
    "cursor": "[[<url> [<x> <y>]? ,]* [auto|default|none|context-menu|help|pointer|progress|wait|cell|crosshair|text|vertical-text|alias|copy|move|no-drop|not-allowed|e-resize|n-resize|ne-resize|nw-resize|s-resize|se-resize|sw-resize|w-resize|ew-resize|ns-resize|nesw-resize|nwse-resize|col-resize|row-resize|all-scroll|zoom-in|zoom-out|grab|grabbing|hand|-webkit-grab|-webkit-grabbing|-webkit-zoom-in|-webkit-zoom-out|-moz-grab|-moz-grabbing|-moz-zoom-in|-moz-zoom-out]]",
    "direction": "ltr|rtl",
    "display": "[<display-outside>||<display-inside>]|<display-listitem>|<display-internal>|<display-box>|<display-legacy>|<-non-standard-display>",
    "empty-cells": "show|hide",
    "filter": "none|<filter-function-list>|<-ms-filter-function-list>",
    "flex": "none|[<'flex-grow'> <'flex-shrink'>?||<'flex-basis'>]",
    "flex-basis": "content|<'width'>",
    "flex-direction": "row|row-reverse|column|column-reverse",
    "flex-flow": "<'flex-direction'>||<'flex-wrap'>",
    "flex-grow": "<number>",
    "flex-shrink": "<number>",
    "flex-wrap": "nowrap|wrap|wrap-reverse",
    "float": "left|right|none|inline-start|inline-end",
    "font": "[[<'font-style'>||<font-variant-css21>||<'font-weight'>||<'font-stretch'>]? <'font-size'> [/ <'line-height'>]? <'font-family'>]|caption|icon|menu|message-box|small-caption|status-bar",
    "font-family": "[<family-name>|<generic-family>]#",
    "font-feature-settings": "normal|<feature-tag-value>#",
    "font-kerning": "auto|normal|none",
    "font-language-override": "normal|<string>",
    "font-optical-sizing": "auto|none",
    "font-variation-settings": "normal|[<string> <number>]#",
    "font-size": "<absolute-size>|<relative-size>|<length-percentage>",
    "font-size-adjust": "none|[ex-height|cap-height|ch-width|ic-width|ic-height]? [from-font|<number>]",
    "font-smooth": "auto|never|always|<absolute-size>|<length>",
    "font-stretch": "<font-stretch-absolute>",
    "font-style": "normal|italic|oblique <angle>?",
    "font-synthesis": "none|[weight||style||small-caps]",
    "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]",
    "font-variant-alternates": "normal|[stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )]",
    "font-variant-caps": "normal|small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps",
    "font-variant-east-asian": "normal|[<east-asian-variant-values>||<east-asian-width-values>||ruby]",
    "font-variant-ligatures": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>]",
    "font-variant-numeric": "normal|[<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero]",
    "font-variant-position": "normal|sub|super",
    "font-weight": "<font-weight-absolute>|bolder|lighter",
    "forced-color-adjust": "auto|none",
    "gap": "<'row-gap'> <'column-gap'>?",
    "grid": "<'grid-template'>|<'grid-template-rows'> / [auto-flow&&dense?] <'grid-auto-columns'>?|[auto-flow&&dense?] <'grid-auto-rows'>? / <'grid-template-columns'>",
    "grid-area": "<grid-line> [/ <grid-line>]{0,3}",
    "grid-auto-columns": "<track-size>+",
    "grid-auto-flow": "[row|column]||dense",
    "grid-auto-rows": "<track-size>+",
    "grid-column": "<grid-line> [/ <grid-line>]?",
    "grid-column-end": "<grid-line>",
    "grid-column-gap": "<length-percentage>",
    "grid-column-start": "<grid-line>",
    "grid-gap": "<'grid-row-gap'> <'grid-column-gap'>?",
    "grid-row": "<grid-line> [/ <grid-line>]?",
    "grid-row-end": "<grid-line>",
    "grid-row-gap": "<length-percentage>",
    "grid-row-start": "<grid-line>",
    "grid-template": "none|[<'grid-template-rows'> / <'grid-template-columns'>]|[<line-names>? <string> <track-size>? <line-names>?]+ [/ <explicit-track-list>]?",
    "grid-template-areas": "none|<string>+",
    "grid-template-columns": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
    "grid-template-rows": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
    "hanging-punctuation": "none|[first||[force-end|allow-end]||last]",
    "height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )",
    "hyphenate-character": "auto|<string>",
    "hyphens": "none|manual|auto",
    "image-orientation": "from-image|<angle>|[<angle>? flip]",
    "image-rendering": "auto|crisp-edges|pixelated|optimizeSpeed|optimizeQuality|<-non-standard-image-rendering>",
    "image-resolution": "[from-image||<resolution>]&&snap?",
    "ime-mode": "auto|normal|active|inactive|disabled",
    "initial-letter": "normal|[<number> <integer>?]",
    "initial-letter-align": "[auto|alphabetic|hanging|ideographic]",
    "inline-size": "<'width'>",
    "input-security": "auto|none",
    "inset": "<'top'>{1,4}",
    "inset-block": "<'top'>{1,2}",
    "inset-block-end": "<'top'>",
    "inset-block-start": "<'top'>",
    "inset-inline": "<'top'>{1,2}",
    "inset-inline-end": "<'top'>",
    "inset-inline-start": "<'top'>",
    "isolation": "auto|isolate",
    "justify-content": "normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]",
    "justify-items": "normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]|legacy|legacy&&[left|right|center]",
    "justify-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]",
    "justify-tracks": "[normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]]#",
    "left": "<length>|<percentage>|auto",
    "letter-spacing": "normal|<length-percentage>",
    "line-break": "auto|loose|normal|strict|anywhere",
    "line-clamp": "none|<integer>",
    "line-height": "normal|<number>|<length>|<percentage>",
    "line-height-step": "<length>",
    "list-style": "<'list-style-type'>||<'list-style-position'>||<'list-style-image'>",
    "list-style-image": "<image>|none",
    "list-style-position": "inside|outside",
    "list-style-type": "<counter-style>|<string>|none",
    "margin": "[<length>|<percentage>|auto]{1,4}",
    "margin-block": "<'margin-left'>{1,2}",
    "margin-block-end": "<'margin-left'>",
    "margin-block-start": "<'margin-left'>",
    "margin-bottom": "<length>|<percentage>|auto",
    "margin-inline": "<'margin-left'>{1,2}",
    "margin-inline-end": "<'margin-left'>",
    "margin-inline-start": "<'margin-left'>",
    "margin-left": "<length>|<percentage>|auto",
    "margin-right": "<length>|<percentage>|auto",
    "margin-top": "<length>|<percentage>|auto",
    "margin-trim": "none|in-flow|all",
    "mask": "<mask-layer>#",
    "mask-border": "<'mask-border-source'>||<'mask-border-slice'> [/ <'mask-border-width'>? [/ <'mask-border-outset'>]?]?||<'mask-border-repeat'>||<'mask-border-mode'>",
    "mask-border-mode": "luminance|alpha",
    "mask-border-outset": "[<length>|<number>]{1,4}",
    "mask-border-repeat": "[stretch|repeat|round|space]{1,2}",
    "mask-border-slice": "<number-percentage>{1,4} fill?",
    "mask-border-source": "none|<image>",
    "mask-border-width": "[<length-percentage>|<number>|auto]{1,4}",
    "mask-clip": "[<geometry-box>|no-clip]#",
    "mask-composite": "<compositing-operator>#",
    "mask-image": "<mask-reference>#",
    "mask-mode": "<masking-mode>#",
    "mask-origin": "<geometry-box>#",
    "mask-position": "<position>#",
    "mask-repeat": "<repeat-style>#",
    "mask-size": "<bg-size>#",
    "mask-type": "luminance|alpha",
    "masonry-auto-flow": "[pack|next]||[definite-first|ordered]",
    "math-depth": "auto-add|add( <integer> )|<integer>",
    "math-shift": "normal|compact",
    "math-style": "normal|compact",
    "max-block-size": "<'max-width'>",
    "max-height": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )",
    "max-inline-size": "<'max-width'>",
    "max-lines": "none|<integer>",
    "max-width": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|<-non-standard-width>",
    "min-block-size": "<'min-width'>",
    "min-height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )",
    "min-inline-size": "<'min-width'>",
    "min-width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|<-non-standard-width>",
    "mix-blend-mode": "<blend-mode>|plus-lighter",
    "object-fit": "fill|contain|cover|none|scale-down",
    "object-position": "<position>",
    "offset": "[<'offset-position'>? [<'offset-path'> [<'offset-distance'>||<'offset-rotate'>]?]?]! [/ <'offset-anchor'>]?",
    "offset-anchor": "auto|<position>",
    "offset-distance": "<length-percentage>",
    "offset-path": "none|ray( [<angle>&&<size>&&contain?] )|<path()>|<url>|[<basic-shape>||<geometry-box>]",
    "offset-position": "auto|<position>",
    "offset-rotate": "[auto|reverse]||<angle>",
    "opacity": "<alpha-value>",
    "order": "<integer>",
    "orphans": "<integer>",
    "outline": "[<'outline-color'>||<'outline-style'>||<'outline-width'>]",
    "outline-color": "<color>|invert",
    "outline-offset": "<length>",
    "outline-style": "auto|<'border-style'>",
    "outline-width": "<line-width>",
    "overflow": "[visible|hidden|clip|scroll|auto]{1,2}|<-non-standard-overflow>",
    "overflow-anchor": "auto|none",
    "overflow-block": "visible|hidden|clip|scroll|auto",
    "overflow-clip-box": "padding-box|content-box",
    "overflow-clip-margin": "<visual-box>||<length [0,∞]>",
    "overflow-inline": "visible|hidden|clip|scroll|auto",
    "overflow-wrap": "normal|break-word|anywhere",
    "overflow-x": "visible|hidden|clip|scroll|auto",
    "overflow-y": "visible|hidden|clip|scroll|auto",
    "overscroll-behavior": "[contain|none|auto]{1,2}",
    "overscroll-behavior-block": "contain|none|auto",
    "overscroll-behavior-inline": "contain|none|auto",
    "overscroll-behavior-x": "contain|none|auto",
    "overscroll-behavior-y": "contain|none|auto",
    "padding": "[<length>|<percentage>]{1,4}",
    "padding-block": "<'padding-left'>{1,2}",
    "padding-block-end": "<'padding-left'>",
    "padding-block-start": "<'padding-left'>",
    "padding-bottom": "<length>|<percentage>",
    "padding-inline": "<'padding-left'>{1,2}",
    "padding-inline-end": "<'padding-left'>",
    "padding-inline-start": "<'padding-left'>",
    "padding-left": "<length>|<percentage>",
    "padding-right": "<length>|<percentage>",
    "padding-top": "<length>|<percentage>",
    "page-break-after": "auto|always|avoid|left|right|recto|verso",
    "page-break-before": "auto|always|avoid|left|right|recto|verso",
    "page-break-inside": "auto|avoid",
    "paint-order": "normal|[fill||stroke||markers]",
    "perspective": "none|<length>",
    "perspective-origin": "<position>",
    "place-content": "<'align-content'> <'justify-content'>?",
    "place-items": "<'align-items'> <'justify-items'>?",
    "place-self": "<'align-self'> <'justify-self'>?",
    "pointer-events": "auto|none|visiblePainted|visibleFill|visibleStroke|visible|painted|fill|stroke|all|inherit",
    "position": "static|relative|absolute|sticky|fixed|-webkit-sticky",
    "quotes": "none|auto|[<string> <string>]+",
    "resize": "none|both|horizontal|vertical|block|inline",
    "right": "<length>|<percentage>|auto",
    "rotate": "none|<angle>|[x|y|z|<number>{3}]&&<angle>",
    "row-gap": "normal|<length-percentage>",
    "ruby-align": "start|center|space-between|space-around",
    "ruby-merge": "separate|collapse|auto",
    "ruby-position": "[alternate||[over|under]]|inter-character",
    "scale": "none|<number>{1,3}",
    "scrollbar-color": "auto|<color>{2}",
    "scrollbar-gutter": "auto|stable&&both-edges?",
    "scrollbar-width": "auto|thin|none",
    "scroll-behavior": "auto|smooth",
    "scroll-margin": "<length>{1,4}",
    "scroll-margin-block": "<length>{1,2}",
    "scroll-margin-block-start": "<length>",
    "scroll-margin-block-end": "<length>",
    "scroll-margin-bottom": "<length>",
    "scroll-margin-inline": "<length>{1,2}",
    "scroll-margin-inline-start": "<length>",
    "scroll-margin-inline-end": "<length>",
    "scroll-margin-left": "<length>",
    "scroll-margin-right": "<length>",
    "scroll-margin-top": "<length>",
    "scroll-padding": "[auto|<length-percentage>]{1,4}",
    "scroll-padding-block": "[auto|<length-percentage>]{1,2}",
    "scroll-padding-block-start": "auto|<length-percentage>",
    "scroll-padding-block-end": "auto|<length-percentage>",
    "scroll-padding-bottom": "auto|<length-percentage>",
    "scroll-padding-inline": "[auto|<length-percentage>]{1,2}",
    "scroll-padding-inline-start": "auto|<length-percentage>",
    "scroll-padding-inline-end": "auto|<length-percentage>",
    "scroll-padding-left": "auto|<length-percentage>",
    "scroll-padding-right": "auto|<length-percentage>",
    "scroll-padding-top": "auto|<length-percentage>",
    "scroll-snap-align": "[none|start|end|center]{1,2}",
    "scroll-snap-coordinate": "none|<position>#",
    "scroll-snap-destination": "<position>",
    "scroll-snap-points-x": "none|repeat( <length-percentage> )",
    "scroll-snap-points-y": "none|repeat( <length-percentage> )",
    "scroll-snap-stop": "normal|always",
    "scroll-snap-type": "none|[x|y|block|inline|both] [mandatory|proximity]?",
    "scroll-snap-type-x": "none|mandatory|proximity",
    "scroll-snap-type-y": "none|mandatory|proximity",
    "scroll-timeline": "<scroll-timeline-name>||<scroll-timeline-axis>",
    "scroll-timeline-axis": "block|inline|vertical|horizontal",
    "scroll-timeline-name": "none|<custom-ident>",
    "shape-image-threshold": "<alpha-value>",
    "shape-margin": "<length-percentage>",
    "shape-outside": "none|[<shape-box>||<basic-shape>]|<image>",
    "tab-size": "<integer>|<length>",
    "table-layout": "auto|fixed",
    "text-align": "start|end|left|right|center|justify|match-parent",
    "text-align-last": "auto|start|end|left|right|center|justify",
    "text-combine-upright": "none|all|[digits <integer>?]",
    "text-decoration": "<'text-decoration-line'>||<'text-decoration-style'>||<'text-decoration-color'>||<'text-decoration-thickness'>",
    "text-decoration-color": "<color>",
    "text-decoration-line": "none|[underline||overline||line-through||blink]|spelling-error|grammar-error",
    "text-decoration-skip": "none|[objects||[spaces|[leading-spaces||trailing-spaces]]||edges||box-decoration]",
    "text-decoration-skip-ink": "auto|all|none",
    "text-decoration-style": "solid|double|dotted|dashed|wavy",
    "text-decoration-thickness": "auto|from-font|<length>|<percentage>",
    "text-emphasis": "<'text-emphasis-style'>||<'text-emphasis-color'>",
    "text-emphasis-color": "<color>",
    "text-emphasis-position": "[over|under]&&[right|left]",
    "text-emphasis-style": "none|[[filled|open]||[dot|circle|double-circle|triangle|sesame]]|<string>",
    "text-indent": "<length-percentage>&&hanging?&&each-line?",
    "text-justify": "auto|inter-character|inter-word|none",
    "text-orientation": "mixed|upright|sideways",
    "text-overflow": "[clip|ellipsis|<string>]{1,2}",
    "text-rendering": "auto|optimizeSpeed|optimizeLegibility|geometricPrecision",
    "text-shadow": "none|<shadow-t>#",
    "text-size-adjust": "none|auto|<percentage>",
    "text-transform": "none|capitalize|uppercase|lowercase|full-width|full-size-kana",
    "text-underline-offset": "auto|<length>|<percentage>",
    "text-underline-position": "auto|from-font|[under||[left|right]]",
    "top": "<length>|<percentage>|auto",
    "touch-action": "auto|none|[[pan-x|pan-left|pan-right]||[pan-y|pan-up|pan-down]||pinch-zoom]|manipulation",
    "transform": "none|<transform-list>",
    "transform-box": "content-box|border-box|fill-box|stroke-box|view-box",
    "transform-origin": "[<length-percentage>|left|center|right|top|bottom]|[[<length-percentage>|left|center|right]&&[<length-percentage>|top|center|bottom]] <length>?",
    "transform-style": "flat|preserve-3d",
    "transition": "<single-transition>#",
    "transition-delay": "<time>#",
    "transition-duration": "<time>#",
    "transition-property": "none|<single-transition-property>#",
    "transition-timing-function": "<easing-function>#",
    "translate": "none|<length-percentage> [<length-percentage> <length>?]?",
    "unicode-bidi": "normal|embed|isolate|bidi-override|isolate-override|plaintext|-moz-isolate|-moz-isolate-override|-moz-plaintext|-webkit-isolate|-webkit-isolate-override|-webkit-plaintext",
    "user-select": "auto|text|none|contain|all",
    "vertical-align": "baseline|sub|super|text-top|text-bottom|middle|top|bottom|<percentage>|<length>",
    "visibility": "visible|hidden|collapse",
    "white-space": "normal|pre|nowrap|pre-wrap|pre-line|break-spaces",
    "widows": "<integer>",
    "width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|fill|stretch|intrinsic|-moz-max-content|-webkit-max-content|-moz-fit-content|-webkit-fit-content",
    "will-change": "auto|<animateable-feature>#",
    "word-break": "normal|break-all|keep-all|break-word",
    "word-spacing": "normal|<length>",
    "word-wrap": "normal|break-word",
    "writing-mode": "horizontal-tb|vertical-rl|vertical-lr|sideways-rl|sideways-lr|<svg-writing-mode>",
    "z-index": "auto|<integer>",
    "zoom": "normal|reset|<number>|<percentage>",
    "-moz-background-clip": "padding|border",
    "-moz-border-radius-bottomleft": "<'border-bottom-left-radius'>",
    "-moz-border-radius-bottomright": "<'border-bottom-right-radius'>",
    "-moz-border-radius-topleft": "<'border-top-left-radius'>",
    "-moz-border-radius-topright": "<'border-bottom-right-radius'>",
    "-moz-control-character-visibility": "visible|hidden",
    "-moz-osx-font-smoothing": "auto|grayscale",
    "-moz-user-select": "none|text|all|-moz-none",
    "-ms-flex-align": "start|end|center|baseline|stretch",
    "-ms-flex-item-align": "auto|start|end|center|baseline|stretch",
    "-ms-flex-line-pack": "start|end|center|justify|distribute|stretch",
    "-ms-flex-negative": "<'flex-shrink'>",
    "-ms-flex-pack": "start|end|center|justify|distribute",
    "-ms-flex-order": "<integer>",
    "-ms-flex-positive": "<'flex-grow'>",
    "-ms-flex-preferred-size": "<'flex-basis'>",
    "-ms-interpolation-mode": "nearest-neighbor|bicubic",
    "-ms-grid-column-align": "start|end|center|stretch",
    "-ms-grid-row-align": "start|end|center|stretch",
    "-ms-hyphenate-limit-last": "none|always|column|page|spread",
    "-webkit-background-clip": "[<box>|border|padding|content|text]#",
    "-webkit-column-break-after": "always|auto|avoid",
    "-webkit-column-break-before": "always|auto|avoid",
    "-webkit-column-break-inside": "always|auto|avoid",
    "-webkit-font-smoothing": "auto|none|antialiased|subpixel-antialiased",
    "-webkit-mask-box-image": "[<url>|<gradient>|none] [<length-percentage>{4} <-webkit-mask-box-repeat>{2}]?",
    "-webkit-print-color-adjust": "economy|exact",
    "-webkit-text-security": "none|circle|disc|square",
    "-webkit-user-drag": "none|element|auto",
    "-webkit-user-select": "auto|none|text|all",
    "alignment-baseline": "auto|baseline|before-edge|text-before-edge|middle|central|after-edge|text-after-edge|ideographic|alphabetic|hanging|mathematical",
    "baseline-shift": "baseline|sub|super|<svg-length>",
    "behavior": "<url>+",
    "clip-rule": "nonzero|evenodd",
    "cue": "<'cue-before'> <'cue-after'>?",
    "cue-after": "<url> <decibel>?|none",
    "cue-before": "<url> <decibel>?|none",
    "dominant-baseline": "auto|use-script|no-change|reset-size|ideographic|alphabetic|hanging|mathematical|central|middle|text-after-edge|text-before-edge",
    "fill": "<paint>",
    "fill-opacity": "<number-zero-one>",
    "fill-rule": "nonzero|evenodd",
    "glyph-orientation-horizontal": "<angle>",
    "glyph-orientation-vertical": "<angle>",
    "kerning": "auto|<svg-length>",
    "marker": "none|<url>",
    "marker-end": "none|<url>",
    "marker-mid": "none|<url>",
    "marker-start": "none|<url>",
    "pause": "<'pause-before'> <'pause-after'>?",
    "pause-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "pause-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "rest": "<'rest-before'> <'rest-after'>?",
    "rest-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "rest-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "shape-rendering": "auto|optimizeSpeed|crispEdges|geometricPrecision",
    "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
    "speak": "auto|none|normal",
    "speak-as": "normal|spell-out||digits||[literal-punctuation|no-punctuation]",
    "stroke": "<paint>",
    "stroke-dasharray": "none|[<svg-length>+]#",
    "stroke-dashoffset": "<svg-length>",
    "stroke-linecap": "butt|round|square",
    "stroke-linejoin": "miter|round|bevel",
    "stroke-miterlimit": "<number-one-or-greater>",
    "stroke-opacity": "<number-zero-one>",
    "stroke-width": "<svg-length>",
    "text-anchor": "start|middle|end",
    "unicode-range": "<urange>#",
    "voice-balance": "<number>|left|center|right|leftwards|rightwards",
    "voice-duration": "auto|<time>",
    "voice-family": "[[<family-name>|<generic-voice>] ,]* [<family-name>|<generic-voice>]|preserve",
    "voice-pitch": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
    "voice-range": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
    "voice-rate": "[normal|x-slow|slow|medium|fast|x-fast]||<percentage>",
    "voice-stress": "normal|strong|moderate|none|reduced",
    "voice-volume": "silent|[[x-soft|soft|medium|loud|x-loud]||<decibel>]"
  },
  "atrules": {
    "charset": {
      "prelude": "<string>",
      "descriptors": null
    },
    "counter-style": {
      "prelude": "<counter-style-name>",
      "descriptors": {
        "additive-symbols": "[<integer>&&<symbol>]#",
        "fallback": "<counter-style-name>",
        "negative": "<symbol> <symbol>?",
        "pad": "<integer>&&<symbol>",
        "prefix": "<symbol>",
        "range": "[[<integer>|infinite]{2}]#|auto",
        "speak-as": "auto|bullets|numbers|words|spell-out|<counter-style-name>",
        "suffix": "<symbol>",
        "symbols": "<symbol>+",
        "system": "cyclic|numeric|alphabetic|symbolic|additive|[fixed <integer>?]|[extends <counter-style-name>]"
      }
    },
    "document": {
      "prelude": "[<url>|url-prefix( <string> )|domain( <string> )|media-document( <string> )|regexp( <string> )]#",
      "descriptors": null
    },
    "font-face": {
      "prelude": null,
      "descriptors": {
        "ascent-override": "normal|<percentage>",
        "descent-override": "normal|<percentage>",
        "font-display": "[auto|block|swap|fallback|optional]",
        "font-family": "<family-name>",
        "font-feature-settings": "normal|<feature-tag-value>#",
        "font-variation-settings": "normal|[<string> <number>]#",
        "font-stretch": "<font-stretch-absolute>{1,2}",
        "font-style": "normal|italic|oblique <angle>{0,2}",
        "font-weight": "<font-weight-absolute>{1,2}",
        "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]",
        "line-gap-override": "normal|<percentage>",
        "size-adjust": "<percentage>",
        "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
        "unicode-range": "<urange>#"
      }
    },
    "font-feature-values": {
      "prelude": "<family-name>#",
      "descriptors": null
    },
    "import": {
      "prelude": "[<string>|<url>] [layer|layer( <layer-name> )]? [supports( [<supports-condition>|<declaration>] )]? <media-query-list>?",
      "descriptors": null
    },
    "keyframes": {
      "prelude": "<keyframes-name>",
      "descriptors": null
    },
    "layer": {
      "prelude": "[<layer-name>#|<layer-name>?]",
      "descriptors": null
    },
    "media": {
      "prelude": "<media-query-list>",
      "descriptors": null
    },
    "namespace": {
      "prelude": "<namespace-prefix>? [<string>|<url>]",
      "descriptors": null
    },
    "page": {
      "prelude": "<page-selector-list>",
      "descriptors": {
        "bleed": "auto|<length>",
        "marks": "none|[crop||cross]",
        "size": "<length>{1,2}|auto|[<page-size>||[portrait|landscape]]"
      }
    },
    "property": {
      "prelude": "<custom-property-name>",
      "descriptors": {
        "syntax": "<string>",
        "inherits": "true|false",
        "initial-value": "<string>"
      }
    },
    "scroll-timeline": {
      "prelude": "<timeline-name>",
      "descriptors": null
    },
    "supports": {
      "prelude": "<supports-condition>",
      "descriptors": null
    },
    "viewport": {
      "prelude": null,
      "descriptors": {
        "height": "<viewport-length>{1,2}",
        "max-height": "<viewport-length>",
        "max-width": "<viewport-length>",
        "max-zoom": "auto|<number>|<percentage>",
        "min-height": "<viewport-length>",
        "min-width": "<viewport-length>",
        "min-zoom": "auto|<number>|<percentage>",
        "orientation": "auto|portrait|landscape",
        "user-zoom": "zoom|fixed",
        "viewport-fit": "auto|contain|cover",
        "width": "<viewport-length>{1,2}",
        "zoom": "auto|<number>|<percentage>"
      }
    },
    "nest": {
      "prelude": "<complex-selector-list>",
      "descriptors": null
    }
  }
};

// node_modules/css-tree/lib/syntax/node/index.js
var node_exports = {};
__export(node_exports, {
  AnPlusB: () => AnPlusB_exports,
  Atrule: () => Atrule_exports,
  AtrulePrelude: () => AtrulePrelude_exports,
  AttributeSelector: () => AttributeSelector_exports,
  Block: () => Block_exports,
  Brackets: () => Brackets_exports,
  CDC: () => CDC_exports,
  CDO: () => CDO_exports,
  ClassSelector: () => ClassSelector_exports,
  Combinator: () => Combinator_exports,
  Comment: () => Comment_exports,
  Declaration: () => Declaration_exports,
  DeclarationList: () => DeclarationList_exports,
  Dimension: () => Dimension_exports,
  Function: () => Function_exports,
  Hash: () => Hash_exports,
  IdSelector: () => IdSelector_exports,
  Identifier: () => Identifier_exports,
  MediaFeature: () => MediaFeature_exports,
  MediaQuery: () => MediaQuery_exports,
  MediaQueryList: () => MediaQueryList_exports,
  NestingSelector: () => NestingSelector_exports,
  Nth: () => Nth_exports,
  Number: () => Number_exports,
  Operator: () => Operator_exports,
  Parentheses: () => Parentheses_exports,
  Percentage: () => Percentage_exports,
  PseudoClassSelector: () => PseudoClassSelector_exports,
  PseudoElementSelector: () => PseudoElementSelector_exports,
  Ratio: () => Ratio_exports,
  Raw: () => Raw_exports,
  Rule: () => Rule_exports,
  Selector: () => Selector_exports,
  SelectorList: () => SelectorList_exports,
  String: () => String_exports,
  StyleSheet: () => StyleSheet_exports,
  TypeSelector: () => TypeSelector_exports,
  UnicodeRange: () => UnicodeRange_exports,
  Url: () => Url_exports,
  Value: () => Value_exports,
  WhiteSpace: () => WhiteSpace_exports
});

// node_modules/css-tree/lib/syntax/node/AnPlusB.js
var AnPlusB_exports = {};
__export(AnPlusB_exports, {
  generate: () => generate2,
  name: () => name,
  parse: () => parse7,
  structure: () => structure
});
var PLUSSIGN5 = 43;
var HYPHENMINUS5 = 45;
var N5 = 110;
var DISALLOW_SIGN2 = true;
var ALLOW_SIGN2 = false;
function checkInteger2(offset2, disallowSign) {
  let pos = this.tokenStart + offset2;
  const code2 = this.charCodeAt(pos);
  if (code2 === PLUSSIGN5 || code2 === HYPHENMINUS5) {
    if (disallowSign) {
      this.error("Number sign is not allowed");
    }
    pos++;
  }
  for (; pos < this.tokenEnd; pos++) {
    if (!isDigit(this.charCodeAt(pos))) {
      this.error("Integer is expected", pos);
    }
  }
}
function checkTokenIsInteger(disallowSign) {
  return checkInteger2.call(this, 0, disallowSign);
}
function expectCharCode(offset2, code2) {
  if (!this.cmpChar(this.tokenStart + offset2, code2)) {
    let msg = "";
    switch (code2) {
      case N5:
        msg = "N is expected";
        break;
      case HYPHENMINUS5:
        msg = "HyphenMinus is expected";
        break;
    }
    this.error(msg, this.tokenStart + offset2);
  }
}
function consumeB2() {
  let offset2 = 0;
  let sign = 0;
  let type = this.tokenType;
  while (type === WhiteSpace || type === Comment) {
    type = this.lookupType(++offset2);
  }
  if (type !== Number2) {
    if (this.isDelim(PLUSSIGN5, offset2) || this.isDelim(HYPHENMINUS5, offset2)) {
      sign = this.isDelim(PLUSSIGN5, offset2) ? PLUSSIGN5 : HYPHENMINUS5;
      do {
        type = this.lookupType(++offset2);
      } while (type === WhiteSpace || type === Comment);
      if (type !== Number2) {
        this.skip(offset2);
        checkTokenIsInteger.call(this, DISALLOW_SIGN2);
      }
    } else {
      return null;
    }
  }
  if (offset2 > 0) {
    this.skip(offset2);
  }
  if (sign === 0) {
    type = this.charCodeAt(this.tokenStart);
    if (type !== PLUSSIGN5 && type !== HYPHENMINUS5) {
      this.error("Number sign is expected");
    }
  }
  checkTokenIsInteger.call(this, sign !== 0);
  return sign === HYPHENMINUS5 ? "-" + this.consume(Number2) : this.consume(Number2);
}
var name = "AnPlusB";
var structure = {
  a: [String, null],
  b: [String, null]
};
function parse7() {
  const start = this.tokenStart;
  let a = null;
  let b2 = null;
  if (this.tokenType === Number2) {
    checkTokenIsInteger.call(this, ALLOW_SIGN2);
    b2 = this.consume(Number2);
  } else if (this.tokenType === Ident && this.cmpChar(this.tokenStart, HYPHENMINUS5)) {
    a = "-1";
    expectCharCode.call(this, 1, N5);
    switch (this.tokenEnd - this.tokenStart) {
      case 2:
        this.next();
        b2 = consumeB2.call(this);
        break;
      case 3:
        expectCharCode.call(this, 2, HYPHENMINUS5);
        this.next();
        this.skipSC();
        checkTokenIsInteger.call(this, DISALLOW_SIGN2);
        b2 = "-" + this.consume(Number2);
        break;
      default:
        expectCharCode.call(this, 2, HYPHENMINUS5);
        checkInteger2.call(this, 3, DISALLOW_SIGN2);
        this.next();
        b2 = this.substrToCursor(start + 2);
    }
  } else if (this.tokenType === Ident || this.isDelim(PLUSSIGN5) && this.lookupType(1) === Ident) {
    let sign = 0;
    a = "1";
    if (this.isDelim(PLUSSIGN5)) {
      sign = 1;
      this.next();
    }
    expectCharCode.call(this, 0, N5);
    switch (this.tokenEnd - this.tokenStart) {
      case 1:
        this.next();
        b2 = consumeB2.call(this);
        break;
      case 2:
        expectCharCode.call(this, 1, HYPHENMINUS5);
        this.next();
        this.skipSC();
        checkTokenIsInteger.call(this, DISALLOW_SIGN2);
        b2 = "-" + this.consume(Number2);
        break;
      default:
        expectCharCode.call(this, 1, HYPHENMINUS5);
        checkInteger2.call(this, 2, DISALLOW_SIGN2);
        this.next();
        b2 = this.substrToCursor(start + sign + 1);
    }
  } else if (this.tokenType === Dimension) {
    const code2 = this.charCodeAt(this.tokenStart);
    const sign = code2 === PLUSSIGN5 || code2 === HYPHENMINUS5;
    let i = this.tokenStart + sign;
    for (; i < this.tokenEnd; i++) {
      if (!isDigit(this.charCodeAt(i))) {
        break;
      }
    }
    if (i === this.tokenStart + sign) {
      this.error("Integer is expected", this.tokenStart + sign);
    }
    expectCharCode.call(this, i - this.tokenStart, N5);
    a = this.substring(start, i);
    if (i + 1 === this.tokenEnd) {
      this.next();
      b2 = consumeB2.call(this);
    } else {
      expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS5);
      if (i + 2 === this.tokenEnd) {
        this.next();
        this.skipSC();
        checkTokenIsInteger.call(this, DISALLOW_SIGN2);
        b2 = "-" + this.consume(Number2);
      } else {
        checkInteger2.call(this, i - this.tokenStart + 2, DISALLOW_SIGN2);
        this.next();
        b2 = this.substrToCursor(i + 1);
      }
    }
  } else {
    this.error();
  }
  if (a !== null && a.charCodeAt(0) === PLUSSIGN5) {
    a = a.substr(1);
  }
  if (b2 !== null && b2.charCodeAt(0) === PLUSSIGN5) {
    b2 = b2.substr(1);
  }
  return {
    type: "AnPlusB",
    loc: this.getLocation(start, this.tokenStart),
    a,
    b: b2
  };
}
function generate2(node) {
  if (node.a) {
    const a = node.a === "+1" && "n" || node.a === "1" && "n" || node.a === "-1" && "-n" || node.a + "n";
    if (node.b) {
      const b2 = node.b[0] === "-" || node.b[0] === "+" ? node.b : "+" + node.b;
      this.tokenize(a + b2);
    } else {
      this.tokenize(a);
    }
  } else {
    this.tokenize(node.b);
  }
}

// node_modules/css-tree/lib/syntax/node/Atrule.js
var Atrule_exports = {};
__export(Atrule_exports, {
  generate: () => generate3,
  name: () => name2,
  parse: () => parse8,
  structure: () => structure2,
  walkContext: () => walkContext
});
function consumeRaw(startToken) {
  return this.Raw(startToken, this.consumeUntilLeftCurlyBracketOrSemicolon, true);
}
function isDeclarationBlockAtrule() {
  for (let offset2 = 1, type; type = this.lookupType(offset2); offset2++) {
    if (type === RightCurlyBracket) {
      return true;
    }
    if (type === LeftCurlyBracket || type === AtKeyword) {
      return false;
    }
  }
  return false;
}
var name2 = "Atrule";
var walkContext = "atrule";
var structure2 = {
  name: String,
  prelude: ["AtrulePrelude", "Raw", null],
  block: ["Block", null]
};
function parse8(isDeclaration = false) {
  const start = this.tokenStart;
  let name49;
  let nameLowerCase;
  let prelude = null;
  let block = null;
  this.eat(AtKeyword);
  name49 = this.substrToCursor(start + 1);
  nameLowerCase = name49.toLowerCase();
  this.skipSC();
  if (this.eof === false && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) {
    if (this.parseAtrulePrelude) {
      prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name49, isDeclaration), consumeRaw);
    } else {
      prelude = consumeRaw.call(this, this.tokenIndex);
    }
    this.skipSC();
  }
  switch (this.tokenType) {
    case Semicolon:
      this.next();
      break;
    case LeftCurlyBracket:
      if (hasOwnProperty.call(this.atrule, nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") {
        block = this.atrule[nameLowerCase].block.call(this, isDeclaration);
      } else {
        block = this.Block(isDeclarationBlockAtrule.call(this));
      }
      break;
  }
  return {
    type: "Atrule",
    loc: this.getLocation(start, this.tokenStart),
    name: name49,
    prelude,
    block
  };
}
function generate3(node) {
  this.token(AtKeyword, "@" + node.name);
  if (node.prelude !== null) {
    this.node(node.prelude);
  }
  if (node.block) {
    this.node(node.block);
  } else {
    this.token(Semicolon, ";");
  }
}

// node_modules/css-tree/lib/syntax/node/AtrulePrelude.js
var AtrulePrelude_exports = {};
__export(AtrulePrelude_exports, {
  generate: () => generate4,
  name: () => name3,
  parse: () => parse9,
  structure: () => structure3,
  walkContext: () => walkContext2
});
var name3 = "AtrulePrelude";
var walkContext2 = "atrulePrelude";
var structure3 = {
  children: [[]]
};
function parse9(name49) {
  let children = null;
  if (name49 !== null) {
    name49 = name49.toLowerCase();
  }
  this.skipSC();
  if (hasOwnProperty.call(this.atrule, name49) && typeof this.atrule[name49].prelude === "function") {
    children = this.atrule[name49].prelude.call(this);
  } else {
    children = this.readSequence(this.scope.AtrulePrelude);
  }
  this.skipSC();
  if (this.eof !== true && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) {
    this.error("Semicolon or block is expected");
  }
  return {
    type: "AtrulePrelude",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate4(node) {
  this.children(node);
}

// node_modules/css-tree/lib/syntax/node/AttributeSelector.js
var AttributeSelector_exports = {};
__export(AttributeSelector_exports, {
  generate: () => generate5,
  name: () => name4,
  parse: () => parse10,
  structure: () => structure4
});
var DOLLARSIGN = 36;
var ASTERISK2 = 42;
var EQUALSSIGN = 61;
var CIRCUMFLEXACCENT = 94;
var VERTICALLINE2 = 124;
var TILDE = 126;
function getAttributeName() {
  if (this.eof) {
    this.error("Unexpected end of input");
  }
  const start = this.tokenStart;
  let expectIdent = false;
  if (this.isDelim(ASTERISK2)) {
    expectIdent = true;
    this.next();
  } else if (!this.isDelim(VERTICALLINE2)) {
    this.eat(Ident);
  }
  if (this.isDelim(VERTICALLINE2)) {
    if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {
      this.next();
      this.eat(Ident);
    } else if (expectIdent) {
      this.error("Identifier is expected", this.tokenEnd);
    }
  } else if (expectIdent) {
    this.error("Vertical line is expected");
  }
  return {
    type: "Identifier",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start)
  };
}
function getOperator() {
  const start = this.tokenStart;
  const code2 = this.charCodeAt(start);
  if (code2 !== EQUALSSIGN && // =
  code2 !== TILDE && // ~=
  code2 !== CIRCUMFLEXACCENT && // ^=
  code2 !== DOLLARSIGN && // $=
  code2 !== ASTERISK2 && // *=
  code2 !== VERTICALLINE2) {
    this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
  }
  this.next();
  if (code2 !== EQUALSSIGN) {
    if (!this.isDelim(EQUALSSIGN)) {
      this.error("Equal sign is expected");
    }
    this.next();
  }
  return this.substrToCursor(start);
}
var name4 = "AttributeSelector";
var structure4 = {
  name: "Identifier",
  matcher: [String, null],
  value: ["String", "Identifier", null],
  flags: [String, null]
};
function parse10() {
  const start = this.tokenStart;
  let name49;
  let matcher = null;
  let value = null;
  let flags = null;
  this.eat(LeftSquareBracket);
  this.skipSC();
  name49 = getAttributeName.call(this);
  this.skipSC();
  if (this.tokenType !== RightSquareBracket) {
    if (this.tokenType !== Ident) {
      matcher = getOperator.call(this);
      this.skipSC();
      value = this.tokenType === String2 ? this.String() : this.Identifier();
      this.skipSC();
    }
    if (this.tokenType === Ident) {
      flags = this.consume(Ident);
      this.skipSC();
    }
  }
  this.eat(RightSquareBracket);
  return {
    type: "AttributeSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: name49,
    matcher,
    value,
    flags
  };
}
function generate5(node) {
  this.token(Delim, "[");
  this.node(node.name);
  if (node.matcher !== null) {
    this.tokenize(node.matcher);
    this.node(node.value);
  }
  if (node.flags !== null) {
    this.token(Ident, node.flags);
  }
  this.token(Delim, "]");
}

// node_modules/css-tree/lib/syntax/node/Block.js
var Block_exports = {};
__export(Block_exports, {
  generate: () => generate6,
  name: () => name5,
  parse: () => parse11,
  structure: () => structure5,
  walkContext: () => walkContext3
});
var AMPERSAND2 = 38;
function consumeRaw2(startToken) {
  return this.Raw(startToken, null, true);
}
function consumeRule() {
  return this.parseWithFallback(this.Rule, consumeRaw2);
}
function consumeRawDeclaration(startToken) {
  return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
}
function consumeDeclaration() {
  if (this.tokenType === Semicolon) {
    return consumeRawDeclaration.call(this, this.tokenIndex);
  }
  const node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
  if (this.tokenType === Semicolon) {
    this.next();
  }
  return node;
}
var name5 = "Block";
var walkContext3 = "block";
var structure5 = {
  children: [[
    "Atrule",
    "Rule",
    "Declaration"
  ]]
};
function parse11(isStyleBlock) {
  const consumer = isStyleBlock ? consumeDeclaration : consumeRule;
  const start = this.tokenStart;
  let children = this.createList();
  this.eat(LeftCurlyBracket);
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case RightCurlyBracket:
          break scan;
        case WhiteSpace:
        case Comment:
          this.next();
          break;
        case AtKeyword:
          children.push(this.parseWithFallback(this.Atrule.bind(this, isStyleBlock), consumeRaw2));
          break;
        default:
          if (isStyleBlock && this.isDelim(AMPERSAND2)) {
            children.push(consumeRule.call(this));
          } else {
            children.push(consumer.call(this));
          }
      }
    }
  if (!this.eof) {
    this.eat(RightCurlyBracket);
  }
  return {
    type: "Block",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate6(node) {
  this.token(LeftCurlyBracket, "{");
  this.children(node, (prev) => {
    if (prev.type === "Declaration") {
      this.token(Semicolon, ";");
    }
  });
  this.token(RightCurlyBracket, "}");
}

// node_modules/css-tree/lib/syntax/node/Brackets.js
var Brackets_exports = {};
__export(Brackets_exports, {
  generate: () => generate7,
  name: () => name6,
  parse: () => parse12,
  structure: () => structure6
});
var name6 = "Brackets";
var structure6 = {
  children: [[]]
};
function parse12(readSequence3, recognizer) {
  const start = this.tokenStart;
  let children = null;
  this.eat(LeftSquareBracket);
  children = readSequence3.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightSquareBracket);
  }
  return {
    type: "Brackets",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate7(node) {
  this.token(Delim, "[");
  this.children(node);
  this.token(Delim, "]");
}

// node_modules/css-tree/lib/syntax/node/CDC.js
var CDC_exports = {};
__export(CDC_exports, {
  generate: () => generate8,
  name: () => name7,
  parse: () => parse13,
  structure: () => structure7
});
var name7 = "CDC";
var structure7 = [];
function parse13() {
  const start = this.tokenStart;
  this.eat(CDC);
  return {
    type: "CDC",
    loc: this.getLocation(start, this.tokenStart)
  };
}
function generate8() {
  this.token(CDC, "-->");
}

// node_modules/css-tree/lib/syntax/node/CDO.js
var CDO_exports = {};
__export(CDO_exports, {
  generate: () => generate9,
  name: () => name8,
  parse: () => parse14,
  structure: () => structure8
});
var name8 = "CDO";
var structure8 = [];
function parse14() {
  const start = this.tokenStart;
  this.eat(CDO);
  return {
    type: "CDO",
    loc: this.getLocation(start, this.tokenStart)
  };
}
function generate9() {
  this.token(CDO, "<!--");
}

// node_modules/css-tree/lib/syntax/node/ClassSelector.js
var ClassSelector_exports = {};
__export(ClassSelector_exports, {
  generate: () => generate10,
  name: () => name9,
  parse: () => parse15,
  structure: () => structure9
});
var FULLSTOP = 46;
var name9 = "ClassSelector";
var structure9 = {
  name: String
};
function parse15() {
  this.eatDelim(FULLSTOP);
  return {
    type: "ClassSelector",
    loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
    name: this.consume(Ident)
  };
}
function generate10(node) {
  this.token(Delim, ".");
  this.token(Ident, node.name);
}

// node_modules/css-tree/lib/syntax/node/Combinator.js
var Combinator_exports = {};
__export(Combinator_exports, {
  generate: () => generate11,
  name: () => name10,
  parse: () => parse16,
  structure: () => structure10
});
var PLUSSIGN6 = 43;
var SOLIDUS = 47;
var GREATERTHANSIGN2 = 62;
var TILDE2 = 126;
var name10 = "Combinator";
var structure10 = {
  name: String
};
function parse16() {
  const start = this.tokenStart;
  let name49;
  switch (this.tokenType) {
    case WhiteSpace:
      name49 = " ";
      break;
    case Delim:
      switch (this.charCodeAt(this.tokenStart)) {
        case GREATERTHANSIGN2:
        case PLUSSIGN6:
        case TILDE2:
          this.next();
          break;
        case SOLIDUS:
          this.next();
          this.eatIdent("deep");
          this.eatDelim(SOLIDUS);
          break;
        default:
          this.error("Combinator is expected");
      }
      name49 = this.substrToCursor(start);
      break;
  }
  return {
    type: "Combinator",
    loc: this.getLocation(start, this.tokenStart),
    name: name49
  };
}
function generate11(node) {
  this.tokenize(node.name);
}

// node_modules/css-tree/lib/syntax/node/Comment.js
var Comment_exports = {};
__export(Comment_exports, {
  generate: () => generate12,
  name: () => name11,
  parse: () => parse17,
  structure: () => structure11
});
var ASTERISK3 = 42;
var SOLIDUS2 = 47;
var name11 = "Comment";
var structure11 = {
  value: String
};
function parse17() {
  const start = this.tokenStart;
  let end = this.tokenEnd;
  this.eat(Comment);
  if (end - start + 2 >= 2 && this.charCodeAt(end - 2) === ASTERISK3 && this.charCodeAt(end - 1) === SOLIDUS2) {
    end -= 2;
  }
  return {
    type: "Comment",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substring(start + 2, end)
  };
}
function generate12(node) {
  this.token(Comment, "/*" + node.value + "*/");
}

// node_modules/css-tree/lib/syntax/node/Declaration.js
var Declaration_exports = {};
__export(Declaration_exports, {
  generate: () => generate13,
  name: () => name12,
  parse: () => parse18,
  structure: () => structure12,
  walkContext: () => walkContext4
});
var EXCLAMATIONMARK3 = 33;
var NUMBERSIGN3 = 35;
var DOLLARSIGN2 = 36;
var AMPERSAND3 = 38;
var ASTERISK4 = 42;
var PLUSSIGN7 = 43;
var SOLIDUS3 = 47;
function consumeValueRaw(startToken) {
  return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, true);
}
function consumeCustomPropertyRaw(startToken) {
  return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, false);
}
function consumeValue() {
  const startValueToken = this.tokenIndex;
  const value = this.Value();
  if (value.type !== "Raw" && this.eof === false && this.tokenType !== Semicolon && this.isDelim(EXCLAMATIONMARK3) === false && this.isBalanceEdge(startValueToken) === false) {
    this.error();
  }
  return value;
}
var name12 = "Declaration";
var walkContext4 = "declaration";
var structure12 = {
  important: [Boolean, String],
  property: String,
  value: ["Value", "Raw"]
};
function parse18() {
  const start = this.tokenStart;
  const startToken = this.tokenIndex;
  const property2 = readProperty2.call(this);
  const customProperty = isCustomProperty(property2);
  const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
  const consumeRaw7 = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
  let important = false;
  let value;
  this.skipSC();
  this.eat(Colon);
  const valueStart = this.tokenIndex;
  if (!customProperty) {
    this.skipSC();
  }
  if (parseValue) {
    value = this.parseWithFallback(consumeValue, consumeRaw7);
  } else {
    value = consumeRaw7.call(this, this.tokenIndex);
  }
  if (customProperty && value.type === "Value" && value.children.isEmpty) {
    for (let offset2 = valueStart - this.tokenIndex; offset2 <= 0; offset2++) {
      if (this.lookupType(offset2) === WhiteSpace) {
        value.children.appendData({
          type: "WhiteSpace",
          loc: null,
          value: " "
        });
        break;
      }
    }
  }
  if (this.isDelim(EXCLAMATIONMARK3)) {
    important = getImportant.call(this);
    this.skipSC();
  }
  if (this.eof === false && this.tokenType !== Semicolon && this.isBalanceEdge(startToken) === false) {
    this.error();
  }
  return {
    type: "Declaration",
    loc: this.getLocation(start, this.tokenStart),
    important,
    property: property2,
    value
  };
}
function generate13(node) {
  this.token(Ident, node.property);
  this.token(Colon, ":");
  this.node(node.value);
  if (node.important) {
    this.token(Delim, "!");
    this.token(Ident, node.important === true ? "important" : node.important);
  }
}
function readProperty2() {
  const start = this.tokenStart;
  if (this.tokenType === Delim) {
    switch (this.charCodeAt(this.tokenStart)) {
      case ASTERISK4:
      case DOLLARSIGN2:
      case PLUSSIGN7:
      case NUMBERSIGN3:
      case AMPERSAND3:
        this.next();
        break;
      case SOLIDUS3:
        this.next();
        if (this.isDelim(SOLIDUS3)) {
          this.next();
        }
        break;
    }
  }
  if (this.tokenType === Hash) {
    this.eat(Hash);
  } else {
    this.eat(Ident);
  }
  return this.substrToCursor(start);
}
function getImportant() {
  this.eat(Delim);
  this.skipSC();
  const important = this.consume(Ident);
  return important === "important" ? true : important;
}

// node_modules/css-tree/lib/syntax/node/DeclarationList.js
var DeclarationList_exports = {};
__export(DeclarationList_exports, {
  generate: () => generate14,
  name: () => name13,
  parse: () => parse19,
  structure: () => structure13
});
var AMPERSAND4 = 38;
function consumeRaw3(startToken) {
  return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
}
var name13 = "DeclarationList";
var structure13 = {
  children: [[
    "Declaration",
    "Atrule",
    "Rule"
  ]]
};
function parse19() {
  const children = this.createList();
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case WhiteSpace:
        case Comment:
        case Semicolon:
          this.next();
          break;
        case AtKeyword:
          children.push(this.parseWithFallback(this.Atrule.bind(this, true), consumeRaw3));
          break;
        default:
          if (this.isDelim(AMPERSAND4)) {
            children.push(this.parseWithFallback(this.Rule, consumeRaw3));
          } else {
            children.push(this.parseWithFallback(this.Declaration, consumeRaw3));
          }
      }
    }
  return {
    type: "DeclarationList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate14(node) {
  this.children(node, (prev) => {
    if (prev.type === "Declaration") {
      this.token(Semicolon, ";");
    }
  });
}

// node_modules/css-tree/lib/syntax/node/Dimension.js
var Dimension_exports = {};
__export(Dimension_exports, {
  generate: () => generate15,
  name: () => name14,
  parse: () => parse20,
  structure: () => structure14
});
var name14 = "Dimension";
var structure14 = {
  value: String,
  unit: String
};
function parse20() {
  const start = this.tokenStart;
  const value = this.consumeNumber(Dimension);
  return {
    type: "Dimension",
    loc: this.getLocation(start, this.tokenStart),
    value,
    unit: this.substring(start + value.length, this.tokenStart)
  };
}
function generate15(node) {
  this.token(Dimension, node.value + node.unit);
}

// node_modules/css-tree/lib/syntax/node/Function.js
var Function_exports = {};
__export(Function_exports, {
  generate: () => generate16,
  name: () => name15,
  parse: () => parse21,
  structure: () => structure15,
  walkContext: () => walkContext5
});
var name15 = "Function";
var walkContext5 = "function";
var structure15 = {
  name: String,
  children: [[]]
};
function parse21(readSequence3, recognizer) {
  const start = this.tokenStart;
  const name49 = this.consumeFunctionName();
  const nameLowerCase = name49.toLowerCase();
  let children;
  children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence3.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "Function",
    loc: this.getLocation(start, this.tokenStart),
    name: name49,
    children
  };
}
function generate16(node) {
  this.token(Function2, node.name + "(");
  this.children(node);
  this.token(RightParenthesis, ")");
}

// node_modules/css-tree/lib/syntax/node/Hash.js
var Hash_exports = {};
__export(Hash_exports, {
  generate: () => generate17,
  name: () => name16,
  parse: () => parse22,
  structure: () => structure16,
  xxx: () => xxx
});
var xxx = "XXX";
var name16 = "Hash";
var structure16 = {
  value: String
};
function parse22() {
  const start = this.tokenStart;
  this.eat(Hash);
  return {
    type: "Hash",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start + 1)
  };
}
function generate17(node) {
  this.token(Hash, "#" + node.value);
}

// node_modules/css-tree/lib/syntax/node/Identifier.js
var Identifier_exports = {};
__export(Identifier_exports, {
  generate: () => generate18,
  name: () => name17,
  parse: () => parse23,
  structure: () => structure17
});
var name17 = "Identifier";
var structure17 = {
  name: String
};
function parse23() {
  return {
    type: "Identifier",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    name: this.consume(Ident)
  };
}
function generate18(node) {
  this.token(Ident, node.name);
}

// node_modules/css-tree/lib/syntax/node/IdSelector.js
var IdSelector_exports = {};
__export(IdSelector_exports, {
  generate: () => generate19,
  name: () => name18,
  parse: () => parse24,
  structure: () => structure18
});
var name18 = "IdSelector";
var structure18 = {
  name: String
};
function parse24() {
  const start = this.tokenStart;
  this.eat(Hash);
  return {
    type: "IdSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start + 1)
  };
}
function generate19(node) {
  this.token(Delim, "#" + node.name);
}

// node_modules/css-tree/lib/syntax/node/MediaFeature.js
var MediaFeature_exports = {};
__export(MediaFeature_exports, {
  generate: () => generate20,
  name: () => name19,
  parse: () => parse25,
  structure: () => structure19
});
var name19 = "MediaFeature";
var structure19 = {
  name: String,
  value: ["Identifier", "Number", "Dimension", "Ratio", null]
};
function parse25() {
  const start = this.tokenStart;
  let name49;
  let value = null;
  this.eat(LeftParenthesis);
  this.skipSC();
  name49 = this.consume(Ident);
  this.skipSC();
  if (this.tokenType !== RightParenthesis) {
    this.eat(Colon);
    this.skipSC();
    switch (this.tokenType) {
      case Number2:
        if (this.lookupNonWSType(1) === Delim) {
          value = this.Ratio();
        } else {
          value = this.Number();
        }
        break;
      case Dimension:
        value = this.Dimension();
        break;
      case Ident:
        value = this.Identifier();
        break;
      default:
        this.error("Number, dimension, ratio or identifier is expected");
    }
    this.skipSC();
  }
  this.eat(RightParenthesis);
  return {
    type: "MediaFeature",
    loc: this.getLocation(start, this.tokenStart),
    name: name49,
    value
  };
}
function generate20(node) {
  this.token(LeftParenthesis, "(");
  this.token(Ident, node.name);
  if (node.value !== null) {
    this.token(Colon, ":");
    this.node(node.value);
  }
  this.token(RightParenthesis, ")");
}

// node_modules/css-tree/lib/syntax/node/MediaQuery.js
var MediaQuery_exports = {};
__export(MediaQuery_exports, {
  generate: () => generate21,
  name: () => name20,
  parse: () => parse26,
  structure: () => structure20
});
var name20 = "MediaQuery";
var structure20 = {
  children: [[
    "Identifier",
    "MediaFeature",
    "WhiteSpace"
  ]]
};
function parse26() {
  const children = this.createList();
  let child = null;
  this.skipSC();
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case Comment:
        case WhiteSpace:
          this.next();
          continue;
        case Ident:
          child = this.Identifier();
          break;
        case LeftParenthesis:
          child = this.MediaFeature();
          break;
        default:
          break scan;
      }
      children.push(child);
    }
  if (child === null) {
    this.error("Identifier or parenthesis is expected");
  }
  return {
    type: "MediaQuery",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate21(node) {
  this.children(node);
}

// node_modules/css-tree/lib/syntax/node/MediaQueryList.js
var MediaQueryList_exports = {};
__export(MediaQueryList_exports, {
  generate: () => generate22,
  name: () => name21,
  parse: () => parse27,
  structure: () => structure21
});
var name21 = "MediaQueryList";
var structure21 = {
  children: [[
    "MediaQuery"
  ]]
};
function parse27() {
  const children = this.createList();
  this.skipSC();
  while (!this.eof) {
    children.push(this.MediaQuery());
    if (this.tokenType !== Comma) {
      break;
    }
    this.next();
  }
  return {
    type: "MediaQueryList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate22(node) {
  this.children(node, () => this.token(Comma, ","));
}

// node_modules/css-tree/lib/syntax/node/NestingSelector.js
var NestingSelector_exports = {};
__export(NestingSelector_exports, {
  generate: () => generate23,
  name: () => name22,
  parse: () => parse28,
  structure: () => structure22
});
var AMPERSAND5 = 38;
var name22 = "NestingSelector";
var structure22 = {};
function parse28() {
  const start = this.tokenStart;
  this.eatDelim(AMPERSAND5);
  return {
    type: "NestingSelector",
    loc: this.getLocation(start, this.tokenStart)
  };
}
function generate23() {
  this.token(Delim, "&");
}

// node_modules/css-tree/lib/syntax/node/Nth.js
var Nth_exports = {};
__export(Nth_exports, {
  generate: () => generate24,
  name: () => name23,
  parse: () => parse29,
  structure: () => structure23
});
var name23 = "Nth";
var structure23 = {
  nth: ["AnPlusB", "Identifier"],
  selector: ["SelectorList", null]
};
function parse29() {
  this.skipSC();
  const start = this.tokenStart;
  let end = start;
  let selector2 = null;
  let nth2;
  if (this.lookupValue(0, "odd") || this.lookupValue(0, "even")) {
    nth2 = this.Identifier();
  } else {
    nth2 = this.AnPlusB();
  }
  end = this.tokenStart;
  this.skipSC();
  if (this.lookupValue(0, "of")) {
    this.next();
    selector2 = this.SelectorList();
    end = this.tokenStart;
  }
  return {
    type: "Nth",
    loc: this.getLocation(start, end),
    nth: nth2,
    selector: selector2
  };
}
function generate24(node) {
  this.node(node.nth);
  if (node.selector !== null) {
    this.token(Ident, "of");
    this.node(node.selector);
  }
}

// node_modules/css-tree/lib/syntax/node/Number.js
var Number_exports = {};
__export(Number_exports, {
  generate: () => generate25,
  name: () => name24,
  parse: () => parse30,
  structure: () => structure24
});
var name24 = "Number";
var structure24 = {
  value: String
};
function parse30() {
  return {
    type: "Number",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: this.consume(Number2)
  };
}
function generate25(node) {
  this.token(Number2, node.value);
}

// node_modules/css-tree/lib/syntax/node/Operator.js
var Operator_exports = {};
__export(Operator_exports, {
  generate: () => generate26,
  name: () => name25,
  parse: () => parse31,
  structure: () => structure25
});
var name25 = "Operator";
var structure25 = {
  value: String
};
function parse31() {
  const start = this.tokenStart;
  this.next();
  return {
    type: "Operator",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start)
  };
}
function generate26(node) {
  this.tokenize(node.value);
}

// node_modules/css-tree/lib/syntax/node/Parentheses.js
var Parentheses_exports = {};
__export(Parentheses_exports, {
  generate: () => generate27,
  name: () => name26,
  parse: () => parse32,
  structure: () => structure26
});
var name26 = "Parentheses";
var structure26 = {
  children: [[]]
};
function parse32(readSequence3, recognizer) {
  const start = this.tokenStart;
  let children = null;
  this.eat(LeftParenthesis);
  children = readSequence3.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "Parentheses",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate27(node) {
  this.token(LeftParenthesis, "(");
  this.children(node);
  this.token(RightParenthesis, ")");
}

// node_modules/css-tree/lib/syntax/node/Percentage.js
var Percentage_exports = {};
__export(Percentage_exports, {
  generate: () => generate28,
  name: () => name27,
  parse: () => parse33,
  structure: () => structure27
});
var name27 = "Percentage";
var structure27 = {
  value: String
};
function parse33() {
  return {
    type: "Percentage",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: this.consumeNumber(Percentage)
  };
}
function generate28(node) {
  this.token(Percentage, node.value + "%");
}

// node_modules/css-tree/lib/syntax/node/PseudoClassSelector.js
var PseudoClassSelector_exports = {};
__export(PseudoClassSelector_exports, {
  generate: () => generate29,
  name: () => name28,
  parse: () => parse34,
  structure: () => structure28,
  walkContext: () => walkContext6
});
var name28 = "PseudoClassSelector";
var walkContext6 = "function";
var structure28 = {
  name: String,
  children: [["Raw"], null]
};
function parse34() {
  const start = this.tokenStart;
  let children = null;
  let name49;
  let nameLowerCase;
  this.eat(Colon);
  if (this.tokenType === Function2) {
    name49 = this.consumeFunctionName();
    nameLowerCase = name49.toLowerCase();
    if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
      this.skipSC();
      children = this.pseudo[nameLowerCase].call(this);
      this.skipSC();
    } else {
      children = this.createList();
      children.push(
        this.Raw(this.tokenIndex, null, false)
      );
    }
    this.eat(RightParenthesis);
  } else {
    name49 = this.consume(Ident);
  }
  return {
    type: "PseudoClassSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: name49,
    children
  };
}
function generate29(node) {
  this.token(Colon, ":");
  if (node.children === null) {
    this.token(Ident, node.name);
  } else {
    this.token(Function2, node.name + "(");
    this.children(node);
    this.token(RightParenthesis, ")");
  }
}

// node_modules/css-tree/lib/syntax/node/PseudoElementSelector.js
var PseudoElementSelector_exports = {};
__export(PseudoElementSelector_exports, {
  generate: () => generate30,
  name: () => name29,
  parse: () => parse35,
  structure: () => structure29,
  walkContext: () => walkContext7
});
var name29 = "PseudoElementSelector";
var walkContext7 = "function";
var structure29 = {
  name: String,
  children: [["Raw"], null]
};
function parse35() {
  const start = this.tokenStart;
  let children = null;
  let name49;
  let nameLowerCase;
  this.eat(Colon);
  this.eat(Colon);
  if (this.tokenType === Function2) {
    name49 = this.consumeFunctionName();
    nameLowerCase = name49.toLowerCase();
    if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
      this.skipSC();
      children = this.pseudo[nameLowerCase].call(this);
      this.skipSC();
    } else {
      children = this.createList();
      children.push(
        this.Raw(this.tokenIndex, null, false)
      );
    }
    this.eat(RightParenthesis);
  } else {
    name49 = this.consume(Ident);
  }
  return {
    type: "PseudoElementSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: name49,
    children
  };
}
function generate30(node) {
  this.token(Colon, ":");
  this.token(Colon, ":");
  if (node.children === null) {
    this.token(Ident, node.name);
  } else {
    this.token(Function2, node.name + "(");
    this.children(node);
    this.token(RightParenthesis, ")");
  }
}

// node_modules/css-tree/lib/syntax/node/Ratio.js
var Ratio_exports = {};
__export(Ratio_exports, {
  generate: () => generate31,
  name: () => name30,
  parse: () => parse36,
  structure: () => structure30
});
var SOLIDUS4 = 47;
var FULLSTOP2 = 46;
function consumeNumber2() {
  this.skipSC();
  const value = this.consume(Number2);
  for (let i = 0; i < value.length; i++) {
    const code2 = value.charCodeAt(i);
    if (!isDigit(code2) && code2 !== FULLSTOP2) {
      this.error("Unsigned number is expected", this.tokenStart - value.length + i);
    }
  }
  if (Number(value) === 0) {
    this.error("Zero number is not allowed", this.tokenStart - value.length);
  }
  return value;
}
var name30 = "Ratio";
var structure30 = {
  left: String,
  right: String
};
function parse36() {
  const start = this.tokenStart;
  const left = consumeNumber2.call(this);
  let right;
  this.skipSC();
  this.eatDelim(SOLIDUS4);
  right = consumeNumber2.call(this);
  return {
    type: "Ratio",
    loc: this.getLocation(start, this.tokenStart),
    left,
    right
  };
}
function generate31(node) {
  this.token(Number2, node.left);
  this.token(Delim, "/");
  this.token(Number2, node.right);
}

// node_modules/css-tree/lib/syntax/node/Raw.js
var Raw_exports = {};
__export(Raw_exports, {
  generate: () => generate32,
  name: () => name31,
  parse: () => parse37,
  structure: () => structure31
});
function getOffsetExcludeWS() {
  if (this.tokenIndex > 0) {
    if (this.lookupType(-1) === WhiteSpace) {
      return this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset;
    }
  }
  return this.tokenStart;
}
var name31 = "Raw";
var structure31 = {
  value: String
};
function parse37(startToken, consumeUntil, excludeWhiteSpace) {
  const startOffset = this.getTokenStart(startToken);
  let endOffset;
  this.skipUntilBalanced(startToken, consumeUntil || this.consumeUntilBalanceEnd);
  if (excludeWhiteSpace && this.tokenStart > startOffset) {
    endOffset = getOffsetExcludeWS.call(this);
  } else {
    endOffset = this.tokenStart;
  }
  return {
    type: "Raw",
    loc: this.getLocation(startOffset, endOffset),
    value: this.substring(startOffset, endOffset)
  };
}
function generate32(node) {
  this.tokenize(node.value);
}

// node_modules/css-tree/lib/syntax/node/Rule.js
var Rule_exports = {};
__export(Rule_exports, {
  generate: () => generate33,
  name: () => name32,
  parse: () => parse38,
  structure: () => structure32,
  walkContext: () => walkContext8
});
function consumeRaw4(startToken) {
  return this.Raw(startToken, this.consumeUntilLeftCurlyBracket, true);
}
function consumePrelude() {
  const prelude = this.SelectorList();
  if (prelude.type !== "Raw" && this.eof === false && this.tokenType !== LeftCurlyBracket) {
    this.error();
  }
  return prelude;
}
var name32 = "Rule";
var walkContext8 = "rule";
var structure32 = {
  prelude: ["SelectorList", "Raw"],
  block: ["Block"]
};
function parse38() {
  const startToken = this.tokenIndex;
  const startOffset = this.tokenStart;
  let prelude;
  let block;
  if (this.parseRulePrelude) {
    prelude = this.parseWithFallback(consumePrelude, consumeRaw4);
  } else {
    prelude = consumeRaw4.call(this, startToken);
  }
  block = this.Block(true);
  return {
    type: "Rule",
    loc: this.getLocation(startOffset, this.tokenStart),
    prelude,
    block
  };
}
function generate33(node) {
  this.node(node.prelude);
  this.node(node.block);
}

// node_modules/css-tree/lib/syntax/node/Selector.js
var Selector_exports = {};
__export(Selector_exports, {
  generate: () => generate34,
  name: () => name33,
  parse: () => parse39,
  structure: () => structure33
});
var name33 = "Selector";
var structure33 = {
  children: [[
    "TypeSelector",
    "IdSelector",
    "ClassSelector",
    "AttributeSelector",
    "PseudoClassSelector",
    "PseudoElementSelector",
    "Combinator",
    "WhiteSpace"
  ]]
};
function parse39() {
  const children = this.readSequence(this.scope.Selector);
  if (this.getFirstListNode(children) === null) {
    this.error("Selector is expected");
  }
  return {
    type: "Selector",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate34(node) {
  this.children(node);
}

// node_modules/css-tree/lib/syntax/node/SelectorList.js
var SelectorList_exports = {};
__export(SelectorList_exports, {
  generate: () => generate35,
  name: () => name34,
  parse: () => parse40,
  structure: () => structure34,
  walkContext: () => walkContext9
});
var name34 = "SelectorList";
var walkContext9 = "selector";
var structure34 = {
  children: [[
    "Selector",
    "Raw"
  ]]
};
function parse40() {
  const children = this.createList();
  while (!this.eof) {
    children.push(this.Selector());
    if (this.tokenType === Comma) {
      this.next();
      continue;
    }
    break;
  }
  return {
    type: "SelectorList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate35(node) {
  this.children(node, () => this.token(Comma, ","));
}

// node_modules/css-tree/lib/syntax/node/String.js
var String_exports = {};
__export(String_exports, {
  generate: () => generate36,
  name: () => name35,
  parse: () => parse41,
  structure: () => structure35
});

// node_modules/css-tree/lib/utils/string.js
var string_exports = {};
__export(string_exports, {
  decode: () => decode,
  encode: () => encode2
});
var REVERSE_SOLIDUS = 92;
var QUOTATION_MARK = 34;
var APOSTROPHE2 = 39;
function decode(str) {
  const len = str.length;
  const firstChar = str.charCodeAt(0);
  const start = firstChar === QUOTATION_MARK || firstChar === APOSTROPHE2 ? 1 : 0;
  const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
  let decoded = "";
  for (let i = start; i <= end; i++) {
    let code2 = str.charCodeAt(i);
    if (code2 === REVERSE_SOLIDUS) {
      if (i === end) {
        if (i !== len - 1) {
          decoded = str.substr(i + 1);
        }
        break;
      }
      code2 = str.charCodeAt(++i);
      if (isValidEscape(REVERSE_SOLIDUS, code2)) {
        const escapeStart = i - 1;
        const escapeEnd = consumeEscaped(str, escapeStart);
        i = escapeEnd - 1;
        decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
      } else {
        if (code2 === 13 && str.charCodeAt(i + 1) === 10) {
          i++;
        }
      }
    } else {
      decoded += str[i];
    }
  }
  return decoded;
}
function encode2(str, apostrophe) {
  const quote = apostrophe ? "'" : '"';
  const quoteCode = apostrophe ? APOSTROPHE2 : QUOTATION_MARK;
  let encoded = "";
  let wsBeforeHexIsNeeded = false;
  for (let i = 0; i < str.length; i++) {
    const code2 = str.charCodeAt(i);
    if (code2 === 0) {
      encoded += "�";
      continue;
    }
    if (code2 <= 31 || code2 === 127) {
      encoded += "\\" + code2.toString(16);
      wsBeforeHexIsNeeded = true;
      continue;
    }
    if (code2 === quoteCode || code2 === REVERSE_SOLIDUS) {
      encoded += "\\" + str.charAt(i);
      wsBeforeHexIsNeeded = false;
    } else {
      if (wsBeforeHexIsNeeded && (isHexDigit2(code2) || isWhiteSpace(code2))) {
        encoded += " ";
      }
      encoded += str.charAt(i);
      wsBeforeHexIsNeeded = false;
    }
  }
  return quote + encoded + quote;
}

// node_modules/css-tree/lib/syntax/node/String.js
var name35 = "String";
var structure35 = {
  value: String
};
function parse41() {
  return {
    type: "String",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: decode(this.consume(String2))
  };
}
function generate36(node) {
  this.token(String2, encode2(node.value));
}

// node_modules/css-tree/lib/syntax/node/StyleSheet.js
var StyleSheet_exports = {};
__export(StyleSheet_exports, {
  generate: () => generate37,
  name: () => name36,
  parse: () => parse42,
  structure: () => structure36,
  walkContext: () => walkContext10
});
var EXCLAMATIONMARK4 = 33;
function consumeRaw5(startToken) {
  return this.Raw(startToken, null, false);
}
var name36 = "StyleSheet";
var walkContext10 = "stylesheet";
var structure36 = {
  children: [[
    "Comment",
    "CDO",
    "CDC",
    "Atrule",
    "Rule",
    "Raw"
  ]]
};
function parse42() {
  const start = this.tokenStart;
  const children = this.createList();
  let child;
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case WhiteSpace:
          this.next();
          continue;
        case Comment:
          if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK4) {
            this.next();
            continue;
          }
          child = this.Comment();
          break;
        case CDO:
          child = this.CDO();
          break;
        case CDC:
          child = this.CDC();
          break;
        case AtKeyword:
          child = this.parseWithFallback(this.Atrule, consumeRaw5);
          break;
        default:
          child = this.parseWithFallback(this.Rule, consumeRaw5);
      }
      children.push(child);
    }
  return {
    type: "StyleSheet",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate37(node) {
  this.children(node);
}

// node_modules/css-tree/lib/syntax/node/TypeSelector.js
var TypeSelector_exports = {};
__export(TypeSelector_exports, {
  generate: () => generate38,
  name: () => name37,
  parse: () => parse43,
  structure: () => structure37
});
var ASTERISK5 = 42;
var VERTICALLINE3 = 124;
function eatIdentifierOrAsterisk() {
  if (this.tokenType !== Ident && this.isDelim(ASTERISK5) === false) {
    this.error("Identifier or asterisk is expected");
  }
  this.next();
}
var name37 = "TypeSelector";
var structure37 = {
  name: String
};
function parse43() {
  const start = this.tokenStart;
  if (this.isDelim(VERTICALLINE3)) {
    this.next();
    eatIdentifierOrAsterisk.call(this);
  } else {
    eatIdentifierOrAsterisk.call(this);
    if (this.isDelim(VERTICALLINE3)) {
      this.next();
      eatIdentifierOrAsterisk.call(this);
    }
  }
  return {
    type: "TypeSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start)
  };
}
function generate38(node) {
  this.tokenize(node.name);
}

// node_modules/css-tree/lib/syntax/node/UnicodeRange.js
var UnicodeRange_exports = {};
__export(UnicodeRange_exports, {
  generate: () => generate39,
  name: () => name38,
  parse: () => parse44,
  structure: () => structure38
});
var PLUSSIGN8 = 43;
var HYPHENMINUS6 = 45;
var QUESTIONMARK3 = 63;
function eatHexSequence(offset2, allowDash) {
  let len = 0;
  for (let pos = this.tokenStart + offset2; pos < this.tokenEnd; pos++) {
    const code2 = this.charCodeAt(pos);
    if (code2 === HYPHENMINUS6 && allowDash && len !== 0) {
      eatHexSequence.call(this, offset2 + len + 1, false);
      return -1;
    }
    if (!isHexDigit2(code2)) {
      this.error(
        allowDash && len !== 0 ? "Hyphen minus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input",
        pos
      );
    }
    if (++len > 6) {
      this.error("Too many hex digits", pos);
    }
    ;
  }
  this.next();
  return len;
}
function eatQuestionMarkSequence(max) {
  let count = 0;
  while (this.isDelim(QUESTIONMARK3)) {
    if (++count > max) {
      this.error("Too many question marks");
    }
    this.next();
  }
}
function startsWith2(code2) {
  if (this.charCodeAt(this.tokenStart) !== code2) {
    this.error((code2 === PLUSSIGN8 ? "Plus sign" : "Hyphen minus") + " is expected");
  }
}
function scanUnicodeRange() {
  let hexLength = 0;
  switch (this.tokenType) {
    case Number2:
      hexLength = eatHexSequence.call(this, 1, true);
      if (this.isDelim(QUESTIONMARK3)) {
        eatQuestionMarkSequence.call(this, 6 - hexLength);
        break;
      }
      if (this.tokenType === Dimension || this.tokenType === Number2) {
        startsWith2.call(this, HYPHENMINUS6);
        eatHexSequence.call(this, 1, false);
        break;
      }
      break;
    case Dimension:
      hexLength = eatHexSequence.call(this, 1, true);
      if (hexLength > 0) {
        eatQuestionMarkSequence.call(this, 6 - hexLength);
      }
      break;
    default:
      this.eatDelim(PLUSSIGN8);
      if (this.tokenType === Ident) {
        hexLength = eatHexSequence.call(this, 0, true);
        if (hexLength > 0) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
        }
        break;
      }
      if (this.isDelim(QUESTIONMARK3)) {
        this.next();
        eatQuestionMarkSequence.call(this, 5);
        break;
      }
      this.error("Hex digit or question mark is expected");
  }
}
var name38 = "UnicodeRange";
var structure38 = {
  value: String
};
function parse44() {
  const start = this.tokenStart;
  this.eatIdent("u");
  scanUnicodeRange.call(this);
  return {
    type: "UnicodeRange",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start)
  };
}
function generate39(node) {
  this.tokenize(node.value);
}

// node_modules/css-tree/lib/syntax/node/Url.js
var Url_exports = {};
__export(Url_exports, {
  generate: () => generate40,
  name: () => name39,
  parse: () => parse45,
  structure: () => structure39
});

// node_modules/css-tree/lib/utils/url.js
var url_exports = {};
__export(url_exports, {
  decode: () => decode2,
  encode: () => encode3
});
var SPACE3 = 32;
var REVERSE_SOLIDUS2 = 92;
var QUOTATION_MARK2 = 34;
var APOSTROPHE3 = 39;
var LEFTPARENTHESIS3 = 40;
var RIGHTPARENTHESIS3 = 41;
function decode2(str) {
  const len = str.length;
  let start = 4;
  let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS3 ? len - 2 : len - 1;
  let decoded = "";
  while (start < end && isWhiteSpace(str.charCodeAt(start))) {
    start++;
  }
  while (start < end && isWhiteSpace(str.charCodeAt(end))) {
    end--;
  }
  for (let i = start; i <= end; i++) {
    let code2 = str.charCodeAt(i);
    if (code2 === REVERSE_SOLIDUS2) {
      if (i === end) {
        if (i !== len - 1) {
          decoded = str.substr(i + 1);
        }
        break;
      }
      code2 = str.charCodeAt(++i);
      if (isValidEscape(REVERSE_SOLIDUS2, code2)) {
        const escapeStart = i - 1;
        const escapeEnd = consumeEscaped(str, escapeStart);
        i = escapeEnd - 1;
        decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
      } else {
        if (code2 === 13 && str.charCodeAt(i + 1) === 10) {
          i++;
        }
      }
    } else {
      decoded += str[i];
    }
  }
  return decoded;
}
function encode3(str) {
  let encoded = "";
  let wsBeforeHexIsNeeded = false;
  for (let i = 0; i < str.length; i++) {
    const code2 = str.charCodeAt(i);
    if (code2 === 0) {
      encoded += "�";
      continue;
    }
    if (code2 <= 31 || code2 === 127) {
      encoded += "\\" + code2.toString(16);
      wsBeforeHexIsNeeded = true;
      continue;
    }
    if (code2 === SPACE3 || code2 === REVERSE_SOLIDUS2 || code2 === QUOTATION_MARK2 || code2 === APOSTROPHE3 || code2 === LEFTPARENTHESIS3 || code2 === RIGHTPARENTHESIS3) {
      encoded += "\\" + str.charAt(i);
      wsBeforeHexIsNeeded = false;
    } else {
      if (wsBeforeHexIsNeeded && isHexDigit2(code2)) {
        encoded += " ";
      }
      encoded += str.charAt(i);
      wsBeforeHexIsNeeded = false;
    }
  }
  return "url(" + encoded + ")";
}

// node_modules/css-tree/lib/syntax/node/Url.js
var name39 = "Url";
var structure39 = {
  value: String
};
function parse45() {
  const start = this.tokenStart;
  let value;
  switch (this.tokenType) {
    case Url:
      value = decode2(this.consume(Url));
      break;
    case Function2:
      if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url(")) {
        this.error("Function name must be `url`");
      }
      this.eat(Function2);
      this.skipSC();
      value = decode(this.consume(String2));
      this.skipSC();
      if (!this.eof) {
        this.eat(RightParenthesis);
      }
      break;
    default:
      this.error("Url or Function is expected");
  }
  return {
    type: "Url",
    loc: this.getLocation(start, this.tokenStart),
    value
  };
}
function generate40(node) {
  this.token(Url, encode3(node.value));
}

// node_modules/css-tree/lib/syntax/node/Value.js
var Value_exports = {};
__export(Value_exports, {
  generate: () => generate41,
  name: () => name40,
  parse: () => parse46,
  structure: () => structure40
});
var name40 = "Value";
var structure40 = {
  children: [[]]
};
function parse46() {
  const start = this.tokenStart;
  const children = this.readSequence(this.scope.Value);
  return {
    type: "Value",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate41(node) {
  this.children(node);
}

// node_modules/css-tree/lib/syntax/node/WhiteSpace.js
var WhiteSpace_exports = {};
__export(WhiteSpace_exports, {
  generate: () => generate42,
  name: () => name41,
  parse: () => parse47,
  structure: () => structure41
});
var SPACE4 = Object.freeze({
  type: "WhiteSpace",
  loc: null,
  value: " "
});
var name41 = "WhiteSpace";
var structure41 = {
  value: String
};
function parse47() {
  this.eat(WhiteSpace);
  return SPACE4;
}
function generate42(node) {
  this.token(WhiteSpace, node.value);
}

// node_modules/css-tree/lib/syntax/config/lexer.js
var lexer_default = {
  generic: true,
  ...data_default,
  node: node_exports
};

// node_modules/css-tree/lib/syntax/scope/index.js
var scope_exports = {};
__export(scope_exports, {
  AtrulePrelude: () => atrulePrelude_default,
  Selector: () => selector_default,
  Value: () => value_default
});

// node_modules/css-tree/lib/syntax/scope/default.js
var NUMBERSIGN4 = 35;
var ASTERISK6 = 42;
var PLUSSIGN9 = 43;
var HYPHENMINUS7 = 45;
var SOLIDUS5 = 47;
var U2 = 117;
function defaultRecognizer(context) {
  switch (this.tokenType) {
    case Hash:
      return this.Hash();
    case Comma:
      return this.Operator();
    case LeftParenthesis:
      return this.Parentheses(this.readSequence, context.recognizer);
    case LeftSquareBracket:
      return this.Brackets(this.readSequence, context.recognizer);
    case String2:
      return this.String();
    case Dimension:
      return this.Dimension();
    case Percentage:
      return this.Percentage();
    case Number2:
      return this.Number();
    case Function2:
      return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context.recognizer);
    case Url:
      return this.Url();
    case Ident:
      if (this.cmpChar(this.tokenStart, U2) && this.cmpChar(this.tokenStart + 1, PLUSSIGN9)) {
        return this.UnicodeRange();
      } else {
        return this.Identifier();
      }
    case Delim: {
      const code2 = this.charCodeAt(this.tokenStart);
      if (code2 === SOLIDUS5 || code2 === ASTERISK6 || code2 === PLUSSIGN9 || code2 === HYPHENMINUS7) {
        return this.Operator();
      }
      if (code2 === NUMBERSIGN4) {
        this.error("Hex or identifier is expected", this.tokenStart + 1);
      }
      break;
    }
  }
}

// node_modules/css-tree/lib/syntax/scope/atrulePrelude.js
var atrulePrelude_default = {
  getNode: defaultRecognizer
};

// node_modules/css-tree/lib/syntax/scope/selector.js
var NUMBERSIGN5 = 35;
var AMPERSAND6 = 38;
var ASTERISK7 = 42;
var PLUSSIGN10 = 43;
var SOLIDUS6 = 47;
var FULLSTOP3 = 46;
var GREATERTHANSIGN3 = 62;
var VERTICALLINE4 = 124;
var TILDE3 = 126;
function onWhiteSpace(next, children) {
  if (children.last !== null && children.last.type !== "Combinator" && next !== null && next.type !== "Combinator") {
    children.push({
      // FIXME: this.Combinator() should be used instead
      type: "Combinator",
      loc: null,
      name: " "
    });
  }
}
function getNode() {
  switch (this.tokenType) {
    case LeftSquareBracket:
      return this.AttributeSelector();
    case Hash:
      return this.IdSelector();
    case Colon:
      if (this.lookupType(1) === Colon) {
        return this.PseudoElementSelector();
      } else {
        return this.PseudoClassSelector();
      }
    case Ident:
      return this.TypeSelector();
    case Number2:
    case Percentage:
      return this.Percentage();
    case Dimension:
      if (this.charCodeAt(this.tokenStart) === FULLSTOP3) {
        this.error("Identifier is expected", this.tokenStart + 1);
      }
      break;
    case Delim: {
      const code2 = this.charCodeAt(this.tokenStart);
      switch (code2) {
        case PLUSSIGN10:
        case GREATERTHANSIGN3:
        case TILDE3:
        case SOLIDUS6:
          return this.Combinator();
        case FULLSTOP3:
          return this.ClassSelector();
        case ASTERISK7:
        case VERTICALLINE4:
          return this.TypeSelector();
        case NUMBERSIGN5:
          return this.IdSelector();
        case AMPERSAND6:
          return this.NestingSelector();
      }
      break;
    }
  }
}
var selector_default = {
  onWhiteSpace,
  getNode
};

// node_modules/css-tree/lib/syntax/function/expression.js
function expression_default() {
  return this.createSingleNodeList(
    this.Raw(this.tokenIndex, null, false)
  );
}

// node_modules/css-tree/lib/syntax/function/var.js
function var_default() {
  const children = this.createList();
  this.skipSC();
  children.push(this.Identifier());
  this.skipSC();
  if (this.tokenType === Comma) {
    children.push(this.Operator());
    const startIndex = this.tokenIndex;
    const value = this.parseCustomProperty ? this.Value(null) : this.Raw(this.tokenIndex, this.consumeUntilExclamationMarkOrSemicolon, false);
    if (value.type === "Value" && value.children.isEmpty) {
      for (let offset2 = startIndex - this.tokenIndex; offset2 <= 0; offset2++) {
        if (this.lookupType(offset2) === WhiteSpace) {
          value.children.appendData({
            type: "WhiteSpace",
            loc: null,
            value: " "
          });
          break;
        }
      }
    }
    children.push(value);
  }
  return children;
}

// node_modules/css-tree/lib/syntax/scope/value.js
function isPlusMinusOperator(node) {
  return node !== null && node.type === "Operator" && (node.value[node.value.length - 1] === "-" || node.value[node.value.length - 1] === "+");
}
var value_default = {
  getNode: defaultRecognizer,
  onWhiteSpace(next, children) {
    if (isPlusMinusOperator(next)) {
      next.value = " " + next.value;
    }
    if (isPlusMinusOperator(children.last)) {
      children.last.value += " ";
    }
  },
  "expression": expression_default,
  "var": var_default
};

// node_modules/css-tree/lib/syntax/atrule/font-face.js
var font_face_default = {
  parse: {
    prelude: null,
    block() {
      return this.Block(true);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/import.js
var import_default3 = {
  parse: {
    prelude() {
      const children = this.createList();
      this.skipSC();
      switch (this.tokenType) {
        case String2:
          children.push(this.String());
          break;
        case Url:
        case Function2:
          children.push(this.Url());
          break;
        default:
          this.error("String or url() is expected");
      }
      if (this.lookupNonWSType(0) === Ident || this.lookupNonWSType(0) === LeftParenthesis) {
        children.push(this.MediaQueryList());
      }
      return children;
    },
    block: null
  }
};

// node_modules/css-tree/lib/syntax/atrule/media.js
var media_default = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.MediaQueryList()
      );
    },
    block(isStyleBlock = false) {
      return this.Block(isStyleBlock);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/nest.js
var nest_default = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.SelectorList()
      );
    },
    block() {
      return this.Block(true);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/page.js
var page_default = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.SelectorList()
      );
    },
    block() {
      return this.Block(true);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/supports.js
function consumeRaw6() {
  return this.createSingleNodeList(
    this.Raw(this.tokenIndex, null, false)
  );
}
function parentheses() {
  this.skipSC();
  if (this.tokenType === Ident && this.lookupNonWSType(1) === Colon) {
    return this.createSingleNodeList(
      this.Declaration()
    );
  }
  return readSequence2.call(this);
}
function readSequence2() {
  const children = this.createList();
  let child;
  this.skipSC();
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case Comment:
        case WhiteSpace:
          this.next();
          continue;
        case Function2:
          child = this.Function(consumeRaw6, this.scope.AtrulePrelude);
          break;
        case Ident:
          child = this.Identifier();
          break;
        case LeftParenthesis:
          child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
          break;
        default:
          break scan;
      }
      children.push(child);
    }
  return children;
}
var supports_default = {
  parse: {
    prelude() {
      const children = readSequence2.call(this);
      if (this.getFirstListNode(children) === null) {
        this.error("Condition is expected");
      }
      return children;
    },
    block(isStyleBlock = false) {
      return this.Block(isStyleBlock);
    }
  }
};

// node_modules/css-tree/lib/syntax/atrule/index.js
var atrule_default = {
  "font-face": font_face_default,
  "import": import_default3,
  media: media_default,
  nest: nest_default,
  page: page_default,
  supports: supports_default
};

// node_modules/css-tree/lib/syntax/pseudo/index.js
var selectorList = {
  parse() {
    return this.createSingleNodeList(
      this.SelectorList()
    );
  }
};
var selector = {
  parse() {
    return this.createSingleNodeList(
      this.Selector()
    );
  }
};
var identList = {
  parse() {
    return this.createSingleNodeList(
      this.Identifier()
    );
  }
};
var nth = {
  parse() {
    return this.createSingleNodeList(
      this.Nth()
    );
  }
};
var pseudo_default = {
  "dir": identList,
  "has": selectorList,
  "lang": identList,
  "matches": selectorList,
  "is": selectorList,
  "-moz-any": selectorList,
  "-webkit-any": selectorList,
  "where": selectorList,
  "not": selectorList,
  "nth-child": nth,
  "nth-last-child": nth,
  "nth-last-of-type": nth,
  "nth-of-type": nth,
  "slotted": selector,
  "host": selector,
  "host-context": selector
};

// node_modules/css-tree/lib/syntax/node/index-parse.js
var index_parse_exports = {};
__export(index_parse_exports, {
  AnPlusB: () => parse7,
  Atrule: () => parse8,
  AtrulePrelude: () => parse9,
  AttributeSelector: () => parse10,
  Block: () => parse11,
  Brackets: () => parse12,
  CDC: () => parse13,
  CDO: () => parse14,
  ClassSelector: () => parse15,
  Combinator: () => parse16,
  Comment: () => parse17,
  Declaration: () => parse18,
  DeclarationList: () => parse19,
  Dimension: () => parse20,
  Function: () => parse21,
  Hash: () => parse22,
  IdSelector: () => parse24,
  Identifier: () => parse23,
  MediaFeature: () => parse25,
  MediaQuery: () => parse26,
  MediaQueryList: () => parse27,
  NestingSelector: () => parse28,
  Nth: () => parse29,
  Number: () => parse30,
  Operator: () => parse31,
  Parentheses: () => parse32,
  Percentage: () => parse33,
  PseudoClassSelector: () => parse34,
  PseudoElementSelector: () => parse35,
  Ratio: () => parse36,
  Raw: () => parse37,
  Rule: () => parse38,
  Selector: () => parse39,
  SelectorList: () => parse40,
  String: () => parse41,
  StyleSheet: () => parse42,
  TypeSelector: () => parse43,
  UnicodeRange: () => parse44,
  Url: () => parse45,
  Value: () => parse46,
  WhiteSpace: () => parse47
});

// node_modules/css-tree/lib/syntax/config/parser.js
var parser_default = {
  parseContext: {
    default: "StyleSheet",
    stylesheet: "StyleSheet",
    atrule: "Atrule",
    atrulePrelude(options) {
      return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
    },
    mediaQueryList: "MediaQueryList",
    mediaQuery: "MediaQuery",
    rule: "Rule",
    selectorList: "SelectorList",
    selector: "Selector",
    block() {
      return this.Block(true);
    },
    declarationList: "DeclarationList",
    declaration: "Declaration",
    value: "Value"
  },
  scope: scope_exports,
  atrule: atrule_default,
  pseudo: pseudo_default,
  node: index_parse_exports
};

// node_modules/css-tree/lib/syntax/config/walker.js
var walker_default = {
  node: node_exports
};

// node_modules/css-tree/lib/syntax/index.js
var syntax_default = create_default({
  ...lexer_default,
  ...parser_default,
  ...walker_default
});

// node_modules/css-tree/lib/utils/ident.js
var ident_exports = {};
__export(ident_exports, {
  decode: () => decode3,
  encode: () => encode4
});
var REVERSE_SOLIDUS3 = 92;
function decode3(str) {
  const end = str.length - 1;
  let decoded = "";
  for (let i = 0; i < str.length; i++) {
    let code2 = str.charCodeAt(i);
    if (code2 === REVERSE_SOLIDUS3) {
      if (i === end) {
        break;
      }
      code2 = str.charCodeAt(++i);
      if (isValidEscape(REVERSE_SOLIDUS3, code2)) {
        const escapeStart = i - 1;
        const escapeEnd = consumeEscaped(str, escapeStart);
        i = escapeEnd - 1;
        decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
      } else {
        if (code2 === 13 && str.charCodeAt(i + 1) === 10) {
          i++;
        }
      }
    } else {
      decoded += str[i];
    }
  }
  return decoded;
}
function encode4(str) {
  let encoded = "";
  if (str.length === 1 && str.charCodeAt(0) === 45) {
    return "\\-";
  }
  for (let i = 0; i < str.length; i++) {
    const code2 = str.charCodeAt(i);
    if (code2 === 0) {
      encoded += "�";
      continue;
    }
    if (
      // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F ...
      // Note: Do not compare with 0x0001 since 0x0000 is precessed before
      code2 <= 31 || code2 === 127 || // [or] ... is in the range [0-9] (U+0030 to U+0039),
      code2 >= 48 && code2 <= 57 && // If the character is the first character ...
      (i === 0 || // If the character is the second character ... and the first character is a "-" (U+002D)
      i === 1 && str.charCodeAt(0) === 45)
    ) {
      encoded += "\\" + code2.toString(16) + " ";
      continue;
    }
    if (isName(code2)) {
      encoded += str.charAt(i);
    } else {
      encoded += "\\" + str.charAt(i);
    }
  }
  return encoded;
}

// node_modules/css-tree/lib/index.js
var {
  tokenize: tokenize2,
  parse: parse48,
  generate: generate43,
  lexer,
  createLexer,
  walk: walk3,
  find,
  findLast,
  findAll,
  toPlainObject,
  fromPlainObject,
  fork
} = syntax_default;

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/node/index.js
var node_exports2 = {};
__export(node_exports2, {
  Comparison: () => comparison_exports,
  ContainerFeatureStyle: () => container_feature_style_exports,
  ContainerQuery: () => container_query_exports,
  MediaQuery: () => media_query_exports,
  QueryCSSFunction: () => query_css_function_exports,
  QueryFeature: () => query_feature_exports,
  QueryFeatureRange: () => query_feature_range_exports
});

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/node/comparison.js
var comparison_exports = {};
__export(comparison_exports, {
  generate: () => generate44,
  name: () => name42,
  parse: () => parse49,
  structure: () => structure42
});
var name42 = "Comparison";
var structure42 = {
  value: String
};
function parse49() {
  const start = this.tokenStart;
  const char1 = this.consume(Delim);
  if (char1 !== "<" && char1 !== ">" && char1 !== "=") {
    this.error("Malformed comparison operator");
  }
  let char2;
  if (this.tokenType === Delim) {
    char2 = this.consume(Delim);
    if (char2 !== "=") {
      this.error("Malformed comparison operator");
    }
  }
  if (this.tokenType === Delim) {
    this.error("Malformed comparison operator");
  }
  const value = char2 ? `${char1}${char2}` : char1;
  return {
    type: "Comparison",
    loc: this.getLocation(start, this.tokenStart),
    value
  };
}
function generate44(node) {
  for (let index = 0; index < node.value.length; index++) {
    this.token(Delim, node.value.charAt(index));
  }
}

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/node/container_feature_style.js
var container_feature_style_exports = {};
__export(container_feature_style_exports, {
  generate: () => generate45,
  name: () => name43,
  parse: () => parse50,
  structure: () => structure43
});
var name43 = "ContainerFeatureStyle";
var structure43 = {
  name: String,
  value: ["Function", "Identifier", "Number", "Dimension", "QueryCSSFunction", "Ratio", null]
};
function parse50() {
  const start = this.tokenStart;
  let value = null;
  const function_name = this.consumeFunctionName();
  if (function_name !== "style") {
    this.error('Unknown container style query identifier; "style" is expected');
  }
  this.skipSC();
  const name49 = this.consume(Ident);
  this.skipSC();
  if (this.tokenType !== RightParenthesis) {
    this.eat(Colon);
    this.skipSC();
    switch (this.tokenType) {
      case Number2:
        if (this.lookupNonWSType(1) === Delim) {
          value = this.Ratio();
        } else {
          value = this.Number();
        }
        break;
      case Dimension:
        value = this.Dimension();
        break;
      case Function2:
        value = this.QueryCSSFunction();
        break;
      case Ident:
        value = this.Identifier();
        break;
      default:
        this.error("Number, dimension, ratio, function or identifier is expected");
        break;
    }
    this.skipSC();
  }
  this.eat(RightParenthesis);
  return {
    type: "ContainerFeatureStyle",
    loc: this.getLocation(start, this.tokenStart),
    name: name49,
    value
  };
}
function generate45(node) {
  this.token(Function2, "style(");
  this.token(Ident, node.name);
  if (node.value !== null) {
    this.token(Colon, ":");
    this.node(node.value);
  }
  this.token(RightParenthesis, ")");
}

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/node/container_query.js
var container_query_exports = {};
__export(container_query_exports, {
  generate: () => generate46,
  name: () => name44,
  parse: () => parse51,
  structure: () => structure44
});

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/node/lookahead_is_range.js
function lookahead_is_range() {
  let type;
  let offset2 = 0;
  let count = 0;
  let delim_found = false;
  let no_colon = true;
  do {
    type = this.lookupNonWSType(offset2++);
    if (type !== WhiteSpace) {
      count++;
    }
    if (type === Delim) {
      delim_found = true;
    }
    if (type === Colon) {
      no_colon = false;
    }
    if (type === LeftCurlyBracket || type === RightParenthesis) {
      break;
    }
  } while (type !== EOF && count <= 6);
  return delim_found && no_colon;
}

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/node/container_query.js
var CONTAINER_QUERY_KEYWORDS = /* @__PURE__ */ new Set(["none", "and", "not", "or"]);
var name44 = "ContainerQuery";
var structure44 = {
  name: "Identifier",
  children: [
    ["Identifier", "QueryFeature", "QueryFeatureRange", "ContainerFeatureStyle", "WhiteSpace"]
  ]
};
function parse51() {
  const start = this.tokenStart;
  const children = this.createList();
  let child = null;
  let name49 = null;
  if (this.tokenType === Ident) {
    const container_name = this.substring(this.tokenStart, this.tokenEnd);
    if (!CONTAINER_QUERY_KEYWORDS.has(container_name.toLowerCase())) {
      name49 = container_name;
      this.eat(Ident);
    }
  }
  this.skipSC();
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case Comment:
        case WhiteSpace:
          this.next();
          continue;
        case Ident:
          child = this.Identifier();
          break;
        case Function2:
          child = this.ContainerFeatureStyle();
          break;
        case LeftParenthesis:
          child = lookahead_is_range.call(this) ? this.QueryFeatureRange() : this.QueryFeature();
          break;
        default:
          break scan;
      }
      children.push(child);
    }
  if (child === null) {
    this.error("Identifier or parenthesis is expected");
  }
  return {
    type: "ContainerQuery",
    loc: this.getLocation(start, this.tokenStart - 1),
    name: name49,
    children
  };
}
function generate46(node) {
  if (typeof node.name === "string") {
    this.token(Ident, node.name);
  }
  this.children(node);
}

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/node/media_query.js
var media_query_exports = {};
__export(media_query_exports, {
  generate: () => generate47,
  name: () => name45,
  parse: () => parse52,
  structure: () => structure45
});
var name45 = "MediaQuery";
var structure45 = {
  children: [["Identifier", "QueryFeature", "QueryFeatureRange", "WhiteSpace"]]
};
function parse52() {
  const children = this.createList();
  let child = null;
  this.skipSC();
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case Comment:
        case WhiteSpace:
          this.next();
          continue;
        case Ident:
          child = this.Identifier();
          break;
        case LeftParenthesis:
          child = lookahead_is_range.call(this) ? this.QueryFeatureRange() : this.QueryFeature();
          break;
        default:
          break scan;
      }
      children.push(child);
    }
  if (child === null) {
    this.error("Identifier or parenthesis is expected");
  }
  return {
    type: "MediaQuery",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate47(node) {
  this.children(node);
}

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/node/query_feature.js
var query_feature_exports = {};
__export(query_feature_exports, {
  generate: () => generate48,
  name: () => name46,
  parse: () => parse53,
  structure: () => structure46
});
var name46 = "QueryFeature";
var structure46 = {
  name: String,
  value: ["Identifier", "Number", "Dimension", "QueryCSSFunction", "Ratio", null]
};
function parse53() {
  const start = this.tokenStart;
  let value = null;
  this.eat(LeftParenthesis);
  this.skipSC();
  const name49 = this.consume(Ident);
  this.skipSC();
  if (this.tokenType !== RightParenthesis) {
    this.eat(Colon);
    this.skipSC();
    switch (this.tokenType) {
      case Number2:
        if (this.lookupNonWSType(1) === Delim) {
          value = this.Ratio();
        } else {
          value = this.Number();
        }
        break;
      case Dimension:
        value = this.Dimension();
        break;
      case Function2:
        value = this.QueryCSSFunction();
        break;
      case Ident:
        value = this.Identifier();
        break;
      default:
        this.error("Number, dimension, ratio, function, or identifier is expected");
        break;
    }
    this.skipSC();
  }
  this.eat(RightParenthesis);
  return {
    type: "QueryFeature",
    loc: this.getLocation(start, this.tokenStart),
    name: name49,
    value
  };
}
function generate48(node) {
  this.token(LeftParenthesis, "(");
  this.token(Ident, node.name);
  if (node.value !== null) {
    this.token(Colon, ":");
    this.node(node.value);
  }
  this.token(RightParenthesis, ")");
}

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/node/query_feature_range.js
var query_feature_range_exports = {};
__export(query_feature_range_exports, {
  generate: () => generate49,
  name: () => name47,
  parse: () => parse54,
  structure: () => structure47
});
var name47 = "QueryFeatureRange";
var structure47 = {
  name: String,
  value: ["Identifier", "Number", "Comparison", "Dimension", "QueryCSSFunction", "Ratio", null]
};
function lookup_non_ws_type_and_value(offset2, type, reference_str) {
  let current_type;
  do {
    current_type = this.lookupType(offset2++);
    if (current_type !== WhiteSpace) {
      break;
    }
  } while (current_type !== 0);
  return current_type === type ? this.lookupValue(offset2 - 1, reference_str) : false;
}
function parse54() {
  const start = this.tokenStart;
  const children = this.createList();
  let child = null;
  this.eat(LeftParenthesis);
  this.skipSC();
  while (!this.eof && this.tokenType !== RightParenthesis) {
    switch (this.tokenType) {
      case Number2:
        if (lookup_non_ws_type_and_value.call(this, 1, Delim, "/")) {
          child = this.Ratio();
        } else {
          child = this.Number();
        }
        break;
      case Delim:
        child = this.Comparison();
        break;
      case Dimension:
        child = this.Dimension();
        break;
      case Function2:
        child = this.QueryCSSFunction();
        break;
      case Ident:
        child = this.Identifier();
        break;
      default:
        this.error("Number, dimension, comparison, ratio, function, or identifier is expected");
        break;
    }
    children.push(child);
    this.skipSC();
  }
  this.eat(RightParenthesis);
  return {
    type: "QueryFeatureRange",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate49(node) {
  this.children(node);
}

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/node/query_css_function.js
var query_css_function_exports = {};
__export(query_css_function_exports, {
  generate: () => generate50,
  name: () => name48,
  parse: () => parse55,
  structure: () => structure48
});
var QUERY_CSS_FUNCTIONS = /* @__PURE__ */ new Set(["calc", "clamp", "min", "max"]);
var name48 = "QueryCSSFunction";
var structure48 = {
  name: String,
  expression: String
};
function parse55() {
  const start = this.tokenStart;
  const name49 = this.consumeFunctionName();
  if (!QUERY_CSS_FUNCTIONS.has(name49)) {
    this.error('Unknown query single value function; expected: "calc", "clamp", "max", min"');
  }
  const body = this.Raw(this.tokenIndex, null, false);
  this.eat(RightParenthesis);
  return {
    type: "QueryCSSFunction",
    loc: this.getLocation(start, this.tokenStart),
    name: name49,
    expression: body.value
  };
}
function generate50(node) {
  this.token(Function, `${node.name}(`);
  this.node(node.expression);
  this.token(RightParenthesis, ")");
}

// node_modules/svelte/src/compiler/parse/read/css-tree-cq/css_tree_parse.js
var cq_syntax = fork({
  atrule: {
    // extend or override at-rule dictionary
    container: {
      parse: {
        prelude() {
          return this.createSingleNodeList(this.ContainerQuery());
        },
        block(is_style_block = false) {
          return this.Block(is_style_block);
        }
      }
    }
  },
  node: node_exports2
});
var parse56 = cq_syntax.parse;

// node_modules/svelte/src/compiler/parse/read/style.js
var regex_closing_style_tag = /<\/style\s*>/;
var regex_starts_with_closing_style_tag = /^<\/style\s*>/;
function read_style(parser, start, attributes) {
  const content_start = parser.index;
  const styles = parser.read_until(regex_closing_style_tag, errors_default.unclosed_style);
  if (parser.index >= parser.template.length) {
    parser.error(errors_default.unclosed_style);
  }
  const content_end = parser.index;
  if (parser.css_mode === "none") {
    parser.read(regex_starts_with_closing_style_tag);
    return null;
  }
  let ast;
  try {
    ast = parse56(styles, {
      positions: true,
      offset: content_start,
      onParseError(error2) {
        throw error2;
      }
    });
  } catch (err) {
    if (err.name === "SyntaxError") {
      parser.error(errors_default.css_syntax_error(err.message), err.offset);
    } else {
      throw err;
    }
  }
  ast = JSON.parse(JSON.stringify(ast));
  walk(ast, {
    /** @param {any} node */
    enter: (node) => {
      if (node.type === "Selector") {
        for (let i = 0; i < node.children.length; i += 1) {
          const a = node.children[i];
          const b2 = node.children[i + 1];
          if (is_ref_selector(a, b2)) {
            parser.error(errors_default.invalid_ref_selector, a.loc.start.offset);
          }
        }
      }
      if (node.type === "Declaration" && node.value.type === "Value" && node.value.children.length === 0) {
        parser.error(errors_default.invalid_declaration, node.start);
      }
      if (node.type === "PseudoClassSelector" && node.name === "global" && node.children === null) {
        parser.error(errors_default.empty_global_selector, node.loc.start.offset);
      }
      if (node.loc) {
        node.start = node.loc.start.offset;
        node.end = node.loc.end.offset;
        delete node.loc;
      }
    }
  });
  parser.read(regex_starts_with_closing_style_tag);
  const end = parser.index;
  return {
    type: "Style",
    start,
    end,
    attributes,
    children: ast.children,
    content: {
      start: content_start,
      end: content_end,
      styles
    }
  };
}
function is_ref_selector(a, b2) {
  if (!b2)
    return false;
  return a.type === "TypeSelector" && a.name === "ref" && b2.type === "PseudoClassSelector";
}

// node_modules/svelte/src/compiler/parse/utils/entities.js
var entities_default = {
  "CounterClockwiseContourIntegral;": 8755,
  "ClockwiseContourIntegral;": 8754,
  "DoubleLongLeftRightArrow;": 10234,
  "NotNestedGreaterGreater;": 10914,
  "DiacriticalDoubleAcute;": 733,
  "NotSquareSupersetEqual;": 8931,
  "CloseCurlyDoubleQuote;": 8221,
  "DoubleContourIntegral;": 8751,
  "FilledVerySmallSquare;": 9642,
  "NegativeVeryThinSpace;": 8203,
  "NotPrecedesSlantEqual;": 8928,
  "NotRightTriangleEqual;": 8941,
  "NotSucceedsSlantEqual;": 8929,
  "CapitalDifferentialD;": 8517,
  "DoubleLeftRightArrow;": 8660,
  "DoubleLongRightArrow;": 10233,
  "EmptyVerySmallSquare;": 9643,
  "NestedGreaterGreater;": 8811,
  "NotDoubleVerticalBar;": 8742,
  "NotGreaterSlantEqual;": 10878,
  "NotLeftTriangleEqual;": 8940,
  "NotSquareSubsetEqual;": 8930,
  "OpenCurlyDoubleQuote;": 8220,
  "ReverseUpEquilibrium;": 10607,
  "DoubleLongLeftArrow;": 10232,
  "DownLeftRightVector;": 10576,
  "LeftArrowRightArrow;": 8646,
  "NegativeMediumSpace;": 8203,
  "NotGreaterFullEqual;": 8807,
  "NotRightTriangleBar;": 10704,
  "RightArrowLeftArrow;": 8644,
  "SquareSupersetEqual;": 8850,
  "leftrightsquigarrow;": 8621,
  "DownRightTeeVector;": 10591,
  "DownRightVectorBar;": 10583,
  "LongLeftRightArrow;": 10231,
  "Longleftrightarrow;": 10234,
  "NegativeThickSpace;": 8203,
  "NotLeftTriangleBar;": 10703,
  "PrecedesSlantEqual;": 8828,
  "ReverseEquilibrium;": 8651,
  "RightDoubleBracket;": 10215,
  "RightDownTeeVector;": 10589,
  "RightDownVectorBar;": 10581,
  "RightTriangleEqual;": 8885,
  "SquareIntersection;": 8851,
  "SucceedsSlantEqual;": 8829,
  "blacktriangleright;": 9656,
  "longleftrightarrow;": 10231,
  "DoubleUpDownArrow;": 8661,
  "DoubleVerticalBar;": 8741,
  "DownLeftTeeVector;": 10590,
  "DownLeftVectorBar;": 10582,
  "FilledSmallSquare;": 9724,
  "GreaterSlantEqual;": 10878,
  "LeftDoubleBracket;": 10214,
  "LeftDownTeeVector;": 10593,
  "LeftDownVectorBar;": 10585,
  "LeftTriangleEqual;": 8884,
  "NegativeThinSpace;": 8203,
  "NotGreaterGreater;": 8811,
  "NotLessSlantEqual;": 10877,
  "NotNestedLessLess;": 10913,
  "NotReverseElement;": 8716,
  "NotSquareSuperset;": 8848,
  "NotTildeFullEqual;": 8775,
  "RightAngleBracket;": 10217,
  "RightUpDownVector;": 10575,
  "SquareSubsetEqual;": 8849,
  "VerticalSeparator;": 10072,
  "blacktriangledown;": 9662,
  "blacktriangleleft;": 9666,
  "leftrightharpoons;": 8651,
  "rightleftharpoons;": 8652,
  "twoheadrightarrow;": 8608,
  "DiacriticalAcute;": 180,
  "DiacriticalGrave;": 96,
  "DiacriticalTilde;": 732,
  "DoubleRightArrow;": 8658,
  "DownArrowUpArrow;": 8693,
  "EmptySmallSquare;": 9723,
  "GreaterEqualLess;": 8923,
  "GreaterFullEqual;": 8807,
  "LeftAngleBracket;": 10216,
  "LeftUpDownVector;": 10577,
  "LessEqualGreater;": 8922,
  "NonBreakingSpace;": 160,
  "NotPrecedesEqual;": 10927,
  "NotRightTriangle;": 8939,
  "NotSucceedsEqual;": 10928,
  "NotSucceedsTilde;": 8831,
  "NotSupersetEqual;": 8841,
  "RightTriangleBar;": 10704,
  "RightUpTeeVector;": 10588,
  "RightUpVectorBar;": 10580,
  "UnderParenthesis;": 9181,
  "UpArrowDownArrow;": 8645,
  "circlearrowright;": 8635,
  "downharpoonright;": 8642,
  "ntrianglerighteq;": 8941,
  "rightharpoondown;": 8641,
  "rightrightarrows;": 8649,
  "twoheadleftarrow;": 8606,
  "vartriangleright;": 8883,
  "CloseCurlyQuote;": 8217,
  "ContourIntegral;": 8750,
  "DoubleDownArrow;": 8659,
  "DoubleLeftArrow;": 8656,
  "DownRightVector;": 8641,
  "LeftRightVector;": 10574,
  "LeftTriangleBar;": 10703,
  "LeftUpTeeVector;": 10592,
  "LeftUpVectorBar;": 10584,
  "LowerRightArrow;": 8600,
  "NotGreaterEqual;": 8817,
  "NotGreaterTilde;": 8821,
  "NotHumpDownHump;": 8782,
  "NotLeftTriangle;": 8938,
  "NotSquareSubset;": 8847,
  "OverParenthesis;": 9180,
  "RightDownVector;": 8642,
  "ShortRightArrow;": 8594,
  "UpperRightArrow;": 8599,
  "bigtriangledown;": 9661,
  "circlearrowleft;": 8634,
  "curvearrowright;": 8631,
  "downharpoonleft;": 8643,
  "leftharpoondown;": 8637,
  "leftrightarrows;": 8646,
  "nLeftrightarrow;": 8654,
  "nleftrightarrow;": 8622,
  "ntrianglelefteq;": 8940,
  "rightleftarrows;": 8644,
  "rightsquigarrow;": 8605,
  "rightthreetimes;": 8908,
  "straightepsilon;": 1013,
  "trianglerighteq;": 8885,
  "vartriangleleft;": 8882,
  "DiacriticalDot;": 729,
  "DoubleRightTee;": 8872,
  "DownLeftVector;": 8637,
  "GreaterGreater;": 10914,
  "HorizontalLine;": 9472,
  "InvisibleComma;": 8291,
  "InvisibleTimes;": 8290,
  "LeftDownVector;": 8643,
  "LeftRightArrow;": 8596,
  "Leftrightarrow;": 8660,
  "LessSlantEqual;": 10877,
  "LongRightArrow;": 10230,
  "Longrightarrow;": 10233,
  "LowerLeftArrow;": 8601,
  "NestedLessLess;": 8810,
  "NotGreaterLess;": 8825,
  "NotLessGreater;": 8824,
  "NotSubsetEqual;": 8840,
  "NotVerticalBar;": 8740,
  "OpenCurlyQuote;": 8216,
  "ReverseElement;": 8715,
  "RightTeeVector;": 10587,
  "RightVectorBar;": 10579,
  "ShortDownArrow;": 8595,
  "ShortLeftArrow;": 8592,
  "SquareSuperset;": 8848,
  "TildeFullEqual;": 8773,
  "UpperLeftArrow;": 8598,
  "ZeroWidthSpace;": 8203,
  "curvearrowleft;": 8630,
  "doublebarwedge;": 8966,
  "downdownarrows;": 8650,
  "hookrightarrow;": 8618,
  "leftleftarrows;": 8647,
  "leftrightarrow;": 8596,
  "leftthreetimes;": 8907,
  "longrightarrow;": 10230,
  "looparrowright;": 8620,
  "nshortparallel;": 8742,
  "ntriangleright;": 8939,
  "rightarrowtail;": 8611,
  "rightharpoonup;": 8640,
  "trianglelefteq;": 8884,
  "upharpoonright;": 8638,
  "ApplyFunction;": 8289,
  "DifferentialD;": 8518,
  "DoubleLeftTee;": 10980,
  "DoubleUpArrow;": 8657,
  "LeftTeeVector;": 10586,
  "LeftVectorBar;": 10578,
  "LessFullEqual;": 8806,
  "LongLeftArrow;": 10229,
  "Longleftarrow;": 10232,
  "NotEqualTilde;": 8770,
  "NotTildeEqual;": 8772,
  "NotTildeTilde;": 8777,
  "Poincareplane;": 8460,
  "PrecedesEqual;": 10927,
  "PrecedesTilde;": 8830,
  "RightArrowBar;": 8677,
  "RightTeeArrow;": 8614,
  "RightTriangle;": 8883,
  "RightUpVector;": 8638,
  "SucceedsEqual;": 10928,
  "SucceedsTilde;": 8831,
  "SupersetEqual;": 8839,
  "UpEquilibrium;": 10606,
  "VerticalTilde;": 8768,
  "VeryThinSpace;": 8202,
  "bigtriangleup;": 9651,
  "blacktriangle;": 9652,
  "divideontimes;": 8903,
  "fallingdotseq;": 8786,
  "hookleftarrow;": 8617,
  "leftarrowtail;": 8610,
  "leftharpoonup;": 8636,
  "longleftarrow;": 10229,
  "looparrowleft;": 8619,
  "measuredangle;": 8737,
  "ntriangleleft;": 8938,
  "shortparallel;": 8741,
  "smallsetminus;": 8726,
  "triangleright;": 9657,
  "upharpoonleft;": 8639,
  "varsubsetneqq;": 10955,
  "varsupsetneqq;": 10956,
  "DownArrowBar;": 10515,
  "DownTeeArrow;": 8615,
  "ExponentialE;": 8519,
  "GreaterEqual;": 8805,
  "GreaterTilde;": 8819,
  "HilbertSpace;": 8459,
  "HumpDownHump;": 8782,
  "Intersection;": 8898,
  "LeftArrowBar;": 8676,
  "LeftTeeArrow;": 8612,
  "LeftTriangle;": 8882,
  "LeftUpVector;": 8639,
  "NotCongruent;": 8802,
  "NotHumpEqual;": 8783,
  "NotLessEqual;": 8816,
  "NotLessTilde;": 8820,
  "Proportional;": 8733,
  "RightCeiling;": 8969,
  "RoundImplies;": 10608,
  "ShortUpArrow;": 8593,
  "SquareSubset;": 8847,
  "UnderBracket;": 9141,
  "VerticalLine;": 124,
  "blacklozenge;": 10731,
  "exponentiale;": 8519,
  "risingdotseq;": 8787,
  "triangledown;": 9663,
  "triangleleft;": 9667,
  "varsubsetneq;": 8842,
  "varsupsetneq;": 8843,
  "CircleMinus;": 8854,
  "CircleTimes;": 8855,
  "Equilibrium;": 8652,
  "GreaterLess;": 8823,
  "LeftCeiling;": 8968,
  "LessGreater;": 8822,
  "MediumSpace;": 8287,
  "NotLessLess;": 8810,
  "NotPrecedes;": 8832,
  "NotSucceeds;": 8833,
  "NotSuperset;": 8835,
  "OverBracket;": 9140,
  "RightVector;": 8640,
  "Rrightarrow;": 8667,
  "RuleDelayed;": 10740,
  "SmallCircle;": 8728,
  "SquareUnion;": 8852,
  "SubsetEqual;": 8838,
  "UpDownArrow;": 8597,
  "Updownarrow;": 8661,
  "VerticalBar;": 8739,
  "backepsilon;": 1014,
  "blacksquare;": 9642,
  "circledcirc;": 8858,
  "circleddash;": 8861,
  "curlyeqprec;": 8926,
  "curlyeqsucc;": 8927,
  "diamondsuit;": 9830,
  "eqslantless;": 10901,
  "expectation;": 8496,
  "nRightarrow;": 8655,
  "nrightarrow;": 8603,
  "preccurlyeq;": 8828,
  "precnapprox;": 10937,
  "quaternions;": 8461,
  "straightphi;": 981,
  "succcurlyeq;": 8829,
  "succnapprox;": 10938,
  "thickapprox;": 8776,
  "updownarrow;": 8597,
  "Bernoullis;": 8492,
  "CirclePlus;": 8853,
  "EqualTilde;": 8770,
  "Fouriertrf;": 8497,
  "ImaginaryI;": 8520,
  "Laplacetrf;": 8466,
  "LeftVector;": 8636,
  "Lleftarrow;": 8666,
  "NotElement;": 8713,
  "NotGreater;": 8815,
  "Proportion;": 8759,
  "RightArrow;": 8594,
  "RightFloor;": 8971,
  "Rightarrow;": 8658,
  "ThickSpace;": 8287,
  "TildeEqual;": 8771,
  "TildeTilde;": 8776,
  "UnderBrace;": 9183,
  "UpArrowBar;": 10514,
  "UpTeeArrow;": 8613,
  "circledast;": 8859,
  "complement;": 8705,
  "curlywedge;": 8911,
  "eqslantgtr;": 10902,
  "gtreqqless;": 10892,
  "lessapprox;": 10885,
  "lesseqqgtr;": 10891,
  "lmoustache;": 9136,
  "longmapsto;": 10236,
  "mapstodown;": 8615,
  "mapstoleft;": 8612,
  "nLeftarrow;": 8653,
  "nleftarrow;": 8602,
  "nsubseteqq;": 10949,
  "nsupseteqq;": 10950,
  "precapprox;": 10935,
  "rightarrow;": 8594,
  "rmoustache;": 9137,
  "sqsubseteq;": 8849,
  "sqsupseteq;": 8850,
  "subsetneqq;": 10955,
  "succapprox;": 10936,
  "supsetneqq;": 10956,
  "upuparrows;": 8648,
  "varepsilon;": 1013,
  "varnothing;": 8709,
  "Backslash;": 8726,
  "CenterDot;": 183,
  "CircleDot;": 8857,
  "Congruent;": 8801,
  "Coproduct;": 8720,
  "DoubleDot;": 168,
  "DownArrow;": 8595,
  "DownBreve;": 785,
  "Downarrow;": 8659,
  "HumpEqual;": 8783,
  "LeftArrow;": 8592,
  "LeftFloor;": 8970,
  "Leftarrow;": 8656,
  "LessTilde;": 8818,
  "Mellintrf;": 8499,
  "MinusPlus;": 8723,
  "NotCupCap;": 8813,
  "NotExists;": 8708,
  "NotSubset;": 8834,
  "OverBrace;": 9182,
  "PlusMinus;": 177,
  "Therefore;": 8756,
  "ThinSpace;": 8201,
  "TripleDot;": 8411,
  "UnionPlus;": 8846,
  "backprime;": 8245,
  "backsimeq;": 8909,
  "bigotimes;": 10754,
  "centerdot;": 183,
  "checkmark;": 10003,
  "complexes;": 8450,
  "dotsquare;": 8865,
  "downarrow;": 8595,
  "gtrapprox;": 10886,
  "gtreqless;": 8923,
  "gvertneqq;": 8809,
  "heartsuit;": 9829,
  "leftarrow;": 8592,
  "lesseqgtr;": 8922,
  "lvertneqq;": 8808,
  "ngeqslant;": 10878,
  "nleqslant;": 10877,
  "nparallel;": 8742,
  "nshortmid;": 8740,
  "nsubseteq;": 8840,
  "nsupseteq;": 8841,
  "pitchfork;": 8916,
  "rationals;": 8474,
  "spadesuit;": 9824,
  "subseteqq;": 10949,
  "subsetneq;": 8842,
  "supseteqq;": 10950,
  "supsetneq;": 8843,
  "therefore;": 8756,
  "triangleq;": 8796,
  "varpropto;": 8733,
  "DDotrahd;": 10513,
  "DotEqual;": 8784,
  "Integral;": 8747,
  "LessLess;": 10913,
  "NotEqual;": 8800,
  "NotTilde;": 8769,
  "PartialD;": 8706,
  "Precedes;": 8826,
  "RightTee;": 8866,
  "Succeeds;": 8827,
  "SuchThat;": 8715,
  "Superset;": 8835,
  "Uarrocir;": 10569,
  "UnderBar;": 95,
  "andslope;": 10840,
  "angmsdaa;": 10664,
  "angmsdab;": 10665,
  "angmsdac;": 10666,
  "angmsdad;": 10667,
  "angmsdae;": 10668,
  "angmsdaf;": 10669,
  "angmsdag;": 10670,
  "angmsdah;": 10671,
  "angrtvbd;": 10653,
  "approxeq;": 8778,
  "awconint;": 8755,
  "backcong;": 8780,
  "barwedge;": 8965,
  "bbrktbrk;": 9142,
  "bigoplus;": 10753,
  "bigsqcup;": 10758,
  "biguplus;": 10756,
  "bigwedge;": 8896,
  "boxminus;": 8863,
  "boxtimes;": 8864,
  "bsolhsub;": 10184,
  "capbrcup;": 10825,
  "circledR;": 174,
  "circledS;": 9416,
  "cirfnint;": 10768,
  "clubsuit;": 9827,
  "cupbrcap;": 10824,
  "curlyvee;": 8910,
  "cwconint;": 8754,
  "doteqdot;": 8785,
  "dotminus;": 8760,
  "drbkarow;": 10512,
  "dzigrarr;": 10239,
  "elinters;": 9191,
  "emptyset;": 8709,
  "eqvparsl;": 10725,
  "fpartint;": 10765,
  "geqslant;": 10878,
  "gesdotol;": 10884,
  "gnapprox;": 10890,
  "hksearow;": 10533,
  "hkswarow;": 10534,
  "imagline;": 8464,
  "imagpart;": 8465,
  "infintie;": 10717,
  "integers;": 8484,
  "intercal;": 8890,
  "intlarhk;": 10775,
  "laemptyv;": 10676,
  "ldrushar;": 10571,
  "leqslant;": 10877,
  "lesdotor;": 10883,
  "llcorner;": 8990,
  "lnapprox;": 10889,
  "lrcorner;": 8991,
  "lurdshar;": 10570,
  "mapstoup;": 8613,
  "multimap;": 8888,
  "naturals;": 8469,
  "ncongdot;": 10861,
  "notindot;": 8949,
  "otimesas;": 10806,
  "parallel;": 8741,
  "plusacir;": 10787,
  "pointint;": 10773,
  "precneqq;": 10933,
  "precnsim;": 8936,
  "profalar;": 9006,
  "profline;": 8978,
  "profsurf;": 8979,
  "raemptyv;": 10675,
  "realpart;": 8476,
  "rppolint;": 10770,
  "rtriltri;": 10702,
  "scpolint;": 10771,
  "setminus;": 8726,
  "shortmid;": 8739,
  "smeparsl;": 10724,
  "sqsubset;": 8847,
  "sqsupset;": 8848,
  "subseteq;": 8838,
  "succneqq;": 10934,
  "succnsim;": 8937,
  "supseteq;": 8839,
  "thetasym;": 977,
  "thicksim;": 8764,
  "timesbar;": 10801,
  "triangle;": 9653,
  "triminus;": 10810,
  "trpezium;": 9186,
  "ulcorner;": 8988,
  "urcorner;": 8989,
  "varkappa;": 1008,
  "varsigma;": 962,
  "vartheta;": 977,
  "Because;": 8757,
  "Cayleys;": 8493,
  "Cconint;": 8752,
  "Cedilla;": 184,
  "Diamond;": 8900,
  "DownTee;": 8868,
  "Element;": 8712,
  "Epsilon;": 917,
  "Implies;": 8658,
  "LeftTee;": 8867,
  "NewLine;": 10,
  "NoBreak;": 8288,
  "NotLess;": 8814,
  "Omicron;": 927,
  "OverBar;": 8254,
  "Product;": 8719,
  "UpArrow;": 8593,
  "Uparrow;": 8657,
  "Upsilon;": 933,
  "alefsym;": 8501,
  "angrtvb;": 8894,
  "angzarr;": 9084,
  "asympeq;": 8781,
  "backsim;": 8765,
  "because;": 8757,
  "bemptyv;": 10672,
  "between;": 8812,
  "bigcirc;": 9711,
  "bigodot;": 10752,
  "bigstar;": 9733,
  "bnequiv;": 8801,
  "boxplus;": 8862,
  "ccupssm;": 10832,
  "cemptyv;": 10674,
  "cirscir;": 10690,
  "coloneq;": 8788,
  "congdot;": 10861,
  "cudarrl;": 10552,
  "cudarrr;": 10549,
  "cularrp;": 10557,
  "curarrm;": 10556,
  "dbkarow;": 10511,
  "ddagger;": 8225,
  "ddotseq;": 10871,
  "demptyv;": 10673,
  "diamond;": 8900,
  "digamma;": 989,
  "dotplus;": 8724,
  "dwangle;": 10662,
  "epsilon;": 949,
  "eqcolon;": 8789,
  "equivDD;": 10872,
  "gesdoto;": 10882,
  "gtquest;": 10876,
  "gtrless;": 8823,
  "harrcir;": 10568,
  "intprod;": 10812,
  "isindot;": 8949,
  "larrbfs;": 10527,
  "larrsim;": 10611,
  "lbrksld;": 10639,
  "lbrkslu;": 10637,
  "ldrdhar;": 10599,
  "lesdoto;": 10881,
  "lessdot;": 8918,
  "lessgtr;": 8822,
  "lesssim;": 8818,
  "lotimes;": 10804,
  "lozenge;": 9674,
  "ltquest;": 10875,
  "luruhar;": 10598,
  "maltese;": 10016,
  "minusdu;": 10794,
  "napprox;": 8777,
  "natural;": 9838,
  "nearrow;": 8599,
  "nexists;": 8708,
  "notinva;": 8713,
  "notinvb;": 8951,
  "notinvc;": 8950,
  "notniva;": 8716,
  "notnivb;": 8958,
  "notnivc;": 8957,
  "npolint;": 10772,
  "npreceq;": 10927,
  "nsqsube;": 8930,
  "nsqsupe;": 8931,
  "nsubset;": 8834,
  "nsucceq;": 10928,
  "nsupset;": 8835,
  "nvinfin;": 10718,
  "nvltrie;": 8884,
  "nvrtrie;": 8885,
  "nwarrow;": 8598,
  "olcross;": 10683,
  "omicron;": 959,
  "orderof;": 8500,
  "orslope;": 10839,
  "pertenk;": 8241,
  "planckh;": 8462,
  "pluscir;": 10786,
  "plussim;": 10790,
  "plustwo;": 10791,
  "precsim;": 8830,
  "quatint;": 10774,
  "questeq;": 8799,
  "rarrbfs;": 10528,
  "rarrsim;": 10612,
  "rbrksld;": 10638,
  "rbrkslu;": 10640,
  "rdldhar;": 10601,
  "realine;": 8475,
  "rotimes;": 10805,
  "ruluhar;": 10600,
  "searrow;": 8600,
  "simplus;": 10788,
  "simrarr;": 10610,
  "subedot;": 10947,
  "submult;": 10945,
  "subplus;": 10943,
  "subrarr;": 10617,
  "succsim;": 8831,
  "supdsub;": 10968,
  "supedot;": 10948,
  "suphsol;": 10185,
  "suphsub;": 10967,
  "suplarr;": 10619,
  "supmult;": 10946,
  "supplus;": 10944,
  "swarrow;": 8601,
  "topfork;": 10970,
  "triplus;": 10809,
  "tritime;": 10811,
  "uparrow;": 8593,
  "upsilon;": 965,
  "uwangle;": 10663,
  "vzigzag;": 10650,
  "zigrarr;": 8669,
  "Aacute;": 193,
  "Abreve;": 258,
  "Agrave;": 192,
  "Assign;": 8788,
  "Atilde;": 195,
  "Barwed;": 8966,
  "Bumpeq;": 8782,
  "Cacute;": 262,
  "Ccaron;": 268,
  "Ccedil;": 199,
  "Colone;": 10868,
  "Conint;": 8751,
  "CupCap;": 8781,
  "Dagger;": 8225,
  "Dcaron;": 270,
  "DotDot;": 8412,
  "Dstrok;": 272,
  "Eacute;": 201,
  "Ecaron;": 282,
  "Egrave;": 200,
  "Exists;": 8707,
  "ForAll;": 8704,
  "Gammad;": 988,
  "Gbreve;": 286,
  "Gcedil;": 290,
  "HARDcy;": 1066,
  "Hstrok;": 294,
  "Iacute;": 205,
  "Igrave;": 204,
  "Itilde;": 296,
  "Jsercy;": 1032,
  "Kcedil;": 310,
  "Lacute;": 313,
  "Lambda;": 923,
  "Lcaron;": 317,
  "Lcedil;": 315,
  "Lmidot;": 319,
  "Lstrok;": 321,
  "Nacute;": 323,
  "Ncaron;": 327,
  "Ncedil;": 325,
  "Ntilde;": 209,
  "Oacute;": 211,
  "Odblac;": 336,
  "Ograve;": 210,
  "Oslash;": 216,
  "Otilde;": 213,
  "Otimes;": 10807,
  "Racute;": 340,
  "Rarrtl;": 10518,
  "Rcaron;": 344,
  "Rcedil;": 342,
  "SHCHcy;": 1065,
  "SOFTcy;": 1068,
  "Sacute;": 346,
  "Scaron;": 352,
  "Scedil;": 350,
  "Square;": 9633,
  "Subset;": 8912,
  "Supset;": 8913,
  "Tcaron;": 356,
  "Tcedil;": 354,
  "Tstrok;": 358,
  "Uacute;": 218,
  "Ubreve;": 364,
  "Udblac;": 368,
  "Ugrave;": 217,
  "Utilde;": 360,
  "Vdashl;": 10982,
  "Verbar;": 8214,
  "Vvdash;": 8874,
  "Yacute;": 221,
  "Zacute;": 377,
  "Zcaron;": 381,
  "aacute;": 225,
  "abreve;": 259,
  "agrave;": 224,
  "andand;": 10837,
  "angmsd;": 8737,
  "angsph;": 8738,
  "apacir;": 10863,
  "approx;": 8776,
  "atilde;": 227,
  "barvee;": 8893,
  "barwed;": 8965,
  "becaus;": 8757,
  "bernou;": 8492,
  "bigcap;": 8898,
  "bigcup;": 8899,
  "bigvee;": 8897,
  "bkarow;": 10509,
  "bottom;": 8869,
  "bowtie;": 8904,
  "boxbox;": 10697,
  "bprime;": 8245,
  "brvbar;": 166,
  "bullet;": 8226,
  "bumpeq;": 8783,
  "cacute;": 263,
  "capand;": 10820,
  "capcap;": 10827,
  "capcup;": 10823,
  "capdot;": 10816,
  "ccaron;": 269,
  "ccedil;": 231,
  "circeq;": 8791,
  "cirmid;": 10991,
  "colone;": 8788,
  "commat;": 64,
  "compfn;": 8728,
  "conint;": 8750,
  "coprod;": 8720,
  "copysr;": 8471,
  "cularr;": 8630,
  "cupcap;": 10822,
  "cupcup;": 10826,
  "cupdot;": 8845,
  "curarr;": 8631,
  "curren;": 164,
  "cylcty;": 9005,
  "dagger;": 8224,
  "daleth;": 8504,
  "dcaron;": 271,
  "dfisht;": 10623,
  "divide;": 247,
  "divonx;": 8903,
  "dlcorn;": 8990,
  "dlcrop;": 8973,
  "dollar;": 36,
  "drcorn;": 8991,
  "drcrop;": 8972,
  "dstrok;": 273,
  "eacute;": 233,
  "easter;": 10862,
  "ecaron;": 283,
  "ecolon;": 8789,
  "egrave;": 232,
  "egsdot;": 10904,
  "elsdot;": 10903,
  "emptyv;": 8709,
  "emsp13;": 8196,
  "emsp14;": 8197,
  "eparsl;": 10723,
  "eqcirc;": 8790,
  "equals;": 61,
  "equest;": 8799,
  "female;": 9792,
  "ffilig;": 64259,
  "ffllig;": 64260,
  "forall;": 8704,
  "frac12;": 189,
  "frac13;": 8531,
  "frac14;": 188,
  "frac15;": 8533,
  "frac16;": 8537,
  "frac18;": 8539,
  "frac23;": 8532,
  "frac25;": 8534,
  "frac34;": 190,
  "frac35;": 8535,
  "frac38;": 8540,
  "frac45;": 8536,
  "frac56;": 8538,
  "frac58;": 8541,
  "frac78;": 8542,
  "gacute;": 501,
  "gammad;": 989,
  "gbreve;": 287,
  "gesdot;": 10880,
  "gesles;": 10900,
  "gtlPar;": 10645,
  "gtrarr;": 10616,
  "gtrdot;": 8919,
  "gtrsim;": 8819,
  "hairsp;": 8202,
  "hamilt;": 8459,
  "hardcy;": 1098,
  "hearts;": 9829,
  "hellip;": 8230,
  "hercon;": 8889,
  "homtht;": 8763,
  "horbar;": 8213,
  "hslash;": 8463,
  "hstrok;": 295,
  "hybull;": 8259,
  "hyphen;": 8208,
  "iacute;": 237,
  "igrave;": 236,
  "iiiint;": 10764,
  "iinfin;": 10716,
  "incare;": 8453,
  "inodot;": 305,
  "intcal;": 8890,
  "iquest;": 191,
  "isinsv;": 8947,
  "itilde;": 297,
  "jsercy;": 1112,
  "kappav;": 1008,
  "kcedil;": 311,
  "kgreen;": 312,
  "lAtail;": 10523,
  "lacute;": 314,
  "lagran;": 8466,
  "lambda;": 955,
  "langle;": 10216,
  "larrfs;": 10525,
  "larrhk;": 8617,
  "larrlp;": 8619,
  "larrpl;": 10553,
  "larrtl;": 8610,
  "latail;": 10521,
  "lbrace;": 123,
  "lbrack;": 91,
  "lcaron;": 318,
  "lcedil;": 316,
  "ldquor;": 8222,
  "lesdot;": 10879,
  "lesges;": 10899,
  "lfisht;": 10620,
  "lfloor;": 8970,
  "lharul;": 10602,
  "llhard;": 10603,
  "lmidot;": 320,
  "lmoust;": 9136,
  "loplus;": 10797,
  "lowast;": 8727,
  "lowbar;": 95,
  "lparlt;": 10643,
  "lrhard;": 10605,
  "lsaquo;": 8249,
  "lsquor;": 8218,
  "lstrok;": 322,
  "lthree;": 8907,
  "ltimes;": 8905,
  "ltlarr;": 10614,
  "ltrPar;": 10646,
  "mapsto;": 8614,
  "marker;": 9646,
  "mcomma;": 10793,
  "midast;": 42,
  "midcir;": 10992,
  "middot;": 183,
  "minusb;": 8863,
  "minusd;": 8760,
  "mnplus;": 8723,
  "models;": 8871,
  "mstpos;": 8766,
  "nVDash;": 8879,
  "nVdash;": 8878,
  "nacute;": 324,
  "nbumpe;": 8783,
  "ncaron;": 328,
  "ncedil;": 326,
  "nearhk;": 10532,
  "nequiv;": 8802,
  "nesear;": 10536,
  "nexist;": 8708,
  "nltrie;": 8940,
  "notinE;": 8953,
  "nparsl;": 11005,
  "nprcue;": 8928,
  "nrarrc;": 10547,
  "nrarrw;": 8605,
  "nrtrie;": 8941,
  "nsccue;": 8929,
  "nsimeq;": 8772,
  "ntilde;": 241,
  "numero;": 8470,
  "nvDash;": 8877,
  "nvHarr;": 10500,
  "nvdash;": 8876,
  "nvlArr;": 10498,
  "nvrArr;": 10499,
  "nwarhk;": 10531,
  "nwnear;": 10535,
  "oacute;": 243,
  "odblac;": 337,
  "odsold;": 10684,
  "ograve;": 242,
  "ominus;": 8854,
  "origof;": 8886,
  "oslash;": 248,
  "otilde;": 245,
  "otimes;": 8855,
  "parsim;": 10995,
  "percnt;": 37,
  "period;": 46,
  "permil;": 8240,
  "phmmat;": 8499,
  "planck;": 8463,
  "plankv;": 8463,
  "plusdo;": 8724,
  "plusdu;": 10789,
  "plusmn;": 177,
  "preceq;": 10927,
  "primes;": 8473,
  "prnsim;": 8936,
  "propto;": 8733,
  "prurel;": 8880,
  "puncsp;": 8200,
  "qprime;": 8279,
  "rAtail;": 10524,
  "racute;": 341,
  "rangle;": 10217,
  "rarrap;": 10613,
  "rarrfs;": 10526,
  "rarrhk;": 8618,
  "rarrlp;": 8620,
  "rarrpl;": 10565,
  "rarrtl;": 8611,
  "ratail;": 10522,
  "rbrace;": 125,
  "rbrack;": 93,
  "rcaron;": 345,
  "rcedil;": 343,
  "rdquor;": 8221,
  "rfisht;": 10621,
  "rfloor;": 8971,
  "rharul;": 10604,
  "rmoust;": 9137,
  "roplus;": 10798,
  "rpargt;": 10644,
  "rsaquo;": 8250,
  "rsquor;": 8217,
  "rthree;": 8908,
  "rtimes;": 8906,
  "sacute;": 347,
  "scaron;": 353,
  "scedil;": 351,
  "scnsim;": 8937,
  "searhk;": 10533,
  "seswar;": 10537,
  "sfrown;": 8994,
  "shchcy;": 1097,
  "sigmaf;": 962,
  "sigmav;": 962,
  "simdot;": 10858,
  "smashp;": 10803,
  "softcy;": 1100,
  "solbar;": 9023,
  "spades;": 9824,
  "sqcaps;": 8851,
  "sqcups;": 8852,
  "sqsube;": 8849,
  "sqsupe;": 8850,
  "square;": 9633,
  "squarf;": 9642,
  "ssetmn;": 8726,
  "ssmile;": 8995,
  "sstarf;": 8902,
  "subdot;": 10941,
  "subset;": 8834,
  "subsim;": 10951,
  "subsub;": 10965,
  "subsup;": 10963,
  "succeq;": 10928,
  "supdot;": 10942,
  "supset;": 8835,
  "supsim;": 10952,
  "supsub;": 10964,
  "supsup;": 10966,
  "swarhk;": 10534,
  "swnwar;": 10538,
  "target;": 8982,
  "tcaron;": 357,
  "tcedil;": 355,
  "telrec;": 8981,
  "there4;": 8756,
  "thetav;": 977,
  "thinsp;": 8201,
  "thksim;": 8764,
  "timesb;": 8864,
  "timesd;": 10800,
  "topbot;": 9014,
  "topcir;": 10993,
  "tprime;": 8244,
  "tridot;": 9708,
  "tstrok;": 359,
  "uacute;": 250,
  "ubreve;": 365,
  "udblac;": 369,
  "ufisht;": 10622,
  "ugrave;": 249,
  "ulcorn;": 8988,
  "ulcrop;": 8975,
  "urcorn;": 8989,
  "urcrop;": 8974,
  "utilde;": 361,
  "vangrt;": 10652,
  "varphi;": 981,
  "varrho;": 1009,
  "veebar;": 8891,
  "vellip;": 8942,
  "verbar;": 124,
  "vsubnE;": 10955,
  "vsubne;": 8842,
  "vsupnE;": 10956,
  "vsupne;": 8843,
  "wedbar;": 10847,
  "wedgeq;": 8793,
  "weierp;": 8472,
  "wreath;": 8768,
  "xoplus;": 10753,
  "xotime;": 10754,
  "xsqcup;": 10758,
  "xuplus;": 10756,
  "xwedge;": 8896,
  "yacute;": 253,
  "zacute;": 378,
  "zcaron;": 382,
  "zeetrf;": 8488,
  "AElig;": 198,
  Aacute: 193,
  "Acirc;": 194,
  Agrave: 192,
  "Alpha;": 913,
  "Amacr;": 256,
  "Aogon;": 260,
  "Aring;": 197,
  Atilde: 195,
  "Breve;": 728,
  Ccedil: 199,
  "Ccirc;": 264,
  "Colon;": 8759,
  "Cross;": 10799,
  "Dashv;": 10980,
  "Delta;": 916,
  Eacute: 201,
  "Ecirc;": 202,
  Egrave: 200,
  "Emacr;": 274,
  "Eogon;": 280,
  "Equal;": 10869,
  "Gamma;": 915,
  "Gcirc;": 284,
  "Hacek;": 711,
  "Hcirc;": 292,
  "IJlig;": 306,
  Iacute: 205,
  "Icirc;": 206,
  Igrave: 204,
  "Imacr;": 298,
  "Iogon;": 302,
  "Iukcy;": 1030,
  "Jcirc;": 308,
  "Jukcy;": 1028,
  "Kappa;": 922,
  Ntilde: 209,
  "OElig;": 338,
  Oacute: 211,
  "Ocirc;": 212,
  Ograve: 210,
  "Omacr;": 332,
  "Omega;": 937,
  Oslash: 216,
  Otilde: 213,
  "Prime;": 8243,
  "RBarr;": 10512,
  "Scirc;": 348,
  "Sigma;": 931,
  "THORN;": 222,
  "TRADE;": 8482,
  "TSHcy;": 1035,
  "Theta;": 920,
  "Tilde;": 8764,
  Uacute: 218,
  "Ubrcy;": 1038,
  "Ucirc;": 219,
  Ugrave: 217,
  "Umacr;": 362,
  "Union;": 8899,
  "Uogon;": 370,
  "UpTee;": 8869,
  "Uring;": 366,
  "VDash;": 8875,
  "Vdash;": 8873,
  "Wcirc;": 372,
  "Wedge;": 8896,
  Yacute: 221,
  "Ycirc;": 374,
  aacute: 225,
  "acirc;": 226,
  "acute;": 180,
  "aelig;": 230,
  agrave: 224,
  "aleph;": 8501,
  "alpha;": 945,
  "amacr;": 257,
  "amalg;": 10815,
  "angle;": 8736,
  "angrt;": 8735,
  "angst;": 197,
  "aogon;": 261,
  "aring;": 229,
  "asymp;": 8776,
  atilde: 227,
  "awint;": 10769,
  "bcong;": 8780,
  "bdquo;": 8222,
  "bepsi;": 1014,
  "blank;": 9251,
  "blk12;": 9618,
  "blk14;": 9617,
  "blk34;": 9619,
  "block;": 9608,
  "boxDL;": 9559,
  "boxDR;": 9556,
  "boxDl;": 9558,
  "boxDr;": 9555,
  "boxHD;": 9574,
  "boxHU;": 9577,
  "boxHd;": 9572,
  "boxHu;": 9575,
  "boxUL;": 9565,
  "boxUR;": 9562,
  "boxUl;": 9564,
  "boxUr;": 9561,
  "boxVH;": 9580,
  "boxVL;": 9571,
  "boxVR;": 9568,
  "boxVh;": 9579,
  "boxVl;": 9570,
  "boxVr;": 9567,
  "boxdL;": 9557,
  "boxdR;": 9554,
  "boxdl;": 9488,
  "boxdr;": 9484,
  "boxhD;": 9573,
  "boxhU;": 9576,
  "boxhd;": 9516,
  "boxhu;": 9524,
  "boxuL;": 9563,
  "boxuR;": 9560,
  "boxul;": 9496,
  "boxur;": 9492,
  "boxvH;": 9578,
  "boxvL;": 9569,
  "boxvR;": 9566,
  "boxvh;": 9532,
  "boxvl;": 9508,
  "boxvr;": 9500,
  "breve;": 728,
  brvbar: 166,
  "bsemi;": 8271,
  "bsime;": 8909,
  "bsolb;": 10693,
  "bumpE;": 10926,
  "bumpe;": 8783,
  "caret;": 8257,
  "caron;": 711,
  "ccaps;": 10829,
  ccedil: 231,
  "ccirc;": 265,
  "ccups;": 10828,
  "cedil;": 184,
  "check;": 10003,
  "clubs;": 9827,
  "colon;": 58,
  "comma;": 44,
  "crarr;": 8629,
  "cross;": 10007,
  "csube;": 10961,
  "csupe;": 10962,
  "ctdot;": 8943,
  "cuepr;": 8926,
  "cuesc;": 8927,
  "cupor;": 10821,
  curren: 164,
  "cuvee;": 8910,
  "cuwed;": 8911,
  "cwint;": 8753,
  "dashv;": 8867,
  "dblac;": 733,
  "ddarr;": 8650,
  "delta;": 948,
  "dharl;": 8643,
  "dharr;": 8642,
  "diams;": 9830,
  "disin;": 8946,
  divide: 247,
  "doteq;": 8784,
  "dtdot;": 8945,
  "dtrif;": 9662,
  "duarr;": 8693,
  "duhar;": 10607,
  "eDDot;": 10871,
  eacute: 233,
  "ecirc;": 234,
  "efDot;": 8786,
  egrave: 232,
  "emacr;": 275,
  "empty;": 8709,
  "eogon;": 281,
  "eplus;": 10865,
  "epsiv;": 1013,
  "eqsim;": 8770,
  "equiv;": 8801,
  "erDot;": 8787,
  "erarr;": 10609,
  "esdot;": 8784,
  "exist;": 8707,
  "fflig;": 64256,
  "filig;": 64257,
  "fjlig;": 102,
  "fllig;": 64258,
  "fltns;": 9649,
  "forkv;": 10969,
  frac12: 189,
  frac14: 188,
  frac34: 190,
  "frasl;": 8260,
  "frown;": 8994,
  "gamma;": 947,
  "gcirc;": 285,
  "gescc;": 10921,
  "gimel;": 8503,
  "gneqq;": 8809,
  "gnsim;": 8935,
  "grave;": 96,
  "gsime;": 10894,
  "gsiml;": 10896,
  "gtcir;": 10874,
  "gtdot;": 8919,
  "harrw;": 8621,
  "hcirc;": 293,
  "hoarr;": 8703,
  iacute: 237,
  "icirc;": 238,
  "iexcl;": 161,
  igrave: 236,
  "iiint;": 8749,
  "iiota;": 8489,
  "ijlig;": 307,
  "imacr;": 299,
  "image;": 8465,
  "imath;": 305,
  "imped;": 437,
  "infin;": 8734,
  "iogon;": 303,
  "iprod;": 10812,
  iquest: 191,
  "isinE;": 8953,
  "isins;": 8948,
  "isinv;": 8712,
  "iukcy;": 1110,
  "jcirc;": 309,
  "jmath;": 567,
  "jukcy;": 1108,
  "kappa;": 954,
  "lAarr;": 8666,
  "lBarr;": 10510,
  "langd;": 10641,
  "laquo;": 171,
  "larrb;": 8676,
  "lates;": 10925,
  "lbarr;": 10508,
  "lbbrk;": 10098,
  "lbrke;": 10635,
  "lceil;": 8968,
  "ldquo;": 8220,
  "lescc;": 10920,
  "lhard;": 8637,
  "lharu;": 8636,
  "lhblk;": 9604,
  "llarr;": 8647,
  "lltri;": 9722,
  "lneqq;": 8808,
  "lnsim;": 8934,
  "loang;": 10220,
  "loarr;": 8701,
  "lobrk;": 10214,
  "lopar;": 10629,
  "lrarr;": 8646,
  "lrhar;": 8651,
  "lrtri;": 8895,
  "lsime;": 10893,
  "lsimg;": 10895,
  "lsquo;": 8216,
  "ltcir;": 10873,
  "ltdot;": 8918,
  "ltrie;": 8884,
  "ltrif;": 9666,
  "mDDot;": 8762,
  "mdash;": 8212,
  "micro;": 181,
  middot: 183,
  "minus;": 8722,
  "mumap;": 8888,
  "nabla;": 8711,
  "napid;": 8779,
  "napos;": 329,
  "natur;": 9838,
  "nbump;": 8782,
  "ncong;": 8775,
  "ndash;": 8211,
  "neArr;": 8663,
  "nearr;": 8599,
  "nedot;": 8784,
  "nesim;": 8770,
  "ngeqq;": 8807,
  "ngsim;": 8821,
  "nhArr;": 8654,
  "nharr;": 8622,
  "nhpar;": 10994,
  "nlArr;": 8653,
  "nlarr;": 8602,
  "nleqq;": 8806,
  "nless;": 8814,
  "nlsim;": 8820,
  "nltri;": 8938,
  "notin;": 8713,
  "notni;": 8716,
  "npart;": 8706,
  "nprec;": 8832,
  "nrArr;": 8655,
  "nrarr;": 8603,
  "nrtri;": 8939,
  "nsime;": 8772,
  "nsmid;": 8740,
  "nspar;": 8742,
  "nsubE;": 10949,
  "nsube;": 8840,
  "nsucc;": 8833,
  "nsupE;": 10950,
  "nsupe;": 8841,
  ntilde: 241,
  "numsp;": 8199,
  "nvsim;": 8764,
  "nwArr;": 8662,
  "nwarr;": 8598,
  oacute: 243,
  "ocirc;": 244,
  "odash;": 8861,
  "oelig;": 339,
  "ofcir;": 10687,
  ograve: 242,
  "ohbar;": 10677,
  "olarr;": 8634,
  "olcir;": 10686,
  "oline;": 8254,
  "omacr;": 333,
  "omega;": 969,
  "operp;": 10681,
  "oplus;": 8853,
  "orarr;": 8635,
  "order;": 8500,
  oslash: 248,
  otilde: 245,
  "ovbar;": 9021,
  "parsl;": 11005,
  "phone;": 9742,
  "plusb;": 8862,
  "pluse;": 10866,
  plusmn: 177,
  "pound;": 163,
  "prcue;": 8828,
  "prime;": 8242,
  "prnap;": 10937,
  "prsim;": 8830,
  "quest;": 63,
  "rAarr;": 8667,
  "rBarr;": 10511,
  "radic;": 8730,
  "rangd;": 10642,
  "range;": 10661,
  "raquo;": 187,
  "rarrb;": 8677,
  "rarrc;": 10547,
  "rarrw;": 8605,
  "ratio;": 8758,
  "rbarr;": 10509,
  "rbbrk;": 10099,
  "rbrke;": 10636,
  "rceil;": 8969,
  "rdquo;": 8221,
  "reals;": 8477,
  "rhard;": 8641,
  "rharu;": 8640,
  "rlarr;": 8644,
  "rlhar;": 8652,
  "rnmid;": 10990,
  "roang;": 10221,
  "roarr;": 8702,
  "robrk;": 10215,
  "ropar;": 10630,
  "rrarr;": 8649,
  "rsquo;": 8217,
  "rtrie;": 8885,
  "rtrif;": 9656,
  "sbquo;": 8218,
  "sccue;": 8829,
  "scirc;": 349,
  "scnap;": 10938,
  "scsim;": 8831,
  "sdotb;": 8865,
  "sdote;": 10854,
  "seArr;": 8664,
  "searr;": 8600,
  "setmn;": 8726,
  "sharp;": 9839,
  "sigma;": 963,
  "simeq;": 8771,
  "simgE;": 10912,
  "simlE;": 10911,
  "simne;": 8774,
  "slarr;": 8592,
  "smile;": 8995,
  "smtes;": 10924,
  "sqcap;": 8851,
  "sqcup;": 8852,
  "sqsub;": 8847,
  "sqsup;": 8848,
  "srarr;": 8594,
  "starf;": 9733,
  "strns;": 175,
  "subnE;": 10955,
  "subne;": 8842,
  "supnE;": 10956,
  "supne;": 8843,
  "swArr;": 8665,
  "swarr;": 8601,
  "szlig;": 223,
  "theta;": 952,
  "thkap;": 8776,
  "thorn;": 254,
  "tilde;": 732,
  "times;": 215,
  "trade;": 8482,
  "trisb;": 10701,
  "tshcy;": 1115,
  "twixt;": 8812,
  uacute: 250,
  "ubrcy;": 1118,
  "ucirc;": 251,
  "udarr;": 8645,
  "udhar;": 10606,
  ugrave: 249,
  "uharl;": 8639,
  "uharr;": 8638,
  "uhblk;": 9600,
  "ultri;": 9720,
  "umacr;": 363,
  "uogon;": 371,
  "uplus;": 8846,
  "upsih;": 978,
  "uring;": 367,
  "urtri;": 9721,
  "utdot;": 8944,
  "utrif;": 9652,
  "uuarr;": 8648,
  "vBarv;": 10985,
  "vDash;": 8872,
  "varpi;": 982,
  "vdash;": 8866,
  "veeeq;": 8794,
  "vltri;": 8882,
  "vnsub;": 8834,
  "vnsup;": 8835,
  "vprop;": 8733,
  "vrtri;": 8883,
  "wcirc;": 373,
  "wedge;": 8743,
  "xcirc;": 9711,
  "xdtri;": 9661,
  "xhArr;": 10234,
  "xharr;": 10231,
  "xlArr;": 10232,
  "xlarr;": 10229,
  "xodot;": 10752,
  "xrArr;": 10233,
  "xrarr;": 10230,
  "xutri;": 9651,
  yacute: 253,
  "ycirc;": 375,
  AElig: 198,
  Acirc: 194,
  "Aopf;": 120120,
  Aring: 197,
  "Ascr;": 119964,
  "Auml;": 196,
  "Barv;": 10983,
  "Beta;": 914,
  "Bopf;": 120121,
  "Bscr;": 8492,
  "CHcy;": 1063,
  "COPY;": 169,
  "Cdot;": 266,
  "Copf;": 8450,
  "Cscr;": 119966,
  "DJcy;": 1026,
  "DScy;": 1029,
  "DZcy;": 1039,
  "Darr;": 8609,
  "Dopf;": 120123,
  "Dscr;": 119967,
  Ecirc: 202,
  "Edot;": 278,
  "Eopf;": 120124,
  "Escr;": 8496,
  "Esim;": 10867,
  "Euml;": 203,
  "Fopf;": 120125,
  "Fscr;": 8497,
  "GJcy;": 1027,
  "Gdot;": 288,
  "Gopf;": 120126,
  "Gscr;": 119970,
  "Hopf;": 8461,
  "Hscr;": 8459,
  "IEcy;": 1045,
  "IOcy;": 1025,
  Icirc: 206,
  "Idot;": 304,
  "Iopf;": 120128,
  "Iota;": 921,
  "Iscr;": 8464,
  "Iuml;": 207,
  "Jopf;": 120129,
  "Jscr;": 119973,
  "KHcy;": 1061,
  "KJcy;": 1036,
  "Kopf;": 120130,
  "Kscr;": 119974,
  "LJcy;": 1033,
  "Lang;": 10218,
  "Larr;": 8606,
  "Lopf;": 120131,
  "Lscr;": 8466,
  "Mopf;": 120132,
  "Mscr;": 8499,
  "NJcy;": 1034,
  "Nopf;": 8469,
  "Nscr;": 119977,
  Ocirc: 212,
  "Oopf;": 120134,
  "Oscr;": 119978,
  "Ouml;": 214,
  "Popf;": 8473,
  "Pscr;": 119979,
  "QUOT;": 34,
  "Qopf;": 8474,
  "Qscr;": 119980,
  "Rang;": 10219,
  "Rarr;": 8608,
  "Ropf;": 8477,
  "Rscr;": 8475,
  "SHcy;": 1064,
  "Sopf;": 120138,
  "Sqrt;": 8730,
  "Sscr;": 119982,
  "Star;": 8902,
  THORN: 222,
  "TScy;": 1062,
  "Topf;": 120139,
  "Tscr;": 119983,
  "Uarr;": 8607,
  Ucirc: 219,
  "Uopf;": 120140,
  "Upsi;": 978,
  "Uscr;": 119984,
  "Uuml;": 220,
  "Vbar;": 10987,
  "Vert;": 8214,
  "Vopf;": 120141,
  "Vscr;": 119985,
  "Wopf;": 120142,
  "Wscr;": 119986,
  "Xopf;": 120143,
  "Xscr;": 119987,
  "YAcy;": 1071,
  "YIcy;": 1031,
  "YUcy;": 1070,
  "Yopf;": 120144,
  "Yscr;": 119988,
  "Yuml;": 376,
  "ZHcy;": 1046,
  "Zdot;": 379,
  "Zeta;": 918,
  "Zopf;": 8484,
  "Zscr;": 119989,
  acirc: 226,
  acute: 180,
  aelig: 230,
  "andd;": 10844,
  "andv;": 10842,
  "ange;": 10660,
  "aopf;": 120146,
  "apid;": 8779,
  "apos;": 39,
  aring: 229,
  "ascr;": 119990,
  "auml;": 228,
  "bNot;": 10989,
  "bbrk;": 9141,
  "beta;": 946,
  "beth;": 8502,
  "bnot;": 8976,
  "bopf;": 120147,
  "boxH;": 9552,
  "boxV;": 9553,
  "boxh;": 9472,
  "boxv;": 9474,
  "bscr;": 119991,
  "bsim;": 8765,
  "bsol;": 92,
  "bull;": 8226,
  "bump;": 8782,
  "caps;": 8745,
  "cdot;": 267,
  cedil: 184,
  "cent;": 162,
  "chcy;": 1095,
  "cirE;": 10691,
  "circ;": 710,
  "cire;": 8791,
  "comp;": 8705,
  "cong;": 8773,
  "copf;": 120148,
  "copy;": 169,
  "cscr;": 119992,
  "csub;": 10959,
  "csup;": 10960,
  "cups;": 8746,
  "dArr;": 8659,
  "dHar;": 10597,
  "darr;": 8595,
  "dash;": 8208,
  "diam;": 8900,
  "djcy;": 1106,
  "dopf;": 120149,
  "dscr;": 119993,
  "dscy;": 1109,
  "dsol;": 10742,
  "dtri;": 9663,
  "dzcy;": 1119,
  "eDot;": 8785,
  "ecir;": 8790,
  ecirc: 234,
  "edot;": 279,
  "emsp;": 8195,
  "ensp;": 8194,
  "eopf;": 120150,
  "epar;": 8917,
  "epsi;": 949,
  "escr;": 8495,
  "esim;": 8770,
  "euml;": 235,
  "euro;": 8364,
  "excl;": 33,
  "flat;": 9837,
  "fnof;": 402,
  "fopf;": 120151,
  "fork;": 8916,
  "fscr;": 119995,
  "gdot;": 289,
  "geqq;": 8807,
  "gesl;": 8923,
  "gjcy;": 1107,
  "gnap;": 10890,
  "gneq;": 10888,
  "gopf;": 120152,
  "gscr;": 8458,
  "gsim;": 8819,
  "gtcc;": 10919,
  "gvnE;": 8809,
  "hArr;": 8660,
  "half;": 189,
  "harr;": 8596,
  "hbar;": 8463,
  "hopf;": 120153,
  "hscr;": 119997,
  icirc: 238,
  "iecy;": 1077,
  iexcl: 161,
  "imof;": 8887,
  "iocy;": 1105,
  "iopf;": 120154,
  "iota;": 953,
  "iscr;": 119998,
  "isin;": 8712,
  "iuml;": 239,
  "jopf;": 120155,
  "jscr;": 119999,
  "khcy;": 1093,
  "kjcy;": 1116,
  "kopf;": 120156,
  "kscr;": 12e4,
  "lArr;": 8656,
  "lHar;": 10594,
  "lang;": 10216,
  laquo: 171,
  "larr;": 8592,
  "late;": 10925,
  "lcub;": 123,
  "ldca;": 10550,
  "ldsh;": 8626,
  "leqq;": 8806,
  "lesg;": 8922,
  "ljcy;": 1113,
  "lnap;": 10889,
  "lneq;": 10887,
  "lopf;": 120157,
  "lozf;": 10731,
  "lpar;": 40,
  "lscr;": 120001,
  "lsim;": 8818,
  "lsqb;": 91,
  "ltcc;": 10918,
  "ltri;": 9667,
  "lvnE;": 8808,
  "macr;": 175,
  "male;": 9794,
  "malt;": 10016,
  micro: 181,
  "mlcp;": 10971,
  "mldr;": 8230,
  "mopf;": 120158,
  "mscr;": 120002,
  "nGtv;": 8811,
  "nLtv;": 8810,
  "nang;": 8736,
  "napE;": 10864,
  "nbsp;": 160,
  "ncap;": 10819,
  "ncup;": 10818,
  "ngeq;": 8817,
  "nges;": 10878,
  "ngtr;": 8815,
  "nisd;": 8954,
  "njcy;": 1114,
  "nldr;": 8229,
  "nleq;": 8816,
  "nles;": 10877,
  "nmid;": 8740,
  "nopf;": 120159,
  "npar;": 8742,
  "npre;": 10927,
  "nsce;": 10928,
  "nscr;": 120003,
  "nsim;": 8769,
  "nsub;": 8836,
  "nsup;": 8837,
  "ntgl;": 8825,
  "ntlg;": 8824,
  "nvap;": 8781,
  "nvge;": 8805,
  "nvgt;": 62,
  "nvle;": 8804,
  "nvlt;": 60,
  "oast;": 8859,
  "ocir;": 8858,
  ocirc: 244,
  "odiv;": 10808,
  "odot;": 8857,
  "ogon;": 731,
  "oint;": 8750,
  "omid;": 10678,
  "oopf;": 120160,
  "opar;": 10679,
  "ordf;": 170,
  "ordm;": 186,
  "oror;": 10838,
  "oscr;": 8500,
  "osol;": 8856,
  "ouml;": 246,
  "para;": 182,
  "part;": 8706,
  "perp;": 8869,
  "phiv;": 981,
  "plus;": 43,
  "popf;": 120161,
  pound: 163,
  "prap;": 10935,
  "prec;": 8826,
  "prnE;": 10933,
  "prod;": 8719,
  "prop;": 8733,
  "pscr;": 120005,
  "qint;": 10764,
  "qopf;": 120162,
  "qscr;": 120006,
  "quot;": 34,
  "rArr;": 8658,
  "rHar;": 10596,
  "race;": 8765,
  "rang;": 10217,
  raquo: 187,
  "rarr;": 8594,
  "rcub;": 125,
  "rdca;": 10551,
  "rdsh;": 8627,
  "real;": 8476,
  "rect;": 9645,
  "rhov;": 1009,
  "ring;": 730,
  "ropf;": 120163,
  "rpar;": 41,
  "rscr;": 120007,
  "rsqb;": 93,
  "rtri;": 9657,
  "scap;": 10936,
  "scnE;": 10934,
  "sdot;": 8901,
  "sect;": 167,
  "semi;": 59,
  "sext;": 10038,
  "shcy;": 1096,
  "sime;": 8771,
  "simg;": 10910,
  "siml;": 10909,
  "smid;": 8739,
  "smte;": 10924,
  "solb;": 10692,
  "sopf;": 120164,
  "spar;": 8741,
  "squf;": 9642,
  "sscr;": 120008,
  "star;": 9734,
  "subE;": 10949,
  "sube;": 8838,
  "succ;": 8827,
  "sung;": 9834,
  "sup1;": 185,
  "sup2;": 178,
  "sup3;": 179,
  "supE;": 10950,
  "supe;": 8839,
  szlig: 223,
  "tbrk;": 9140,
  "tdot;": 8411,
  thorn: 254,
  times: 215,
  "tint;": 8749,
  "toea;": 10536,
  "topf;": 120165,
  "tosa;": 10537,
  "trie;": 8796,
  "tscr;": 120009,
  "tscy;": 1094,
  "uArr;": 8657,
  "uHar;": 10595,
  "uarr;": 8593,
  ucirc: 251,
  "uopf;": 120166,
  "upsi;": 965,
  "uscr;": 120010,
  "utri;": 9653,
  "uuml;": 252,
  "vArr;": 8661,
  "vBar;": 10984,
  "varr;": 8597,
  "vert;": 124,
  "vopf;": 120167,
  "vscr;": 120011,
  "wopf;": 120168,
  "wscr;": 120012,
  "xcap;": 8898,
  "xcup;": 8899,
  "xmap;": 10236,
  "xnis;": 8955,
  "xopf;": 120169,
  "xscr;": 120013,
  "xvee;": 8897,
  "yacy;": 1103,
  "yicy;": 1111,
  "yopf;": 120170,
  "yscr;": 120014,
  "yucy;": 1102,
  "yuml;": 255,
  "zdot;": 380,
  "zeta;": 950,
  "zhcy;": 1078,
  "zopf;": 120171,
  "zscr;": 120015,
  "zwnj;": 8204,
  "AMP;": 38,
  "Acy;": 1040,
  "Afr;": 120068,
  "And;": 10835,
  Auml: 196,
  "Bcy;": 1041,
  "Bfr;": 120069,
  COPY: 169,
  "Cap;": 8914,
  "Cfr;": 8493,
  "Chi;": 935,
  "Cup;": 8915,
  "Dcy;": 1044,
  "Del;": 8711,
  "Dfr;": 120071,
  "Dot;": 168,
  "ENG;": 330,
  "ETH;": 208,
  "Ecy;": 1069,
  "Efr;": 120072,
  "Eta;": 919,
  Euml: 203,
  "Fcy;": 1060,
  "Ffr;": 120073,
  "Gcy;": 1043,
  "Gfr;": 120074,
  "Hat;": 94,
  "Hfr;": 8460,
  "Icy;": 1048,
  "Ifr;": 8465,
  "Int;": 8748,
  Iuml: 207,
  "Jcy;": 1049,
  "Jfr;": 120077,
  "Kcy;": 1050,
  "Kfr;": 120078,
  "Lcy;": 1051,
  "Lfr;": 120079,
  "Lsh;": 8624,
  "Map;": 10501,
  "Mcy;": 1052,
  "Mfr;": 120080,
  "Ncy;": 1053,
  "Nfr;": 120081,
  "Not;": 10988,
  "Ocy;": 1054,
  "Ofr;": 120082,
  Ouml: 214,
  "Pcy;": 1055,
  "Pfr;": 120083,
  "Phi;": 934,
  "Psi;": 936,
  QUOT: 34,
  "Qfr;": 120084,
  "REG;": 174,
  "Rcy;": 1056,
  "Rfr;": 8476,
  "Rho;": 929,
  "Rsh;": 8625,
  "Scy;": 1057,
  "Sfr;": 120086,
  "Sub;": 8912,
  "Sum;": 8721,
  "Sup;": 8913,
  "Tab;": 9,
  "Tau;": 932,
  "Tcy;": 1058,
  "Tfr;": 120087,
  "Ucy;": 1059,
  "Ufr;": 120088,
  Uuml: 220,
  "Vcy;": 1042,
  "Vee;": 8897,
  "Vfr;": 120089,
  "Wfr;": 120090,
  "Xfr;": 120091,
  "Ycy;": 1067,
  "Yfr;": 120092,
  "Zcy;": 1047,
  "Zfr;": 8488,
  "acE;": 8766,
  "acd;": 8767,
  "acy;": 1072,
  "afr;": 120094,
  "amp;": 38,
  "and;": 8743,
  "ang;": 8736,
  "apE;": 10864,
  "ape;": 8778,
  "ast;": 42,
  auml: 228,
  "bcy;": 1073,
  "bfr;": 120095,
  "bne;": 61,
  "bot;": 8869,
  "cap;": 8745,
  cent: 162,
  "cfr;": 120096,
  "chi;": 967,
  "cir;": 9675,
  copy: 169,
  "cup;": 8746,
  "dcy;": 1076,
  "deg;": 176,
  "dfr;": 120097,
  "die;": 168,
  "div;": 247,
  "dot;": 729,
  "ecy;": 1101,
  "efr;": 120098,
  "egs;": 10902,
  "ell;": 8467,
  "els;": 10901,
  "eng;": 331,
  "eta;": 951,
  "eth;": 240,
  euml: 235,
  "fcy;": 1092,
  "ffr;": 120099,
  "gEl;": 10892,
  "gap;": 10886,
  "gcy;": 1075,
  "gel;": 8923,
  "geq;": 8805,
  "ges;": 10878,
  "gfr;": 120100,
  "ggg;": 8921,
  "glE;": 10898,
  "gla;": 10917,
  "glj;": 10916,
  "gnE;": 8809,
  "gne;": 10888,
  "hfr;": 120101,
  "icy;": 1080,
  "iff;": 8660,
  "ifr;": 120102,
  "int;": 8747,
  iuml: 239,
  "jcy;": 1081,
  "jfr;": 120103,
  "kcy;": 1082,
  "kfr;": 120104,
  "lEg;": 10891,
  "lap;": 10885,
  "lat;": 10923,
  "lcy;": 1083,
  "leg;": 8922,
  "leq;": 8804,
  "les;": 10877,
  "lfr;": 120105,
  "lgE;": 10897,
  "lnE;": 8808,
  "lne;": 10887,
  "loz;": 9674,
  "lrm;": 8206,
  "lsh;": 8624,
  macr: 175,
  "map;": 8614,
  "mcy;": 1084,
  "mfr;": 120106,
  "mho;": 8487,
  "mid;": 8739,
  "nGg;": 8921,
  "nGt;": 8811,
  "nLl;": 8920,
  "nLt;": 8810,
  "nap;": 8777,
  nbsp: 160,
  "ncy;": 1085,
  "nfr;": 120107,
  "ngE;": 8807,
  "nge;": 8817,
  "ngt;": 8815,
  "nis;": 8956,
  "niv;": 8715,
  "nlE;": 8806,
  "nle;": 8816,
  "nlt;": 8814,
  "not;": 172,
  "npr;": 8832,
  "nsc;": 8833,
  "num;": 35,
  "ocy;": 1086,
  "ofr;": 120108,
  "ogt;": 10689,
  "ohm;": 937,
  "olt;": 10688,
  "ord;": 10845,
  ordf: 170,
  ordm: 186,
  "orv;": 10843,
  ouml: 246,
  "par;": 8741,
  para: 182,
  "pcy;": 1087,
  "pfr;": 120109,
  "phi;": 966,
  "piv;": 982,
  "prE;": 10931,
  "pre;": 10927,
  "psi;": 968,
  "qfr;": 120110,
  quot: 34,
  "rcy;": 1088,
  "reg;": 174,
  "rfr;": 120111,
  "rho;": 961,
  "rlm;": 8207,
  "rsh;": 8625,
  "scE;": 10932,
  "sce;": 10928,
  "scy;": 1089,
  sect: 167,
  "sfr;": 120112,
  "shy;": 173,
  "sim;": 8764,
  "smt;": 10922,
  "sol;": 47,
  "squ;": 9633,
  "sub;": 8834,
  "sum;": 8721,
  sup1: 185,
  sup2: 178,
  sup3: 179,
  "sup;": 8835,
  "tau;": 964,
  "tcy;": 1090,
  "tfr;": 120113,
  "top;": 8868,
  "ucy;": 1091,
  "ufr;": 120114,
  "uml;": 168,
  uuml: 252,
  "vcy;": 1074,
  "vee;": 8744,
  "vfr;": 120115,
  "wfr;": 120116,
  "xfr;": 120117,
  "ycy;": 1099,
  "yen;": 165,
  "yfr;": 120118,
  yuml: 255,
  "zcy;": 1079,
  "zfr;": 120119,
  "zwj;": 8205,
  AMP: 38,
  "DD;": 8517,
  ETH: 208,
  "GT;": 62,
  "Gg;": 8921,
  "Gt;": 8811,
  "Im;": 8465,
  "LT;": 60,
  "Ll;": 8920,
  "Lt;": 8810,
  "Mu;": 924,
  "Nu;": 925,
  "Or;": 10836,
  "Pi;": 928,
  "Pr;": 10939,
  REG: 174,
  "Re;": 8476,
  "Sc;": 10940,
  "Xi;": 926,
  "ac;": 8766,
  "af;": 8289,
  amp: 38,
  "ap;": 8776,
  "dd;": 8518,
  deg: 176,
  "ee;": 8519,
  "eg;": 10906,
  "el;": 10905,
  eth: 240,
  "gE;": 8807,
  "ge;": 8805,
  "gg;": 8811,
  "gl;": 8823,
  "gt;": 62,
  "ic;": 8291,
  "ii;": 8520,
  "in;": 8712,
  "it;": 8290,
  "lE;": 8806,
  "le;": 8804,
  "lg;": 8822,
  "ll;": 8810,
  "lt;": 60,
  "mp;": 8723,
  "mu;": 956,
  "ne;": 8800,
  "ni;": 8715,
  not: 172,
  "nu;": 957,
  "oS;": 9416,
  "or;": 8744,
  "pi;": 960,
  "pm;": 177,
  "pr;": 8826,
  reg: 174,
  "rx;": 8478,
  "sc;": 8827,
  shy: 173,
  uml: 168,
  "wp;": 8472,
  "wr;": 8768,
  "xi;": 958,
  yen: 165,
  GT: 62,
  LT: 60,
  gt: 62,
  lt: 60
};

// node_modules/svelte/src/compiler/parse/utils/html.js
var windows_1252 = [
  8364,
  129,
  8218,
  402,
  8222,
  8230,
  8224,
  8225,
  710,
  8240,
  352,
  8249,
  338,
  141,
  381,
  143,
  144,
  8216,
  8217,
  8220,
  8221,
  8226,
  8211,
  8212,
  732,
  8482,
  353,
  8250,
  339,
  157,
  382,
  376
];
function reg_exp_entity(entity_name, is_attribute_value) {
  if (is_attribute_value && !entity_name.endsWith(";")) {
    return `${entity_name}\\b(?!=)`;
  }
  return entity_name;
}
function get_entity_pattern(is_attribute_value) {
  const reg_exp_num = "#(?:x[a-fA-F\\d]+|\\d+)(?:;)?";
  const reg_exp_entities = Object.keys(entities_default).map(
    (entity_name) => reg_exp_entity(entity_name, is_attribute_value)
  );
  const entity_pattern = new RegExp(`&(${reg_exp_num}|${reg_exp_entities.join("|")})`, "g");
  return entity_pattern;
}
var entity_pattern_content = get_entity_pattern(false);
var entity_pattern_attr_value = get_entity_pattern(true);
function decode_character_references(html2, is_attribute_value) {
  const entity_pattern = is_attribute_value ? entity_pattern_attr_value : entity_pattern_content;
  return html2.replace(entity_pattern, (match, entity) => {
    let code2;
    if (entity[0] !== "#") {
      code2 = entities_default[entity];
    } else if (entity[1] === "x") {
      code2 = parseInt(entity.substring(2), 16);
    } else {
      code2 = parseInt(entity.substring(1), 10);
    }
    if (!code2) {
      return match;
    }
    return String.fromCodePoint(validate_code(code2));
  });
}
var NUL = 0;
function validate_code(code2) {
  if (code2 === 10) {
    return 32;
  }
  if (code2 < 128) {
    return code2;
  }
  if (code2 <= 159) {
    return windows_1252[code2 - 128];
  }
  if (code2 < 55296) {
    return code2;
  }
  if (code2 <= 57343) {
    return NUL;
  }
  if (code2 <= 65535) {
    return code2;
  }
  if (code2 >= 65536 && code2 <= 131071) {
    return code2;
  }
  if (code2 >= 131072 && code2 <= 196607) {
    return code2;
  }
  return NUL;
}
var disallowed_contents = /* @__PURE__ */ new Map([
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["dt", /* @__PURE__ */ new Set(["dt", "dd"])],
  ["dd", /* @__PURE__ */ new Set(["dt", "dd"])],
  [
    "p",
    new Set(
      "address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul".split(
        " "
      )
    )
  ],
  ["rt", /* @__PURE__ */ new Set(["rt", "rp"])],
  ["rp", /* @__PURE__ */ new Set(["rt", "rp"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup"])],
  ["option", /* @__PURE__ */ new Set(["option", "optgroup"])],
  ["thead", /* @__PURE__ */ new Set(["tbody", "tfoot"])],
  ["tbody", /* @__PURE__ */ new Set(["tbody", "tfoot"])],
  ["tfoot", /* @__PURE__ */ new Set(["tbody"])],
  ["tr", /* @__PURE__ */ new Set(["tr", "tbody"])],
  ["td", /* @__PURE__ */ new Set(["td", "th", "tr"])],
  ["th", /* @__PURE__ */ new Set(["td", "th", "tr"])]
]);
function closing_tag_omitted(current2, next) {
  if (disallowed_contents.has(current2)) {
    if (!next || disallowed_contents.get(current2).has(next)) {
      return true;
    }
  }
  return false;
}

// node_modules/svelte/src/compiler/parse/state/tag.js
var valid_tag_name = /^\!?[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/;
var regex_starts_with_invalid_attr_value = /^(\/>|[\s"'=<>`])/;
var meta_tags = /* @__PURE__ */ new Map([
  ["svelte:head", "Head"],
  ["svelte:options", "Options"],
  ["svelte:window", "Window"],
  ["svelte:document", "Document"],
  ["svelte:body", "Body"]
]);
var valid_meta_tags = Array.from(meta_tags.keys()).concat(
  "svelte:self",
  "svelte:component",
  "svelte:fragment",
  "svelte:element"
);
var specials = /* @__PURE__ */ new Map([
  [
    "script",
    {
      read: read_script,
      property: "js"
    }
  ],
  [
    "style",
    {
      read: read_style,
      property: "css"
    }
  ]
]);
var SELF = /^svelte:self(?=[\s/>])/;
var COMPONENT = /^svelte:component(?=[\s/>])/;
var SLOT = /^svelte:fragment(?=[\s/>])/;
var ELEMENT = /^svelte:element(?=[\s/>])/;
function parent_is_head(stack) {
  let i = stack.length;
  while (i--) {
    const { type } = stack[i];
    if (type === "Head")
      return true;
    if (type === "Element" || type === "InlineComponent")
      return false;
  }
  return false;
}
var regex_closing_textarea_tag = /^<\/textarea(\s[^>]*)?>/i;
var regex_closing_comment = /-->/;
var regex_capital_letter = /[A-Z]/;
function tag(parser) {
  const start = parser.index++;
  let parent = parser.current();
  if (parser.eat("!--")) {
    const data2 = parser.read_until(regex_closing_comment);
    parser.eat("-->", true, errors_default.unclosed_comment);
    parser.current().children.push({
      start,
      end: parser.index,
      type: "Comment",
      data: data2,
      ignores: extract_svelte_ignore(data2)
    });
    return;
  }
  const is_closing_tag = parser.eat("/");
  const name49 = read_tag_name(parser);
  if (meta_tags.has(name49)) {
    const slug = meta_tags.get(name49).toLowerCase();
    if (is_closing_tag) {
      if ((name49 === "svelte:window" || name49 === "svelte:body") && parser.current().children.length) {
        parser.error(
          errors_default.invalid_element_content(slug, name49),
          parser.current().children[0].start
        );
      }
    } else {
      if (name49 in parser.meta_tags) {
        parser.error(errors_default.duplicate_element(slug, name49), start);
      }
      if (parser.stack.length > 1) {
        parser.error(errors_default.invalid_element_placement(slug, name49), start);
      }
      parser.meta_tags[name49] = true;
    }
  }
  const type = meta_tags.has(name49) ? meta_tags.get(name49) : regex_capital_letter.test(name49[0]) || name49 === "svelte:self" || name49 === "svelte:component" ? "InlineComponent" : name49 === "svelte:fragment" ? "SlotTemplate" : name49 === "title" && parent_is_head(parser.stack) ? "Title" : name49 === "slot" ? "Slot" : "Element";
  const element = {
    start,
    end: null,
    type,
    name: name49,
    attributes: [],
    children: []
  };
  parser.allow_whitespace();
  if (is_closing_tag) {
    if (is_void(name49)) {
      parser.error(errors_default.invalid_void_content(name49), start);
    }
    parser.eat(">", true);
    while (parent.name !== name49) {
      if (parent.type !== "Element") {
        const error2 = parser.last_auto_closed_tag && parser.last_auto_closed_tag.tag === name49 ? errors_default.invalid_closing_tag_autoclosed(name49, parser.last_auto_closed_tag.reason) : errors_default.invalid_closing_tag_unopened(name49);
        parser.error(error2, start);
      }
      parent.end = start;
      parser.stack.pop();
      parent = parser.current();
    }
    parent.end = parser.index;
    parser.stack.pop();
    if (parser.last_auto_closed_tag && parser.stack.length < parser.last_auto_closed_tag.depth) {
      parser.last_auto_closed_tag = null;
    }
    return;
  } else if (closing_tag_omitted(parent.name, name49)) {
    parent.end = start;
    parser.stack.pop();
    parser.last_auto_closed_tag = {
      tag: parent.name,
      reason: name49,
      depth: parser.stack.length
    };
  }
  const unique_names = /* @__PURE__ */ new Set();
  const is_top_level_script_or_style = specials.has(name49) && parser.stack.length === 1;
  let attribute;
  while (attribute = read_attribute(parser, unique_names, is_top_level_script_or_style)) {
    element.attributes.push(attribute);
    parser.allow_whitespace();
  }
  if (name49 === "svelte:component") {
    const index = element.attributes.findIndex(
      (attr) => attr.type === "Attribute" && attr.name === "this"
    );
    if (index === -1) {
      parser.error(errors_default.missing_component_definition, start);
    }
    const definition = element.attributes.splice(index, 1)[0];
    if (definition.value === true || definition.value.length !== 1 || definition.value[0].type === "Text") {
      parser.error(errors_default.invalid_component_definition, definition.start);
    }
    element.expression = definition.value[0].expression;
  }
  if (name49 === "svelte:element") {
    const index = element.attributes.findIndex(
      (attr) => attr.type === "Attribute" && attr.name === "this"
    );
    if (index === -1) {
      parser.error(errors_default.missing_element_definition, start);
    }
    const definition = element.attributes.splice(index, 1)[0];
    if (definition.value === true) {
      parser.error(errors_default.invalid_element_definition, definition.start);
    }
    element.tag = definition.value[0].data || definition.value[0].expression;
  }
  if (is_top_level_script_or_style) {
    const special = specials.get(name49);
    parser.eat(">", true);
    const content = special.read(parser, start, element.attributes);
    if (content)
      parser[special.property].push(content);
    return;
  }
  parser.current().children.push(element);
  const self_closing = parser.eat("/") || is_void(name49);
  parser.eat(">", true);
  if (self_closing) {
    element.end = parser.index;
  } else if (name49 === "textarea") {
    element.children = read_sequence(
      parser,
      () => regex_closing_textarea_tag.test(parser.template.slice(parser.index)),
      "inside <textarea>"
    );
    parser.read(regex_closing_textarea_tag);
    element.end = parser.index;
  } else if (name49 === "script" || name49 === "style") {
    const start2 = parser.index;
    const data2 = parser.read_until(new RegExp(`</${name49}>`));
    const end = parser.index;
    element.children.push({ start: start2, end, type: "Text", data: data2 });
    parser.eat(`</${name49}>`, true);
    element.end = parser.index;
  } else {
    parser.stack.push(element);
  }
}
var regex_whitespace_or_slash_or_closing_tag = /(\s|\/|>)/;
function read_tag_name(parser) {
  const start = parser.index;
  if (parser.read(SELF)) {
    let i = parser.stack.length;
    let legal = false;
    while (i--) {
      const fragment2 = parser.stack[i];
      if (fragment2.type === "IfBlock" || fragment2.type === "EachBlock" || fragment2.type === "InlineComponent") {
        legal = true;
        break;
      }
    }
    if (!legal) {
      parser.error(errors_default.invalid_self_placement, start);
    }
    return "svelte:self";
  }
  if (parser.read(COMPONENT))
    return "svelte:component";
  if (parser.read(ELEMENT))
    return "svelte:element";
  if (parser.read(SLOT))
    return "svelte:fragment";
  const name49 = parser.read_until(regex_whitespace_or_slash_or_closing_tag);
  if (meta_tags.has(name49))
    return name49;
  if (name49.startsWith("svelte:")) {
    const match = fuzzymatch(name49.slice(7), valid_meta_tags);
    parser.error(errors_default.invalid_tag_name_svelte_element(valid_meta_tags, match), start);
  }
  if (!valid_tag_name.test(name49)) {
    parser.error(errors_default.invalid_tag_name, start);
  }
  return name49;
}
var regex_token_ending_character = /[\s=\/>"']/;
var regex_starts_with_quote_characters = /^["']/;
function read_attribute(parser, unique_names, is_static) {
  const start = parser.index;
  function check_unique(name50) {
    if (unique_names.has(name50)) {
      parser.error(errors_default.duplicate_attribute, start);
    }
    unique_names.add(name50);
  }
  if (!is_static && parser.eat("{")) {
    parser.allow_whitespace();
    if (parser.eat("...")) {
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      return {
        start,
        end: parser.index,
        type: "Spread",
        expression
      };
    } else {
      const value_start = parser.index;
      const name50 = parser.read_identifier();
      parser.allow_whitespace();
      parser.eat("}", true);
      if (name50 === null) {
        parser.error(errors_default.empty_attribute_shorthand, start);
      }
      check_unique(name50);
      return {
        start,
        end: parser.index,
        type: "Attribute",
        name: name50,
        value: [
          {
            start: value_start,
            end: value_start + name50.length,
            type: "AttributeShorthand",
            expression: {
              start: value_start,
              end: value_start + name50.length,
              type: "Identifier",
              name: name50
            }
          }
        ]
      };
    }
  }
  const name49 = parser.read_until(regex_token_ending_character);
  if (!name49)
    return null;
  let end = parser.index;
  parser.allow_whitespace();
  const colon_index = name49.indexOf(":");
  const type = colon_index !== -1 && get_directive_type(name49.slice(0, colon_index));
  let value = true;
  if (parser.eat("=")) {
    parser.allow_whitespace();
    value = read_attribute_value(parser, is_static);
    end = parser.index;
  } else if (parser.match_regex(regex_starts_with_quote_characters)) {
    parser.error(errors_default.unexpected_token("="), parser.index);
  }
  if (!is_static && type) {
    const [directive_name, ...modifiers] = name49.slice(colon_index + 1).split("|");
    if (directive_name === "") {
      parser.error(errors_default.empty_directive_name(type), start + colon_index + 1);
    }
    if (type === "Binding" && directive_name !== "this") {
      check_unique(directive_name);
    } else if (type !== "EventHandler" && type !== "Action") {
      check_unique(name49);
    }
    if (type === "Ref") {
      parser.error(errors_default.invalid_ref_directive(directive_name), start);
    }
    if (type === "StyleDirective") {
      return {
        start,
        end,
        type,
        name: directive_name,
        modifiers,
        value
      };
    }
    const first_value = value[0];
    let expression = null;
    if (first_value) {
      const attribute_contains_text = (
        /** @type {any[]} */
        value.length > 1 || first_value.type === "Text"
      );
      if (attribute_contains_text) {
        parser.error(errors_default.invalid_directive_value, first_value.start);
      } else {
        expression = first_value.expression;
      }
    }
    const directive = {
      start,
      end,
      type,
      name: directive_name,
      modifiers,
      expression
    };
    if (type === "Transition") {
      const direction = name49.slice(0, colon_index);
      directive.intro = direction === "in" || direction === "transition";
      directive.outro = direction === "out" || direction === "transition";
    }
    if (!directive.expression && (type === "Binding" || type === "Class")) {
      directive.expression = {
        start: directive.start + colon_index + 1,
        end: directive.end,
        type: "Identifier",
        name: directive.name
      };
    }
    return directive;
  }
  check_unique(name49);
  return {
    start,
    end,
    type: "Attribute",
    name: name49,
    value
  };
}
function get_directive_type(name49) {
  if (name49 === "use")
    return "Action";
  if (name49 === "animate")
    return "Animation";
  if (name49 === "bind")
    return "Binding";
  if (name49 === "class")
    return "Class";
  if (name49 === "style")
    return "StyleDirective";
  if (name49 === "on")
    return "EventHandler";
  if (name49 === "let")
    return "Let";
  if (name49 === "in" || name49 === "out" || name49 === "transition")
    return "Transition";
}
var regex_attribute_value = /^(?:"([^"]*)"|'([^'])*'|([^>\s]+))/;
function read_attribute_value(parser, is_static) {
  if (is_static) {
    let value2 = parser.match_regex(regex_attribute_value);
    if (!value2) {
      parser.error(errors_default.missing_attribute_value);
    }
    parser.index += value2.length;
    const quoted = value2[0] === '"' || value2[0] === "'";
    if (quoted) {
      value2 = value2.slice(1, -1);
    }
    return [
      {
        start: parser.index - value2.length - (quoted ? 1 : 0),
        end: quoted ? parser.index - 1 : parser.index,
        type: "Text",
        raw: value2,
        data: decode_character_references(value2, true)
      }
    ];
  }
  const quote_mark = parser.eat("'") ? "'" : parser.eat('"') ? '"' : null;
  if (quote_mark && parser.eat(quote_mark)) {
    return [
      {
        start: parser.index - 1,
        end: parser.index - 1,
        type: "Text",
        raw: "",
        data: ""
      }
    ];
  }
  let value;
  try {
    value = read_sequence(
      parser,
      () => {
        if (quote_mark)
          return parser.match(quote_mark);
        return !!parser.match_regex(regex_starts_with_invalid_attr_value);
      },
      "in attribute value"
    );
  } catch (error2) {
    if (error2.code === "parse-error") {
      if (parser.template.slice(error2.pos - 1, error2.pos + 1) === "/>") {
        parser.index = error2.pos;
        parser.error(errors_default.unclosed_attribute_value(quote_mark || "}"));
      }
    }
    throw error2;
  }
  if (value.length === 0 && !quote_mark) {
    parser.error(errors_default.missing_attribute_value);
  }
  if (quote_mark)
    parser.index += 1;
  return value;
}
function read_sequence(parser, done, location) {
  let current_chunk = {
    start: parser.index,
    end: null,
    type: "Text",
    raw: "",
    data: null
  };
  const chunks = [];
  function flush(end) {
    if (current_chunk.raw) {
      current_chunk.data = decode_character_references(current_chunk.raw, true);
      current_chunk.end = end;
      chunks.push(current_chunk);
    }
  }
  while (parser.index < parser.template.length) {
    const index = parser.index;
    if (done()) {
      flush(parser.index);
      return chunks;
    } else if (parser.eat("{")) {
      if (parser.match("#")) {
        const index2 = parser.index - 1;
        parser.eat("#");
        const name49 = parser.read_until(/[^a-z]/);
        parser.error(errors_default.invalid_logic_block_placement(location, name49), index2);
      } else if (parser.match("@")) {
        const index2 = parser.index - 1;
        parser.eat("@");
        const name49 = parser.read_until(/[^a-z]/);
        parser.error(errors_default.invalid_tag_placement(location, name49), index2);
      }
      flush(parser.index - 1);
      parser.allow_whitespace();
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      chunks.push({
        start: index,
        end: parser.index,
        type: "MustacheTag",
        expression
      });
      current_chunk = {
        start: parser.index,
        end: null,
        type: "Text",
        raw: "",
        data: null
      };
    } else {
      current_chunk.raw += parser.template[parser.index++];
    }
  }
  parser.error(errors_default.unexpected_eof);
}

// node_modules/svelte/src/compiler/utils/full_char_code_at.js
function full_char_code_at(str, i) {
  const code2 = str.charCodeAt(i);
  if (code2 <= 55295 || code2 >= 57344)
    return code2;
  const next = str.charCodeAt(i + 1);
  return (code2 << 10) + next - 56613888;
}

// node_modules/svelte/src/compiler/parse/utils/bracket.js
var SQUARE_BRACKET_OPEN = "[".charCodeAt(0);
var SQUARE_BRACKET_CLOSE = "]".charCodeAt(0);
var CURLY_BRACKET_OPEN = "{".charCodeAt(0);
var CURLY_BRACKET_CLOSE = "}".charCodeAt(0);
function is_bracket_open(code2) {
  return code2 === SQUARE_BRACKET_OPEN || code2 === CURLY_BRACKET_OPEN;
}
function is_bracket_close(code2) {
  return code2 === SQUARE_BRACKET_CLOSE || code2 === CURLY_BRACKET_CLOSE;
}
function is_bracket_pair(open, close) {
  return open === SQUARE_BRACKET_OPEN && close === SQUARE_BRACKET_CLOSE || open === CURLY_BRACKET_OPEN && close === CURLY_BRACKET_CLOSE;
}
function get_bracket_close(open) {
  if (open === SQUARE_BRACKET_OPEN) {
    return SQUARE_BRACKET_CLOSE;
  }
  if (open === CURLY_BRACKET_OPEN) {
    return CURLY_BRACKET_CLOSE;
  }
}

// node_modules/svelte/src/compiler/parse/read/context.js
function read_context(parser) {
  const start = parser.index;
  let i = parser.index;
  const code2 = full_char_code_at(parser.template, i);
  if (isIdentifierStart(code2, true)) {
    return {
      type: "Identifier",
      name: parser.read_identifier(),
      start,
      end: parser.index
    };
  }
  if (!is_bracket_open(code2)) {
    parser.error(errors_default.unexpected_token_destructure);
  }
  const bracket_stack = [code2];
  i += code2 <= 65535 ? 1 : 2;
  while (i < parser.template.length) {
    const code3 = full_char_code_at(parser.template, i);
    if (is_bracket_open(code3)) {
      bracket_stack.push(code3);
    } else if (is_bracket_close(code3)) {
      if (!is_bracket_pair(bracket_stack[bracket_stack.length - 1], code3)) {
        parser.error(
          errors_default.unexpected_token(
            String.fromCharCode(get_bracket_close(bracket_stack[bracket_stack.length - 1]))
          )
        );
      }
      bracket_stack.pop();
      if (bracket_stack.length === 0) {
        i += code3 <= 65535 ? 1 : 2;
        break;
      }
    }
    i += code3 <= 65535 ? 1 : 2;
  }
  parser.index = i;
  const pattern_string = parser.template.slice(start, i);
  try {
    let space_with_newline = parser.template.slice(0, start).replace(regex_not_newline_characters, " ");
    const first_space = space_with_newline.indexOf(" ");
    space_with_newline = space_with_newline.slice(0, first_space) + space_with_newline.slice(first_space + 1);
    return parse_expression_at(`${space_with_newline}(${pattern_string} = 1)`, start - 1).left;
  } catch (error2) {
    parser.acorn_error(error2);
  }
}

// node_modules/svelte/src/compiler/utils/trim.js
function trim_start(str) {
  return str.replace(regex_starts_with_whitespaces, "");
}
function trim_end(str) {
  return str.replace(regex_ends_with_whitespaces, "");
}

// node_modules/svelte/src/compiler/parse/utils/node.js
function to_string(node) {
  switch (node.type) {
    case "IfBlock":
      return "{#if} block";
    case "ThenBlock":
      return "{:then} block";
    case "ElseBlock":
      return "{:else} block";
    case "PendingBlock":
    case "AwaitBlock":
      return "{#await} block";
    case "CatchBlock":
      return "{:catch} block";
    case "EachBlock":
      return "{#each} block";
    case "RawMustacheTag":
      return "{@html} block";
    case "DebugTag":
      return "{@debug} block";
    case "ConstTag":
      return "{@const} tag";
    case "Element":
    case "InlineComponent":
    case "Slot":
    case "Title":
      return `<${node.name}> tag`;
    default:
      return node.type;
  }
}

// node_modules/svelte/src/compiler/parse/state/mustache.js
function trim_whitespace(block, trim_before, trim_after) {
  if (!block.children || block.children.length === 0)
    return;
  const first_child = block.children[0];
  const last_child = block.children[block.children.length - 1];
  if (first_child.type === "Text" && trim_before) {
    first_child.data = trim_start(first_child.data);
    if (!first_child.data)
      block.children.shift();
  }
  if (last_child.type === "Text" && trim_after) {
    last_child.data = trim_end(last_child.data);
    if (!last_child.data)
      block.children.pop();
  }
  if (block.else) {
    trim_whitespace(block.else, trim_before, trim_after);
  }
  if (first_child.elseif) {
    trim_whitespace(first_child, trim_before, trim_after);
  }
}
var regex_whitespace_with_closing_curly_brace = /^\s*}/;
function mustache(parser) {
  const start = parser.index;
  parser.index += 1;
  parser.allow_whitespace();
  if (parser.eat("/")) {
    let block = parser.current();
    let expected;
    if (closing_tag_omitted(block.name)) {
      block.end = start;
      parser.stack.pop();
      block = parser.current();
    }
    if (block.type === "ElseBlock" || block.type === "PendingBlock" || block.type === "ThenBlock" || block.type === "CatchBlock") {
      block.end = start;
      parser.stack.pop();
      block = parser.current();
      expected = "await";
    }
    if (block.type === "IfBlock") {
      expected = "if";
    } else if (block.type === "EachBlock") {
      expected = "each";
    } else if (block.type === "AwaitBlock") {
      expected = "await";
    } else if (block.type === "KeyBlock") {
      expected = "key";
    } else {
      parser.error(errors_default.unexpected_block_close);
    }
    parser.eat(expected, true);
    parser.allow_whitespace();
    parser.eat("}", true);
    while (block.elseif) {
      block.end = parser.index;
      parser.stack.pop();
      block = parser.current();
      if (block.else) {
        block.else.end = start;
      }
    }
    const char_before = parser.template[block.start - 1];
    const char_after = parser.template[parser.index];
    const trim_before = !char_before || regex_whitespace.test(char_before);
    const trim_after = !char_after || regex_whitespace.test(char_after);
    trim_whitespace(block, trim_before, trim_after);
    block.end = parser.index;
    parser.stack.pop();
  } else if (parser.eat(":else")) {
    if (parser.eat("if")) {
      parser.error(errors_default.invalid_elseif);
    }
    parser.allow_whitespace();
    if (parser.eat("if")) {
      const block = parser.current();
      if (block.type !== "IfBlock") {
        parser.error(
          parser.stack.some((block2) => block2.type === "IfBlock") ? errors_default.invalid_elseif_placement_unclosed_block(to_string(block)) : errors_default.invalid_elseif_placement_outside_if
        );
      }
      parser.require_whitespace();
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      block.else = {
        start: parser.index,
        end: null,
        type: "ElseBlock",
        children: [
          {
            start: parser.index,
            end: null,
            type: "IfBlock",
            elseif: true,
            expression,
            children: []
          }
        ]
      };
      parser.stack.push(block.else.children[0]);
    } else {
      const block = parser.current();
      if (block.type !== "IfBlock" && block.type !== "EachBlock") {
        parser.error(
          parser.stack.some((block2) => block2.type === "IfBlock" || block2.type === "EachBlock") ? errors_default.invalid_else_placement_unclosed_block(to_string(block)) : errors_default.invalid_else_placement_outside_if
        );
      }
      parser.allow_whitespace();
      parser.eat("}", true);
      block.else = {
        start: parser.index,
        end: null,
        type: "ElseBlock",
        children: []
      };
      parser.stack.push(block.else);
    }
  } else if (parser.match(":then") || parser.match(":catch")) {
    const block = parser.current();
    const is_then = parser.eat(":then") || !parser.eat(":catch");
    if (is_then) {
      if (block.type !== "PendingBlock") {
        parser.error(
          parser.stack.some((block2) => block2.type === "PendingBlock") ? errors_default.invalid_then_placement_unclosed_block(to_string(block)) : errors_default.invalid_then_placement_without_await
        );
      }
    } else {
      if (block.type !== "ThenBlock" && block.type !== "PendingBlock") {
        parser.error(
          parser.stack.some((block2) => block2.type === "ThenBlock" || block2.type === "PendingBlock") ? errors_default.invalid_catch_placement_unclosed_block(to_string(block)) : errors_default.invalid_catch_placement_without_await
        );
      }
    }
    block.end = start;
    parser.stack.pop();
    const await_block = parser.current();
    if (!parser.eat("}")) {
      parser.require_whitespace();
      await_block[is_then ? "value" : "error"] = read_context(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
    }
    const new_block = {
      start,
      end: null,
      type: is_then ? "ThenBlock" : "CatchBlock",
      children: [],
      skip: false
    };
    await_block[is_then ? "then" : "catch"] = new_block;
    parser.stack.push(new_block);
  } else if (parser.eat("#")) {
    let type;
    if (parser.eat("if")) {
      type = "IfBlock";
    } else if (parser.eat("each")) {
      type = "EachBlock";
    } else if (parser.eat("await")) {
      type = "AwaitBlock";
    } else if (parser.eat("key")) {
      type = "KeyBlock";
    } else {
      parser.error(errors_default.expected_block_type);
    }
    parser.require_whitespace();
    const expression = read_expression(parser);
    const block = type === "AwaitBlock" ? {
      start,
      end: null,
      type,
      expression,
      value: null,
      error: null,
      pending: {
        start: null,
        end: null,
        type: "PendingBlock",
        children: [],
        skip: true
      },
      then: {
        start: null,
        end: null,
        type: "ThenBlock",
        children: [],
        skip: true
      },
      catch: {
        start: null,
        end: null,
        type: "CatchBlock",
        children: [],
        skip: true
      }
    } : {
      start,
      end: null,
      type,
      expression,
      children: []
    };
    parser.allow_whitespace();
    if (type === "EachBlock") {
      parser.eat("as", true);
      parser.require_whitespace();
      block.context = read_context(parser);
      parser.allow_whitespace();
      if (parser.eat(",")) {
        parser.allow_whitespace();
        block.index = parser.read_identifier();
        if (!block.index)
          parser.error(errors_default.expected_name);
        parser.allow_whitespace();
      }
      if (parser.eat("(")) {
        parser.allow_whitespace();
        block.key = read_expression(parser);
        parser.allow_whitespace();
        parser.eat(")", true);
        parser.allow_whitespace();
      }
    }
    const await_block_shorthand = type === "AwaitBlock" && parser.eat("then");
    if (await_block_shorthand) {
      if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser.allow_whitespace();
      } else {
        parser.require_whitespace();
        block.value = read_context(parser);
        parser.allow_whitespace();
      }
    }
    const await_block_catch_shorthand = !await_block_shorthand && type === "AwaitBlock" && parser.eat("catch");
    if (await_block_catch_shorthand) {
      if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser.allow_whitespace();
      } else {
        parser.require_whitespace();
        block.error = read_context(parser);
        parser.allow_whitespace();
      }
    }
    parser.eat("}", true);
    parser.current().children.push(block);
    parser.stack.push(block);
    if (type === "AwaitBlock") {
      let child_block;
      if (await_block_shorthand) {
        block.then.skip = false;
        child_block = block.then;
      } else if (await_block_catch_shorthand) {
        block.catch.skip = false;
        child_block = block.catch;
      } else {
        block.pending.skip = false;
        child_block = block.pending;
      }
      child_block.start = parser.index;
      parser.stack.push(child_block);
    }
  } else if (parser.eat("@html")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.current().children.push({
      start,
      end: parser.index,
      type: "RawMustacheTag",
      expression
    });
  } else if (parser.eat("@debug")) {
    let identifiers;
    if (parser.read(regex_whitespace_with_closing_curly_brace)) {
      identifiers = [];
    } else {
      const expression = read_expression(parser);
      identifiers = expression.type === "SequenceExpression" ? expression.expressions : [expression];
      identifiers.forEach((node) => {
        if (node.type !== "Identifier") {
          parser.error(errors_default.invalid_debug_args, node.start);
        }
      });
      parser.allow_whitespace();
      parser.eat("}", true);
    }
    parser.current().children.push({
      start,
      end: parser.index,
      type: "DebugTag",
      identifiers
    });
  } else if (parser.eat("@const")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    if (!(expression.type === "AssignmentExpression" && expression.operator === "=")) {
      parser.error(
        {
          code: "invalid-const-args",
          message: "{@const ...} must be an assignment."
        },
        start
      );
    }
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.current().children.push({
      start,
      end: parser.index,
      type: "ConstTag",
      expression
    });
  } else {
    const expression = read_expression(parser);
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.current().children.push({
      start,
      end: parser.index,
      type: "MustacheTag",
      expression
    });
  }
}

// node_modules/svelte/src/compiler/parse/state/text.js
function text(parser) {
  const start = parser.index;
  let data2 = "";
  while (parser.index < parser.template.length && !parser.match("<") && !parser.match("{")) {
    data2 += parser.template[parser.index++];
  }
  const node = {
    start,
    end: parser.index,
    type: "Text",
    raw: data2,
    data: decode_character_references(data2, false)
  };
  parser.current().children.push(node);
}

// node_modules/svelte/src/compiler/parse/state/fragment.js
function fragment(parser) {
  if (parser.match("<")) {
    return tag;
  }
  if (parser.match("{")) {
    return mustache;
  }
  return text;
}

// node_modules/svelte/src/compiler/utils/names.js
var reserved = /* @__PURE__ */ new Set([
  "arguments",
  "await",
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "enum",
  "eval",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "implements",
  "import",
  "in",
  "instanceof",
  "interface",
  "let",
  "new",
  "null",
  "package",
  "private",
  "protected",
  "public",
  "return",
  "static",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield"
]);
function is_valid(str) {
  let i = 0;
  while (i < str.length) {
    const code2 = full_char_code_at(str, i);
    if (!(i === 0 ? isIdentifierStart : isIdentifierChar)(code2, true))
      return false;
    i += code2 <= 65535 ? 1 : 2;
  }
  return true;
}
var regex_non_standard_characters = /[^a-zA-Z0-9_]+/g;
var regex_starts_with_number = /^[0-9]/;
function sanitize(name49) {
  return name49.replace(regex_non_standard_characters, "_").replace(regex_starts_with_underscore, "").replace(regex_ends_with_underscore, "").replace(regex_starts_with_number, "_$&");
}

// node_modules/locate-character/src/index.js
function rangeContains(range, index) {
  return range.start <= index && index < range.end;
}
function getLocator(source, options = {}) {
  const { offsetLine = 0, offsetColumn = 0 } = options;
  let start = 0;
  const ranges = source.split("\n").map((line, i2) => {
    const end = start + line.length + 1;
    const range = { start, end, line: i2 };
    start = end;
    return range;
  });
  let i = 0;
  function locator(search, index) {
    if (typeof search === "string") {
      search = source.indexOf(search, index ?? 0);
    }
    if (search === -1)
      return void 0;
    let range = ranges[i];
    const d = search >= range.end ? 1 : -1;
    while (range) {
      if (rangeContains(range, search)) {
        return {
          line: offsetLine + range.line,
          column: offsetColumn + search - range.start,
          character: search
        };
      }
      i += d;
      range = ranges[i];
    }
  }
  return locator;
}
function locate(source, search, options) {
  return getLocator(source, options)(search, options && options.startIndex);
}

// node_modules/svelte/src/compiler/utils/get_code_frame.js
var regex_tabs = /^\t+/;
function tabs_to_spaces(str) {
  return str.replace(regex_tabs, (match) => match.split("	").join("  "));
}
function get_code_frame(source, line, column) {
  const lines = source.split("\n");
  const frame_start = Math.max(0, line - 2);
  const frame_end = Math.min(line + 3, lines.length);
  const digits = String(frame_end + 1).length;
  return lines.slice(frame_start, frame_end).map((str, i) => {
    const is_error_line = frame_start + i === line;
    const line_num = String(i + frame_start + 1).padStart(digits, " ");
    if (is_error_line) {
      const indicator = " ".repeat(digits + 2 + tabs_to_spaces(str.slice(0, column)).length) + "^";
      return `${line_num}: ${tabs_to_spaces(str)}
${indicator}`;
    }
    return `${line_num}: ${tabs_to_spaces(str)}`;
  }).join("\n");
}

// node_modules/svelte/src/compiler/utils/error.js
var CompileError = class extends Error {
  constructor() {
    super(...arguments);
    /**
     * @type {string}
     */
    __publicField(this, "code");
    /**
     * @type {{ line: number; column: number }}
     */
    __publicField(this, "start");
    /**
     * @type {{ line: number; column: number }}
     */
    __publicField(this, "end");
    /**
     * @type {number}
     */
    __publicField(this, "pos");
    /**
     * @type {string}
     */
    __publicField(this, "filename");
    /**
     * @type {string}
     */
    __publicField(this, "frame");
  }
  toString() {
    return `${this.message} (${this.start.line}:${this.start.column})
${this.frame}`;
  }
};
function error(message, props) {
  const error2 = new CompileError(message);
  error2.name = props.name;
  const start = locate(props.source, props.start, { offsetLine: 1 });
  const end = locate(props.source, props.end || props.start, { offsetLine: 1 });
  error2.code = props.code;
  error2.start = start;
  error2.end = end;
  error2.pos = props.start;
  error2.filename = props.filename;
  error2.frame = get_code_frame(props.source, start.line - 1, start.column);
  throw error2;
}

// node_modules/svelte/src/compiler/parse/index.js
var regex_position_indicator = / \(\d+:\d+\)$/;
var Parser3 = class {
  /**
   * @param {string} template
   * @param {import('../interfaces.js').ParserOptions} options
   */
  constructor(template, options) {
    /**
     * @readonly
     * @type {string}
     */
    __publicField(this, "template");
    /**
     * @readonly
     * @type {string}
     */
    __publicField(this, "filename");
    /**
     * @readonly
     * @type {boolean}
     */
    __publicField(this, "customElement");
    /**
     * @readonly
     * @type {'injected' | 'external' | 'none' | boolean}
     */
    __publicField(this, "css_mode");
    __publicField(this, "index", 0);
    /**
     * @type {import('../interfaces.js').TemplateNode[]}
     */
    __publicField(this, "stack", []);
    /**
     * @type {import('../interfaces.js').Fragment}
     */
    __publicField(this, "html");
    /**
     * @type {import('../interfaces.js').Style[]}
     */
    __publicField(this, "css", []);
    /**
     * @type {import('../interfaces.js').Script[]}
     */
    __publicField(this, "js", []);
    __publicField(this, "meta_tags", {});
    /**
     * @type {{tag: string; reason: string; depth: number;}}
     */
    __publicField(this, "last_auto_closed_tag");
    if (typeof template !== "string") {
      throw new TypeError("Template must be a string");
    }
    this.template = template.trimRight();
    this.filename = options.filename;
    this.customElement = options.customElement;
    this.css_mode = options.css;
    this.html = {
      start: null,
      end: null,
      type: "Fragment",
      children: []
    };
    this.stack.push(this.html);
    let state = fragment;
    while (this.index < this.template.length) {
      state = state(this) || fragment;
    }
    if (this.stack.length > 1) {
      const current2 = this.current();
      const type = current2.type === "Element" ? `<${current2.name}>` : "Block";
      const slug = current2.type === "Element" ? "element" : "block";
      this.error(
        {
          code: `unclosed-${slug}`,
          message: `${type} was left open`
        },
        current2.start
      );
    }
    if (state !== fragment) {
      this.error({
        code: "unexpected-eof",
        message: "Unexpected end of input"
      });
    }
    if (this.html.children.length) {
      let start = this.html.children[0].start;
      while (regex_whitespace.test(template[start]))
        start += 1;
      let end = this.html.children[this.html.children.length - 1].end;
      while (regex_whitespace.test(template[end - 1]))
        end -= 1;
      this.html.start = start;
      this.html.end = end;
    } else {
      this.html.start = this.html.end = null;
    }
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  /**
   * @param {any} err
   */
  acorn_error(err) {
    this.error(
      {
        code: "parse-error",
        message: err.message.replace(regex_position_indicator, "")
      },
      err.pos
    );
  }
  /**
   * @param {{ code: string; message: string }} err
   */
  error({ code: code2, message }, index = this.index) {
    error(message, {
      name: "ParseError",
      code: code2,
      source: this.template,
      start: index,
      filename: this.filename
    });
  }
  /**
   * @param {string} str
   * @param {boolean} [required]
   * @param {{ code: string; message: string }} [error]
   */
  eat(str, required, error2) {
    if (this.match(str)) {
      this.index += str.length;
      return true;
    }
    if (required) {
      this.error(
        error2 || (this.index === this.template.length ? errors_default.unexpected_eof_token(str) : errors_default.unexpected_token(str))
      );
    }
    return false;
  }
  /**
   * @param {string} str
   */
  match(str) {
    return this.template.slice(this.index, this.index + str.length) === str;
  }
  /**
   * Match a regex at the current index
   * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
   */
  match_regex(pattern) {
    const match = pattern.exec(this.template.slice(this.index));
    if (!match || match.index !== 0)
      return null;
    return match[0];
  }
  allow_whitespace() {
    while (this.index < this.template.length && regex_whitespace.test(this.template[this.index])) {
      this.index++;
    }
  }
  /**
   * Search for a regex starting at the current index and return the result if it matches
   * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
   */
  read(pattern) {
    const result = this.match_regex(pattern);
    if (result)
      this.index += result.length;
    return result;
  }
  read_identifier(allow_reserved = false) {
    const start = this.index;
    let i = this.index;
    const code2 = full_char_code_at(this.template, i);
    if (!isIdentifierStart(code2, true))
      return null;
    i += code2 <= 65535 ? 1 : 2;
    while (i < this.template.length) {
      const code3 = full_char_code_at(this.template, i);
      if (!isIdentifierChar(code3, true))
        break;
      i += code3 <= 65535 ? 1 : 2;
    }
    const identifier = this.template.slice(this.index, this.index = i);
    if (!allow_reserved && reserved.has(identifier)) {
      this.error(
        {
          code: "unexpected-reserved-word",
          message: `'${identifier}' is a reserved word in JavaScript and cannot be used here`
        },
        start
      );
    }
    return identifier;
  }
  /**
   * @param {RegExp} pattern
   * @param {Parameters<Parser['error']>[0]} [error_message]
   */
  read_until(pattern, error_message) {
    if (this.index >= this.template.length) {
      this.error(
        error_message || {
          code: "unexpected-eof",
          message: "Unexpected end of input"
        }
      );
    }
    const start = this.index;
    const match = pattern.exec(this.template.slice(start));
    if (match) {
      this.index = start + match.index;
      return this.template.slice(start, this.index);
    }
    this.index = this.template.length;
    return this.template.slice(start);
  }
  require_whitespace() {
    if (!regex_whitespace.test(this.template[this.index])) {
      this.error({
        code: "missing-whitespace",
        message: "Expected whitespace"
      });
    }
    this.allow_whitespace();
  }
};
function parse57(template, options = {}) {
  const parser = new Parser3(template, options);
  if (parser.css.length > 1) {
    parser.error(errors_default.duplicate_style, parser.css[1].start);
  }
  const instance_scripts = parser.js.filter((script) => script.context === "default");
  const module_scripts = parser.js.filter((script) => script.context === "module");
  if (instance_scripts.length > 1) {
    parser.error(errors_default.invalid_script_instance, instance_scripts[1].start);
  }
  if (module_scripts.length > 1) {
    parser.error(errors_default.invalid_script_module, module_scripts[1].start);
  }
  return {
    html: parser.html,
    css: parser.css[0],
    instance: instance_scripts[0],
    module: module_scripts[0]
  };
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/is_head.js
function is_head(node) {
  return node && node.type === "MemberExpression" && node.object["name"] === "@_document" && node.property["name"] === "head";
}

// node_modules/svelte/src/compiler/compile/render_dom/Block.js
var Block = class _Block {
  /** @param {BlockOptions} options */
  constructor(options) {
    /**
     * @typedef {Object} Bindings
     * @property {import('estree').Identifier} object
     * @property {import('estree').Identifier} property
     * @property {import('estree').Node} snippet
     * @property {string} store
     * @property {(node:import('estree').Node) => import('estree').Node} modifier
     */
    /**
     * @typedef {Object} BlockOptions
     * @property {Block} [parent]
     * @property {import('estree').Identifier} name
     * @property {string} type
     * @property {import('./Renderer.js').default} [renderer]
     * @property {string} [comment]
     * @property {import('estree').Identifier} [key]
     * @property {Map<string,Bindings>} [bindings]
     * @property {Set<string>} [dependencies]
     */
    /** @type {Block} */
    __publicField(this, "parent");
    /** @type {import('./Renderer.js').default} */
    __publicField(this, "renderer");
    /** @type {import('estree').Identifier} */
    __publicField(this, "name");
    /** @type {string} */
    __publicField(this, "type");
    /** @type {string} */
    __publicField(this, "comment");
    /** @type {import('./wrappers/shared/Wrapper.js').default[]} */
    __publicField(this, "wrappers");
    /** @type {import('estree').Identifier} */
    __publicField(this, "key");
    /** @type {import('estree').Identifier} */
    __publicField(this, "first");
    /** @type {Set<string>} */
    __publicField(this, "dependencies", /* @__PURE__ */ new Set());
    /** @type {Map<string, Bindings>} */
    __publicField(this, "bindings");
    /** @type {Set<string>} */
    __publicField(this, "binding_group_initialised", /* @__PURE__ */ new Set());
    /** @type {Set<import('./Renderer.js').BindingGroup>} */
    __publicField(this, "binding_groups", /* @__PURE__ */ new Set());
    /**
     * @type {{
     * 		declarations: Array<import('estree').Node | import('estree').Node[]>;
     * 		init: Array<import('estree').Node | import('estree').Node[]>;
     * 		create: Array<import('estree').Node | import('estree').Node[]>;
     * 		claim: Array<import('estree').Node | import('estree').Node[]>;
     * 		hydrate: Array<import('estree').Node | import('estree').Node[]>;
     * 		mount: Array<import('estree').Node | import('estree').Node[]>;
     * 		measure: Array<import('estree').Node | import('estree').Node[]>;
     * 		restore_measurements: Array<import('estree').Node | import('estree').Node[]>;
     * 		fix: Array<import('estree').Node | import('estree').Node[]>;
     * 		animate: Array<import('estree').Node | import('estree').Node[]>;
     * 		intro: Array<import('estree').Node | import('estree').Node[]>;
     * 		update: Array<import('estree').Node | import('estree').Node[]>;
     * 		outro: Array<import('estree').Node | import('estree').Node[]>;
     * 		destroy: Array<import('estree').Node | import('estree').Node[]>;
     * 	}}
     */
    __publicField(this, "chunks");
    /** @type {import('estree').Node[]} */
    __publicField(this, "event_listeners", []);
    /** @type {boolean} */
    __publicField(this, "maintain_context");
    /** @type {boolean} */
    __publicField(this, "has_animation");
    /** @type {boolean} */
    __publicField(this, "has_intros");
    /** @type {boolean} */
    __publicField(this, "has_outros");
    /** @type {boolean} */
    __publicField(this, "has_intro_method");
    // could have the method without the transition, due to siblings
    /** @type {boolean} */
    __publicField(this, "has_outro_method");
    /** @type {number} */
    __publicField(this, "outros");
    /** @type {Map<string, import('estree').Identifier>} */
    __publicField(this, "aliases");
    /** @type {Map<string, { id: import('estree').Identifier; init?: import('estree').Node }>} */
    __publicField(this, "variables", /* @__PURE__ */ new Map());
    /** @type {(name: string) => import('estree').Identifier} */
    __publicField(this, "get_unique_name");
    /** */
    __publicField(this, "has_update_method", false);
    /** @type {{ element_var: string; condition_expression?: any }} */
    __publicField(this, "autofocus");
    this.parent = options.parent;
    this.renderer = options.renderer;
    this.name = options.name;
    this.type = options.type;
    this.comment = options.comment;
    this.wrappers = [];
    this.key = options.key;
    this.first = null;
    this.bindings = options.bindings;
    this.chunks = {
      declarations: [],
      init: [],
      create: [],
      claim: [],
      hydrate: [],
      mount: [],
      measure: [],
      restore_measurements: [],
      fix: [],
      animate: [],
      intro: [],
      update: [],
      outro: [],
      destroy: []
    };
    this.has_animation = false;
    this.has_intro_method = false;
    this.has_outro_method = false;
    this.outros = 0;
    this.get_unique_name = this.renderer.component.get_unique_name_maker();
    this.aliases = /* @__PURE__ */ new Map();
    if (this.key)
      this.aliases.set("key", this.get_unique_name("key"));
  }
  assign_variable_names() {
    const seen = /* @__PURE__ */ new Set();
    const dupes = /* @__PURE__ */ new Set();
    let i = this.wrappers.length;
    while (i--) {
      const wrapper = this.wrappers[i];
      if (!wrapper.var)
        continue;
      if (seen.has(wrapper.var.name)) {
        dupes.add(wrapper.var.name);
      }
      seen.add(wrapper.var.name);
    }
    const counts = /* @__PURE__ */ new Map();
    i = this.wrappers.length;
    while (i--) {
      const wrapper = this.wrappers[i];
      if (!wrapper.var)
        continue;
      let suffix = "";
      if (dupes.has(wrapper.var.name)) {
        const i2 = counts.get(wrapper.var.name) || 0;
        counts.set(wrapper.var.name, i2 + 1);
        suffix = i2;
      }
      wrapper.var.name = this.get_unique_name(wrapper.var.name + suffix).name;
    }
  }
  /** @param {Set<string>} dependencies */
  add_dependencies(dependencies) {
    dependencies.forEach((dependency) => {
      this.dependencies.add(dependency);
    });
    this.has_update_method = true;
    if (this.parent) {
      this.parent.add_dependencies(dependencies);
    }
  }
  /**
   * @param {import('estree').Identifier} id
   * @param {import('estree').Node} render_statement
   * @param {import('estree').Node} claim_statement
   * @param {import('estree').Node} parent_node
   * @param {boolean} [no_detach]
   */
  add_element(id2, render_statement, claim_statement, parent_node, no_detach) {
    this.add_variable(id2);
    this.chunks.create.push(b`${id2} = ${render_statement};`);
    if (this.renderer.options.hydratable) {
      this.chunks.claim.push(b`${id2} = ${claim_statement || render_statement};`);
    }
    if (parent_node) {
      this.chunks.mount.push(b`@append(${parent_node}, ${id2});`);
      if (is_head(parent_node) && !no_detach)
        this.chunks.destroy.push(b`@detach(${id2});`);
    } else {
      this.chunks.mount.push(b`@insert(#target, ${id2}, #anchor);`);
      if (!no_detach)
        this.chunks.destroy.push(b`if (detaching) @detach(${id2});`);
    }
  }
  /** @param {boolean} [local] */
  add_intro(local) {
    this.has_intros = this.has_intro_method = true;
    if (!local && this.parent)
      this.parent.add_intro();
  }
  /** @param {boolean} [local] */
  add_outro(local) {
    this.has_outros = this.has_outro_method = true;
    this.outros += 1;
    if (!local && this.parent)
      this.parent.add_outro();
  }
  add_animation() {
    this.has_animation = true;
  }
  /**
   * @param {import('estree').Identifier} id
   * @param {import('estree').Node} [init]
   */
  add_variable(id2, init) {
    if (this.variables.has(id2.name)) {
      throw new Error(`Variable '${id2.name}' already initialised with a different value`);
    }
    this.variables.set(id2.name, { id: id2, init });
  }
  /** @param {string} name */
  alias(name49) {
    if (!this.aliases.has(name49)) {
      this.aliases.set(name49, this.get_unique_name(name49));
    }
    return this.aliases.get(name49);
  }
  /** @param {BlockOptions} options */
  child(options) {
    return new _Block(Object.assign({}, this, { key: null }, options, { parent: this }));
  }
  /** @param {any} [key] */
  get_contents(key) {
    const { dev } = this.renderer.options;
    if (this.has_outros) {
      this.add_variable({ type: "Identifier", name: "#current" });
      if (this.chunks.intro.length > 0) {
        this.chunks.intro.push(b`#current = true;`);
        this.chunks.mount.push(b`#current = true;`);
      }
      if (this.chunks.outro.length > 0) {
        this.chunks.outro.push(b`#current = false;`);
      }
    }
    if (this.autofocus) {
      if (this.autofocus.condition_expression) {
        this.chunks.mount.push(
          b`if (${this.autofocus.condition_expression}) ${this.autofocus.element_var}.focus();`
        );
      } else {
        this.chunks.mount.push(b`${this.autofocus.element_var}.focus();`);
      }
    }
    this.render_binding_groups();
    this.render_listeners();
    const properties3 = {};
    const noop5 = x`@noop`;
    properties3.key = key;
    if (this.first) {
      properties3.first = x`null`;
      this.chunks.hydrate.push(b`this.first = ${this.first};`);
    }
    if (this.chunks.create.length === 0 && this.chunks.hydrate.length === 0) {
      properties3.create = noop5;
    } else {
      const hydrate = this.chunks.hydrate.length > 0 && (this.renderer.options.hydratable ? b`this.h();` : this.chunks.hydrate);
      properties3.create = x`function #create() {
				${this.chunks.create}
				${hydrate}
			}`;
    }
    if (this.renderer.options.hydratable || this.chunks.claim.length > 0) {
      if (this.chunks.claim.length === 0 && this.chunks.hydrate.length === 0) {
        properties3.claim = noop5;
      } else {
        properties3.claim = x`function #claim(#nodes) {
					${this.chunks.claim}
					${this.renderer.options.hydratable && this.chunks.hydrate.length > 0 && b`this.h();`}
				}`;
      }
    }
    if (this.renderer.options.hydratable && this.chunks.hydrate.length > 0) {
      properties3.hydrate = x`function #hydrate() {
				${this.chunks.hydrate}
			}`;
    }
    if (this.chunks.mount.length === 0) {
      properties3.mount = noop5;
    } else if (this.event_listeners.length === 0) {
      properties3.mount = x`function #mount(#target, #anchor) {
				${this.chunks.mount}
			}`;
    } else {
      properties3.mount = x`function #mount(#target, #anchor) {
				${this.chunks.mount}
			}`;
    }
    if (this.has_update_method || this.maintain_context) {
      if (this.chunks.update.length === 0 && !this.maintain_context) {
        properties3.update = noop5;
      } else {
        const ctx = this.maintain_context ? x`#new_ctx` : x`#ctx`;
        let dirty = { type: "Identifier", name: "#dirty" };
        if (!this.renderer.context_overflow && !this.parent) {
          dirty = { type: "ArrayPattern", elements: [dirty] };
        }
        properties3.update = x`function #update(${ctx}, ${dirty}) {
					${this.maintain_context && b`#ctx = ${ctx};`}
					${this.chunks.update}
				}`;
      }
    }
    if (this.has_animation) {
      properties3.measure = x`function #measure() {
				${this.chunks.measure}
			}`;
      if (this.chunks.restore_measurements.length) {
        properties3.restore_measurements = x`function #restore_measurements(#measurement) {
					${this.chunks.restore_measurements}
				}`;
      }
      properties3.fix = x`function #fix() {
				${this.chunks.fix}
			}`;
      properties3.animate = x`function #animate() {
				${this.chunks.animate}
			}`;
    }
    if (this.has_intro_method || this.has_outro_method) {
      if (this.chunks.intro.length === 0) {
        properties3.intro = noop5;
      } else {
        properties3.intro = x`function #intro(#local) {
					${this.has_outros && b`if (#current) return;`}
					${this.chunks.intro}
				}`;
      }
      if (this.chunks.outro.length === 0) {
        properties3.outro = noop5;
      } else {
        properties3.outro = x`function #outro(#local) {
					${this.chunks.outro}
				}`;
      }
    }
    if (this.chunks.destroy.length === 0) {
      properties3.destroy = noop5;
    } else {
      const dispose_elements = [];
      const others = flatten(this.chunks.destroy).filter(
        /** @param {import('estree').Node} node */
        (node) => {
          if (node.type === "IfStatement" && node.test.type === "Identifier" && node.test.name === "detaching") {
            dispose_elements.push(node.consequent);
            return false;
          } else {
            return true;
          }
        }
      );
      properties3.destroy = x`function #destroy(detaching) {
				${dispose_elements.length ? b`if (detaching) { ${dispose_elements} }` : null}
				${others}
			}`;
    }
    if (!this.renderer.component.compile_options.dev) {
      for (const name49 in properties3) {
        const property2 = properties3[name49];
        if (property2)
          property2.id = null;
      }
    }
    const return_value = x`{
			key: ${properties3.key},
			first: ${properties3.first},
			c: ${properties3.create},
			l: ${properties3.claim},
			h: ${properties3.hydrate},
			m: ${properties3.mount},
			p: ${properties3.update},
			r: ${properties3.measure},
			s: ${properties3.restore_measurements},
			f: ${properties3.fix},
			a: ${properties3.animate},
			i: ${properties3.intro},
			o: ${properties3.outro},
			d: ${properties3.destroy}
		}`;
    const block = dev && this.get_unique_name("block");
    const body = b`
			${this.chunks.declarations}

			${Array.from(this.variables.values()).map(({ id: id2, init }) => {
      return init ? b`let ${id2} = ${init}` : b`let ${id2}`;
    })}

			${this.chunks.init}

			${dev ? b`
					const ${block} = ${return_value};
					@dispatch_dev("SvelteRegisterBlock", {
						block: ${block},
						id: ${this.name || "create_fragment"}.name,
						type: "${this.type}",
						source: "${this.comment ? this.comment.replace(regex_double_quotes, '\\"') : ""}",
						ctx: #ctx
					});
					return ${block};` : b`
					return ${return_value};`}
		`;
    return body;
  }
  /** @returns {boolean} */
  has_content() {
    return !!this.first || this.event_listeners.length > 0 || this.chunks.intro.length > 0 || this.chunks.outro.length > 0 || this.chunks.create.length > 0 || this.chunks.hydrate.length > 0 || this.chunks.claim.length > 0 || this.chunks.mount.length > 0 || this.chunks.update.length > 0 || this.chunks.destroy.length > 0 || this.has_animation;
  }
  render() {
    const key = this.key && this.get_unique_name("key");
    const args = [x`#ctx`];
    if (key)
      args.unshift(key);
    const fn = b`function ${this.name}(${args}) {
			${this.get_contents(key)}
		}`;
    return this.comment ? b`
				// ${this.comment}
				${fn}` : fn;
  }
  /** @param {string} chunk */
  render_listeners(chunk = "") {
    if (this.event_listeners.length > 0) {
      this.add_variable({ type: "Identifier", name: "#mounted" });
      this.chunks.destroy.push(b`#mounted = false`);
      const dispose = {
        type: "Identifier",
        name: `#dispose${chunk}`
      };
      this.add_variable(dispose);
      if (this.event_listeners.length === 1) {
        this.chunks.mount.push(b`
						if (!#mounted) {
							${dispose} = ${this.event_listeners[0]};
							#mounted = true;
						}
					`);
        this.chunks.destroy.push(b`${dispose}();`);
      } else {
        this.chunks.mount.push(b`
					if (!#mounted) {
						${dispose} = [
							${this.event_listeners}
						];
						#mounted = true;
					}
				`);
        this.chunks.destroy.push(b`@run_all(${dispose});`);
      }
    }
  }
  render_binding_groups() {
    for (const binding_group of this.binding_groups) {
      binding_group.render(this);
    }
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/Wrapper.js
var Wrapper = class {
  /**
   * @param {import('../../Renderer.js').default} renderer
   * @param {import('../../Block.js').default} block
   * @param {Wrapper} parent
   * @param {NodeType} node
   */
  constructor(renderer, block, parent, node) {
    /** @type {import('../../Renderer.js').default} */
    __publicField(this, "renderer");
    /** @type {Wrapper} */
    __publicField(this, "parent");
    /** @type {NodeType} */
    __publicField(this, "node");
    /** @type {Wrapper | null} */
    __publicField(this, "prev");
    /** @type {Wrapper | null} */
    __publicField(this, "next");
    /** @type {import('estree').Identifier} */
    __publicField(this, "var");
    this.node = node;
    Object.defineProperties(this, {
      renderer: {
        value: renderer
      },
      parent: {
        value: parent
      }
    });
    block.wrappers.push(this);
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  get_or_create_anchor(block, parent_node, parent_nodes) {
    const needs_anchor = this.next ? !this.next.is_dom_node() : !parent_node || !this.parent.is_dom_node();
    const anchor = needs_anchor ? block.get_unique_name(`${this.var.name}_anchor`) : this.next && this.next.var || { type: "Identifier", name: "null" };
    if (needs_anchor) {
      block.add_element(
        anchor,
        x`@empty()`,
        parent_nodes && x`@empty()`,
        /** @type {import('estree').Identifier} */
        parent_node
      );
    }
    return anchor;
  }
  /**
   * @param {import('estree').Identifier} anchor
   * @returns {import('estree').Identifier}
   */
  get_update_mount_node(anchor) {
    return (
      /** @type {import('estree').Identifier} */
      this.parent && this.parent.is_dom_node() ? this.parent.var : x`${anchor}.parentNode`
    );
  }
  is_dom_node() {
    return this.node.type === "Element" || this.node.type === "Text" || this.node.type === "MustacheTag";
  }
  /**
   * @param {import('../../Block.js').default} _block
   * @param {import('estree').Identifier} _parent_node
   * @param {import('estree').Identifier} _parent_nodes
   * @param {Record<string, any>} _data
   */
  render(_block, _parent_node, _parent_nodes, _data = void 0) {
    throw Error("Wrapper class is not renderable");
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/create_debugging_comment.js
function create_debugging_comment(node, component) {
  const { locate: locate2, source } = component;
  let c2 = node.start;
  if (node.type === "ElseBlock") {
    while (source[c2 - 1] !== "{")
      c2 -= 1;
    while (source[c2 - 1] === "{")
      c2 -= 1;
  }
  let d;
  if (node.type === "InlineComponent" || node.type === "Element" || node.type === "SlotTemplate") {
    if (node.children.length) {
      d = node.children[0].start;
      while (source[d - 1] !== ">")
        d -= 1;
    } else {
      d = node.start;
      while (source[d] !== ">")
        d += 1;
      d += 1;
    }
  } else if (node.type === "Text" || node.type === "Comment") {
    d = node.end;
  } else {
    d = node.expression ? node.expression.node.end : c2;
    while (source[d] !== "}" && d <= source.length)
      d += 1;
    while (source[d] === "}")
      d += 1;
  }
  const start = locate2(c2);
  const loc = `(${start.line}:${start.column})`;
  return `${loc} ${source.slice(c2, d)}`.replace(regex_whitespace_characters, " ");
}

// node_modules/svelte/src/compiler/compile/nodes/shared/Node.js
var Node3 = class {
  /**
   * @param {import('../../Component.js').default} component
   * @param {Node} parent
   * @param {any} _scope
   * @param {import('../../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, _scope, info) {
    /**
     * @readonly
     * @type {number}
     */
    __publicField(this, "start");
    /**
     * @readonly
     * @type {number}
     */
    __publicField(this, "end");
    /**
     * @readonly
     * @type {import('../../Component.js').default}
     */
    __publicField(this, "component");
    /**
     * @readonly
     * @type {Parent}
     */
    __publicField(this, "parent");
    /**
     * @readonly
     * @type {Type}
     */
    __publicField(this, "type");
    /** @type {import('../interfaces.js').INode} */
    __publicField(this, "prev");
    /** @type {import('../interfaces.js').INode} */
    __publicField(this, "next");
    /** @type {boolean} */
    __publicField(this, "can_use_innerhtml");
    /** @type {boolean} */
    __publicField(this, "is_static_content");
    /** @type {string} */
    __publicField(this, "var");
    /** @type {import('../Attribute.js').default[]} */
    __publicField(this, "attributes", []);
    this.start = info.start;
    this.end = info.end;
    this.type = /** @type {Type} */
    info.type;
    Object.defineProperties(this, {
      component: {
        value: component
      },
      parent: {
        value: parent
      }
    });
    this.can_use_innerhtml = true;
    this.is_static_content = true;
  }
  cannot_use_innerhtml() {
    if (this.can_use_innerhtml !== false) {
      this.can_use_innerhtml = false;
      if (this.parent)
        this.parent.cannot_use_innerhtml();
    }
  }
  not_static_content() {
    this.is_static_content = false;
    if (this.parent)
      this.parent.not_static_content();
  }
  /** @param {RegExp} selector */
  find_nearest(selector2) {
    if (selector2.test(this.type))
      return this;
    if (this.parent)
      return this.parent.find_nearest(selector2);
  }
  /** @param {string} name */
  get_static_attribute_value(name49) {
    const attribute = this.attributes.find(
      /** @param {import('../Attribute.js').default} attr */
      (attr) => attr.type === "Attribute" && attr.name.toLowerCase() === name49
    );
    if (!attribute)
      return null;
    if (attribute.is_true)
      return true;
    if (attribute.chunks.length === 0)
      return "";
    if (attribute.chunks.length === 1 && attribute.chunks[0].type === "Text") {
      return (
        /** @type {import('../Text.js').default} */
        attribute.chunks[0].data
      );
    }
    return null;
  }
  /** @param {string} type */
  has_ancestor(type) {
    return this.parent ? this.parent.type === type || this.parent.has_ancestor(type) : false;
  }
};

// node_modules/svelte/src/compiler/compile/compiler_warnings.js
var compiler_warnings_default = {
  tag_option_deprecated: {
    code: "tag-option-deprecated",
    message: "'tag' option is deprecated — use 'customElement' instead"
  },
  unused_export_let: (
    /**
    * @param {string} component
    * @param {string} property
    */
    (component, property2) => ({
      code: "unused-export-let",
      message: `${component} has unused export property '${property2}'. If it is for external reference only, please consider using \`export const ${property2}\``
    })
  ),
  module_script_reactive_declaration: {
    code: "module-script-reactive-declaration",
    message: "$: has no effect in a module script"
  },
  non_top_level_reactive_declaration: {
    code: "non-top-level-reactive-declaration",
    message: "$: has no effect outside of the top-level"
  },
  module_script_variable_reactive_declaration: (
    /** @param {string[]} names */
    (names) => ({
      code: "module-script-reactive-declaration",
      message: `${names.map((name49) => `"${name49}"`).join(", ")} ${names.length > 1 ? "are" : "is"} declared in a module script and will not be reactive`
    })
  ),
  missing_declaration: (
    /**
    * @param {string} name
    * @param {boolean} has_script
    */
    (name49, has_script) => ({
      code: "missing-declaration",
      message: `'${name49}' is not defined` + (has_script ? "" : `. Consider adding a <script> block with 'export let ${name49}' to declare a prop`)
    })
  ),
  missing_custom_element_compile_options: {
    code: "missing-custom-element-compile-options",
    message: "The 'customElement' option is used when generating a custom element. Did you forget the 'customElement: true' compile option?"
  },
  css_unused_selector: (
    /** @param {string} selector */
    (selector2) => ({
      code: "css-unused-selector",
      message: `Unused CSS selector "${selector2}"`
    })
  ),
  empty_block: {
    code: "empty-block",
    message: "Empty block"
  },
  reactive_component: (
    /** @param {string} name */
    (name49) => ({
      code: "reactive-component",
      message: `<${name49}/> will not be reactive if ${name49} changes. Use <svelte:component this={${name49}}/> if you want this reactivity.`
    })
  ),
  component_name_lowercase: (
    /** @param {string} name */
    (name49) => ({
      code: "component-name-lowercase",
      message: `<${name49}> will be treated as an HTML element unless it begins with a capital letter`
    })
  ),
  avoid_is: {
    code: "avoid-is",
    message: "The 'is' attribute is not supported cross-browser and should be avoided"
  },
  invalid_html_attribute: (
    /**
    * @param {string} name
    * @param {string} suggestion
    */
    (name49, suggestion) => ({
      code: "invalid-html-attribute",
      message: `'${name49}' is not a valid HTML attribute. Did you mean '${suggestion}'?`
    })
  ),
  a11y_aria_attributes: (
    /** @param {string} name */
    (name49) => ({
      code: "a11y-aria-attributes",
      message: `A11y: <${name49}> should not have aria-* attributes`
    })
  ),
  a11y_incorrect_attribute_type: (
    /**
    * @param {import('aria-query').ARIAPropertyDefinition} schema
    * @param {string} attribute
    */
    (schema, attribute) => {
      let message;
      switch (schema.type) {
        case "boolean":
          message = `The value of '${attribute}' must be exactly one of true or false`;
          break;
        case "id":
          message = `The value of '${attribute}' must be a string that represents a DOM element ID`;
          break;
        case "idlist":
          message = `The value of '${attribute}' must be a space-separated list of strings that represent DOM element IDs`;
          break;
        case "tristate":
          message = `The value of '${attribute}' must be exactly one of true, false, or mixed`;
          break;
        case "token":
          message = `The value of '${attribute}' must be exactly one of ${(schema.values || []).join(
            ", "
          )}`;
          break;
        case "tokenlist":
          message = `The value of '${attribute}' must be a space-separated list of one or more of ${(schema.values || []).join(", ")}`;
          break;
        default:
          message = `The value of '${attribute}' must be of type ${schema.type}`;
      }
      return {
        code: "a11y-incorrect-aria-attribute-type",
        message: `A11y: ${message}`
      };
    }
  ),
  a11y_unknown_aria_attribute: (
    /**
    * @param {string} attribute
    * @param {string} [suggestion]
    */
    (attribute, suggestion) => ({
      code: "a11y-unknown-aria-attribute",
      message: `A11y: Unknown aria attribute 'aria-${attribute}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : "")
    })
  ),
  a11y_hidden: (
    /** @param {string} name */
    (name49) => ({
      code: "a11y-hidden",
      message: `A11y: <${name49}> element should not be hidden`
    })
  ),
  a11y_misplaced_role: (
    /** @param {string} name */
    (name49) => ({
      code: "a11y-misplaced-role",
      message: `A11y: <${name49}> should not have role attribute`
    })
  ),
  a11y_unknown_role: (
    /**
    * @param {string | boolean} role
    * @param {string} [suggestion]
    */
    (role, suggestion) => ({
      code: "a11y-unknown-role",
      message: `A11y: Unknown role '${role}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : "")
    })
  ),
  a11y_no_abstract_role: (
    /** @param {string | boolean} role */
    (role) => ({
      code: "a11y-no-abstract-role",
      message: `A11y: Abstract role '${role}' is forbidden`
    })
  ),
  a11y_no_redundant_roles: (
    /** @param {string | boolean} role */
    (role) => ({
      code: "a11y-no-redundant-roles",
      message: `A11y: Redundant role '${role}'`
    })
  ),
  a11y_no_static_element_interactions: (
    /**
    * @param {string} element
    * @param {string[]} handlers
    */
    (element, handlers3) => ({
      code: "a11y-no-static-element-interactions",
      message: `A11y: <${element}> with ${handlers3.join(", ")} ${handlers3.length === 1 ? "handler" : "handlers"} must have an ARIA role`
    })
  ),
  a11y_no_interactive_element_to_noninteractive_role: (
    /**
    * @param {string | boolean} role
    * @param {string} element
    */
    (role, element) => ({
      code: "a11y-no-interactive-element-to-noninteractive-role",
      message: `A11y: <${element}> cannot have role '${role}'`
    })
  ),
  a11y_no_noninteractive_element_interactions: (
    /** @param {string} element */
    (element) => ({
      code: "a11y-no-noninteractive-element-interactions",
      message: `A11y: Non-interactive element <${element}> should not be assigned mouse or keyboard event listeners.`
    })
  ),
  a11y_no_noninteractive_element_to_interactive_role: (
    /**
    * @param {string | boolean} role
    * @param {string} element
    */
    (role, element) => ({
      code: "a11y-no-noninteractive-element-to-interactive-role",
      message: `A11y: Non-interactive element <${element}> cannot have interactive role '${role}'`
    })
  ),
  a11y_role_has_required_aria_props: (
    /**
    * @param {string} role
    * @param {string[]} props
    */
    (role, props) => ({
      code: "a11y-role-has-required-aria-props",
      message: `A11y: Elements with the ARIA role "${role}" must have the following attributes defined: ${props.map((name49) => `"${name49}"`).join(", ")}`
    })
  ),
  a11y_role_supports_aria_props: (
    /**
    * @param {string} attribute
    * @param {string} role
    * @param {boolean} is_implicit
    * @param {string} name
    */
    (attribute, role, is_implicit, name49) => {
      let message = `The attribute '${attribute}' is not supported by the role '${role}'.`;
      if (is_implicit) {
        message += ` This role is implicit on the element <${name49}>.`;
      }
      return {
        code: "a11y-role-supports-aria-props",
        message: `A11y: ${message}`
      };
    }
  ),
  a11y_accesskey: {
    code: "a11y-accesskey",
    message: "A11y: Avoid using accesskey"
  },
  a11y_autofocus: {
    code: "a11y-autofocus",
    message: "A11y: Avoid using autofocus"
  },
  a11y_misplaced_scope: {
    code: "a11y-misplaced-scope",
    message: "A11y: The scope attribute should only be used with <th> elements"
  },
  a11y_positive_tabindex: {
    code: "a11y-positive-tabindex",
    message: "A11y: avoid tabindex values above zero"
  },
  a11y_invalid_attribute: (
    /**
    * @param {string} href_attribute
    * @param {string} href_value
    */
    (href_attribute, href_value) => ({
      code: "a11y-invalid-attribute",
      message: `A11y: '${href_value}' is not a valid ${href_attribute} attribute`
    })
  ),
  a11y_missing_attribute: (
    /**
    * @param {string} name
    * @param {string} article
    * @param {string} sequence
    */
    (name49, article, sequence) => ({
      code: "a11y-missing-attribute",
      message: `A11y: <${name49}> element should have ${article} ${sequence} attribute`
    })
  ),
  a11y_autocomplete_valid: (
    /**
    * @param {null | true | string} type
    * @param {null | true | string} value
    */
    (type, value) => ({
      code: "a11y-autocomplete-valid",
      message: `A11y: The value '${value}' is not supported by the attribute 'autocomplete' on element <input type="${type || "..."}">`
    })
  ),
  a11y_img_redundant_alt: {
    code: "a11y-img-redundant-alt",
    message: "A11y: Screenreaders already announce <img> elements as an image."
  },
  a11y_interactive_supports_focus: (
    /** @param {string} role */
    (role) => ({
      code: "a11y-interactive-supports-focus",
      message: `A11y: Elements with the '${role}' interactive role must have a tabindex value.`
    })
  ),
  a11y_label_has_associated_control: {
    code: "a11y-label-has-associated-control",
    message: "A11y: A form label must be associated with a control."
  },
  a11y_media_has_caption: {
    code: "a11y-media-has-caption",
    message: 'A11y: <video> elements must have a <track kind="captions">'
  },
  a11y_distracting_elements: (
    /** @param {string} name */
    (name49) => ({
      code: "a11y-distracting-elements",
      message: `A11y: Avoid <${name49}> elements`
    })
  ),
  a11y_structure_immediate: {
    code: "a11y-structure",
    message: "A11y: <figcaption> must be an immediate child of <figure>"
  },
  a11y_structure_first_or_last: {
    code: "a11y-structure",
    message: "A11y: <figcaption> must be first or last child of <figure>"
  },
  a11y_mouse_events_have_key_events: (
    /**
    * @param {string} event
    * @param {string} accompanied_by
    */
    (event, accompanied_by) => ({
      code: "a11y-mouse-events-have-key-events",
      message: `A11y: on:${event} must be accompanied by on:${accompanied_by}`
    })
  ),
  a11y_click_events_have_key_events: {
    code: "a11y-click-events-have-key-events",
    message: 'A11y: visible, non-interactive elements with an on:click event must be accompanied by a keyboard event handler. Consider whether an interactive element such as <button type="button"> or <a> might be more appropriate. See https://svelte.dev/docs/accessibility-warnings#a11y-click-events-have-key-events for more details.'
  },
  a11y_missing_content: (
    /** @param {string} name */
    (name49) => ({
      code: "a11y-missing-content",
      message: `A11y: <${name49}> element should have child content`
    })
  ),
  a11y_no_noninteractive_tabindex: {
    code: "a11y-no-noninteractive-tabindex",
    message: "A11y: noninteractive element cannot have nonnegative tabIndex value"
  },
  a11y_aria_activedescendant_has_tabindex: {
    code: "a11y-aria-activedescendant-has-tabindex",
    message: "A11y: Elements with attribute aria-activedescendant should have tabindex value"
  },
  redundant_event_modifier_for_touch: {
    code: "redundant-event-modifier",
    message: "Touch event handlers that don't use the 'event' object are passive by default"
  },
  redundant_event_modifier_passive: {
    code: "redundant-event-modifier",
    message: "The passive modifier only works with wheel and touch events"
  },
  invalid_rest_eachblock_binding: (
    /** @param {string} rest_element_name */
    (rest_element_name) => ({
      code: "invalid-rest-eachblock-binding",
      message: `The rest operator (...) will create a new object and binding '${rest_element_name}' with the original object will not work`
    })
  ),
  avoid_mouse_events_on_document: {
    code: "avoid-mouse-events-on-document",
    message: "Mouse enter/leave events on the document are not supported in all browsers and should be avoided"
  },
  illegal_attribute_character: {
    code: "illegal-attribute-character",
    message: "Attributes should not contain ':' characters to prevent ambiguity with Svelte directives"
  }
};

// node_modules/svelte/src/compiler/compile/nodes/shared/AbstractBlock.js
var regex_non_whitespace_characters = /[^ \r\n\f\v\t]/;
var AbstractBlock = class extends Node3 {
  /**
   * @param {import('../../Component.js').default} component
   * @param {any} parent
   * @param {any} scope
   * @param {any} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('../../render_dom/Block.js').default} */
    __publicField(this, "block");
    /** @type {import('../interfaces.js').INode[]} */
    __publicField(this, "children");
  }
  warn_if_empty_block() {
    if (!this.children || this.children.length > 1)
      return;
    const child = this.children[0];
    if (!child || child.type === "Text" && !regex_non_whitespace_characters.test(child.data)) {
      this.component.warn(this, compiler_warnings_default.empty_block);
    }
  }
};

// node_modules/svelte/src/compiler/compile/utils/flatten_reference.js
function flatten_reference(node) {
  const nodes = [];
  const parts = [];
  while (node.type === "MemberExpression") {
    nodes.unshift(node.property);
    if (!node.computed) {
      parts.unshift(
        /** @type {import('estree').Identifier} */
        node.property.name
      );
    } else {
      const computed_property = to_string2(node.property);
      if (computed_property) {
        parts.unshift(`[${computed_property}]`);
      }
    }
    node = node.object;
  }
  const name49 = node.type === "Identifier" ? node.name : node.type === "ThisExpression" ? "this" : null;
  nodes.unshift(node);
  parts.unshift(name49);
  return { name: name49, nodes, parts };
}
function to_string2(node) {
  switch (node.type) {
    case "Literal":
      return String(node.value);
    case "Identifier":
      return node.name;
  }
}

// node_modules/svelte/src/compiler/compile/utils/scope.js
function create_scopes(expression) {
  return analyze(expression);
}

// node_modules/svelte/src/compiler/compile/utils/get_object.js
function get_object(node) {
  while (node.type === "MemberExpression")
    node = node.object;
  return (
    /** @type {import('estree').Identifier} */
    node
  );
}

// node_modules/svelte/src/compiler/compile/utils/reserved_keywords.js
var reserved_keywords = /* @__PURE__ */ new Set(["$$props", "$$restProps", "$$slots"]);
function is_reserved_keyword(name49) {
  return reserved_keywords.has(name49);
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/is_dynamic.js
function is_dynamic(variable) {
  if (variable) {
    const is_declared_in_reactive_context = !variable.module && !variable.global;
    if (is_declared_in_reactive_context && (variable.mutated || variable.reassigned))
      return true;
    if (is_declared_in_reactive_context && variable.writable && variable.export_name)
      return true;
    if (is_reserved_keyword(variable.name))
      return true;
  }
  return false;
}

// node_modules/svelte/src/compiler/utils/nodes_match.js
function nodes_match(a, b2, ignore_keys = []) {
  if (!!a !== !!b2)
    return false;
  if (Array.isArray(a) !== Array.isArray(b2))
    return false;
  if (a && typeof a === "object") {
    if (Array.isArray(a)) {
      if (a.length !== b2.length)
        return false;
      return a.every((child, i2) => nodes_match(child, b2[i2]));
    }
    const a_keys = Object.keys(a).sort().filter((key) => !ignore_keys.includes(key));
    const b_keys = Object.keys(b2).sort().filter((key) => !ignore_keys.includes(key));
    if (a_keys.length !== b_keys.length)
      return false;
    let i = a_keys.length;
    while (i--) {
      const key = a_keys[i];
      if (b_keys[i] !== key)
        return false;
      if (key === "start" || key === "end")
        continue;
      if (!nodes_match(a[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a === b2;
}

// node_modules/svelte/src/compiler/compile/render_dom/invalidate.js
function invalidate(renderer, scope, node, names, main_execution_context = false) {
  const { component } = renderer;
  const [head, ...tail] = (
    /** @type {import('../../interfaces.js').Var[]} */
    Array.from(names).filter((name49) => {
      const owner = scope.find_owner(name49);
      return !owner || owner === component.instance_scope;
    }).map((name49) => component.var_lookup.get(name49)).filter((variable) => {
      return variable && !variable.hoistable && !variable.global && !variable.module && (variable.referenced || variable.subscribable || variable.is_reactive_dependency || variable.export_name || variable.name[0] === "$");
    })
  );
  function get_invalidated(variable, node2) {
    if (main_execution_context && !variable.subscribable && variable.name[0] !== "$") {
      return node2;
    }
    return renderer_invalidate(renderer, variable.name, void 0, main_execution_context);
  }
  if (!head) {
    return node;
  }
  component.has_reactive_assignments = true;
  if (node.type === "AssignmentExpression" && node.operator === "=" && nodes_match(node.left, node.right, ["trailingComments", "leadingComments"]) && tail.length === 0) {
    return get_invalidated(head, node);
  }
  const is_store_value = head.name[0] === "$" && head.name[1] !== "$";
  const extra_args = tail.map((variable) => get_invalidated(variable)).filter(Boolean);
  if (is_store_value) {
    return x`@set_store_value(${head.name.slice(1)}, ${node}, ${head.name}, ${extra_args})`;
  }
  let invalidate2;
  if (!main_execution_context) {
    const pass_value = extra_args.length > 0 || node.type === "AssignmentExpression" && node.left.type !== "Identifier" || node.type === "UpdateExpression" && (!node.prefix || node.argument.type !== "Identifier");
    if (pass_value) {
      extra_args.unshift({
        type: "Identifier",
        name: head.name
      });
    }
    invalidate2 = x`$$invalidate(${renderer.context_lookup.get(head.name).index}, ${node}, ${extra_args})`;
  } else {
    invalidate2 = extra_args.length ? [node, ...extra_args] : node;
  }
  if (head.subscribable && head.reassigned) {
    const subscribe = `$$subscribe_${head.name}`;
    invalidate2 = x`${subscribe}(${invalidate2})`;
  }
  return invalidate2;
}
function renderer_invalidate(renderer, name49, value, main_execution_context = false) {
  const variable = renderer.component.var_lookup.get(name49);
  if (variable && variable.subscribable && (variable.reassigned || variable.export_name)) {
    if (main_execution_context) {
      return x`${`$$subscribe_${name49}`}(${value || name49})`;
    } else {
      const member = renderer.context_lookup.get(name49);
      return x`${`$$subscribe_${name49}`}($$invalidate(${member.index}, ${value || name49}))`;
    }
  }
  if (name49[0] === "$" && name49[1] !== "$") {
    return x`${name49.slice(1)}.set(${value || name49})`;
  }
  if (variable && (variable.module || !variable.referenced && !variable.is_reactive_dependency && !variable.export_name && !name49.startsWith("$$"))) {
    return value || name49;
  }
  if (value) {
    if (main_execution_context) {
      return x`${value}`;
    } else {
      const member = renderer.context_lookup.get(name49);
      return x`$$invalidate(${member.index}, ${value})`;
    }
  }
  if (main_execution_context)
    return;
  const deps = /* @__PURE__ */ new Set([name49]);
  deps.forEach((name50) => {
    const reactive_declarations = renderer.component.reactive_declarations.filter(
      (x2) => x2.assignees.has(name50)
    );
    reactive_declarations.forEach((declaration) => {
      declaration.dependencies.forEach((name51) => {
        deps.add(name51);
      });
    });
  });
  const filtered = Array.from(deps).filter((n2) => renderer.context_lookup.has(n2));
  if (!filtered.length)
    return null;
  return filtered.map((n2) => x`$$invalidate(${renderer.context_lookup.get(n2).index}, ${n2})`).reduce((lhs, rhs) => x`${lhs}, ${rhs}`);
}

// node_modules/svelte/src/compiler/compile/utils/replace_object.js
function replace_object(node, replacement) {
  if (node.type === "Identifier")
    return replacement;
  const ancestor = node;
  let parent;
  while (node.type === "MemberExpression") {
    parent = node;
    node = node.object;
  }
  parent.object = /** @type {any} */
  replacement;
  return ancestor;
}

// node_modules/svelte/src/compiler/compile/nodes/shared/is_contextual.js
function is_contextual(component, scope, name49) {
  if (is_reserved_keyword(name49))
    return true;
  if (!scope.is_top_level(name49))
    return true;
  const variable = component.var_lookup.get(name49);
  if (!variable || variable.hoistable)
    return false;
  return true;
}

// node_modules/svelte/src/compiler/utils/clone.js
function clone2(val) {
  let k, out, tmp;
  if (Array.isArray(val)) {
    out = Array(k = val.length);
    while (k--)
      out[k] = (tmp = val[k]) && typeof tmp === "object" ? clone2(tmp) : tmp;
    return out;
  }
  if (Object.prototype.toString.call(val) === "[object Object]") {
    out = {};
    for (k in val) {
      if (k === "__proto__") {
        Object.defineProperty(out, k, {
          value: clone2(val[k]),
          configurable: true,
          enumerable: true,
          writable: true
        });
      } else if (typeof val[k] !== "function") {
        out[k] = (tmp = val[k]) && typeof tmp === "object" ? clone2(tmp) : tmp;
      }
    }
    return out;
  }
  return val;
}

// node_modules/svelte/src/compiler/compile/compiler_errors.js
var compiler_errors_default = {
  invalid_binding_elements: (
    /**
    * @param {string} element
    * @param {string} binding
    */
    (element, binding) => ({
      code: "invalid-binding",
      message: `'${binding}' is not a valid binding on <${element}> elements`
    })
  ),
  invalid_binding_element_with: (
    /**
    * @param {string} elements
    * @param {string} binding
    */
    (elements, binding) => ({
      code: "invalid-binding",
      message: `'${binding}' binding can only be used with ${elements}`
    })
  ),
  invalid_binding_on: (
    /**
    * @param {string} binding
    * @param {string} element
    * @param {string} [post]
    */
    (binding, element, post) => ({
      code: "invalid-binding",
      message: `'${binding}' is not a valid binding on ${element}` + (post || "")
    })
  ),
  invalid_binding_foreign: (
    /** @param {string} binding */
    (binding) => ({
      code: "invalid-binding",
      message: `'${binding}' is not a valid binding. Foreign elements only support bind:this`
    })
  ),
  invalid_binding_no_checkbox: (
    /**
    * @param {string} binding
    * @param {boolean} is_radio
    */
    (binding, is_radio) => ({
      code: "invalid-binding",
      message: `'${binding}' binding can only be used with <input type="checkbox">` + (is_radio ? ` — for <input type="radio">, use 'group' binding` : "")
    })
  ),
  invalid_binding: (
    /** @param {string} binding */
    (binding) => ({
      code: "invalid-binding",
      message: `'${binding}' is not a valid binding`
    })
  ),
  invalid_binding_window: (
    /** @param {string[]} parts */
    (parts) => ({
      code: "invalid-binding",
      message: `Bindings on <svelte:window> must be to top-level properties, e.g. '${parts[parts.length - 1]}' rather than '${parts.join(".")}'`
    })
  ),
  invalid_binding_let: {
    code: "invalid-binding",
    message: "Cannot bind to a variable declared with the let: directive"
  },
  invalid_binding_await: {
    code: "invalid-binding",
    message: "Cannot bind to a variable declared with {#await ... then} or {:catch} blocks"
  },
  invalid_binding_const: {
    code: "invalid-binding",
    message: "Cannot bind to a variable declared with {@const ...}"
  },
  invalid_binding_writable: {
    code: "invalid-binding",
    message: "Cannot bind to a variable which is not writable"
  },
  binding_undeclared: (
    /** @param {string} name */
    (name49) => ({
      code: "binding-undeclared",
      message: `${name49} is not declared`
    })
  ),
  invalid_type: {
    code: "invalid-type",
    message: "'type' attribute cannot be dynamic if input uses two-way binding"
  },
  missing_type: {
    code: "missing-type",
    message: "'type' attribute must be specified"
  },
  dynamic_multiple_attribute: {
    code: "dynamic-multiple-attribute",
    message: "'multiple' attribute cannot be dynamic if select uses two-way binding"
  },
  missing_contenteditable_attribute: {
    code: "missing-contenteditable-attribute",
    message: "'contenteditable' attribute is required for textContent, innerHTML and innerText two-way bindings"
  },
  dynamic_contenteditable_attribute: {
    code: "dynamic-contenteditable-attribute",
    message: "'contenteditable' attribute cannot be dynamic if element uses two-way binding"
  },
  invalid_event_modifier_combination: (
    /**
    * @param {string} modifier1
    * @param {string} modifier2
    */
    (modifier1, modifier2) => ({
      code: "invalid-event-modifier",
      message: `The '${modifier1}' and '${modifier2}' modifiers cannot be used together`
    })
  ),
  invalid_event_modifier_legacy: (
    /** @param {string} modifier */
    (modifier) => ({
      code: "invalid-event-modifier",
      message: `The '${modifier}' modifier cannot be used in legacy mode`
    })
  ),
  invalid_event_modifier: (
    /** @param {string} valid */
    (valid) => ({
      code: "invalid-event-modifier",
      message: `Valid event modifiers are ${valid}`
    })
  ),
  invalid_event_modifier_component: {
    code: "invalid-event-modifier",
    message: "Event modifiers other than 'once' can only be used on DOM elements"
  },
  textarea_duplicate_value: {
    code: "textarea-duplicate-value",
    message: "A <textarea> can have either a value attribute or (equivalently) child content, but not both"
  },
  illegal_attribute: (
    /** @param {string} name */
    (name49) => ({
      code: "illegal-attribute",
      message: `'${name49}' is not a valid attribute name`
    })
  ),
  invalid_slot_attribute: {
    code: "invalid-slot-attribute",
    message: "slot attribute cannot have a dynamic value"
  },
  duplicate_slot_attribute: (
    /** @param {string} name */
    (name49) => ({
      code: "duplicate-slot-attribute",
      message: `Duplicate '${name49}' slot`
    })
  ),
  invalid_slotted_content: {
    code: "invalid-slotted-content",
    message: "Element with a slot='...' attribute must be a child of a component or a descendant of a custom element"
  },
  invalid_attribute_head: {
    code: "invalid-attribute",
    message: "<svelte:head> should not have any attributes or directives"
  },
  invalid_action: {
    code: "invalid-action",
    message: "Actions can only be applied to DOM elements, not components"
  },
  invalid_animation: {
    code: "invalid-animation",
    message: "Animations can only be applied to DOM elements, not components"
  },
  invalid_class: {
    code: "invalid-class",
    message: "Classes can only be applied to DOM elements, not components"
  },
  invalid_transition: {
    code: "invalid-transition",
    message: "Transitions can only be applied to DOM elements, not components"
  },
  invalid_let: {
    code: "invalid-let",
    message: "let directive value must be an identifier or an object/array pattern"
  },
  invalid_slot_directive: {
    code: "invalid-slot-directive",
    message: "<slot> cannot have directives"
  },
  dynamic_slot_name: {
    code: "dynamic-slot-name",
    message: "<slot> name cannot be dynamic"
  },
  invalid_slot_name: {
    code: "invalid-slot-name",
    message: "default is a reserved word — it cannot be used as a slot name"
  },
  invalid_slot_attribute_value_missing: {
    code: "invalid-slot-attribute",
    message: "slot attribute value is missing"
  },
  invalid_slotted_content_fragment: {
    code: "invalid-slotted-content",
    message: "<svelte:fragment> must be a child of a component"
  },
  illegal_attribute_title: {
    code: "illegal-attribute",
    message: "<title> cannot have attributes"
  },
  illegal_structure_title: {
    code: "illegal-structure",
    message: "<title> can only contain text and {tags}"
  },
  duplicate_transition: (
    /**
    * @param {string} directive
    * @param {string} parent_directive
    */
    (directive, parent_directive) => {
      function describe(_directive) {
        return _directive === "transition" ? "a 'transition'" : `an '${_directive}'`;
      }
      const message = directive === parent_directive ? `An element can only have one '${directive}' directive` : `An element cannot have both ${describe(parent_directive)} directive and ${describe(
        directive
      )} directive`;
      return {
        code: "duplicate-transition",
        message
      };
    }
  ),
  contextual_store: {
    code: "contextual-store",
    message: "Stores must be declared at the top level of the component (this may change in a future version of Svelte)"
  },
  default_export: {
    code: "default-export",
    message: "A component cannot have a default export"
  },
  illegal_declaration: {
    code: "illegal-declaration",
    message: "The $ prefix is reserved, and cannot be used for variable and import names"
  },
  illegal_subscription: {
    code: "illegal-subscription",
    message: 'Cannot reference store value inside <script context="module">'
  },
  illegal_global: (
    /** @param {string} name */
    (name49) => ({
      code: "illegal-global",
      message: `${name49} is an illegal variable name`
    })
  ),
  illegal_variable_declaration: {
    code: "illegal-variable-declaration",
    message: 'Cannot declare same variable name which is imported inside <script context="module">'
  },
  cyclical_reactive_declaration: (
    /** @param {string[]} cycle */
    (cycle) => ({
      code: "cyclical-reactive-declaration",
      message: `Cyclical dependency detected: ${cycle.join(" → ")}`
    })
  ),
  invalid_tag_property: {
    code: "invalid-tag-property",
    message: "tag name must be two or more words joined by the '-' character"
  },
  invalid_customElement_attribute: {
    code: "invalid-customElement-attribute",
    message: "'customElement' must be a string literal defining a valid custom element name or an object of the form { tag: string; shadow?: 'open' | 'none'; props?: { [key: string]: { attribute?: string; reflect?: boolean; type: .. } } }"
  },
  invalid_tag_attribute: {
    code: "invalid-tag-attribute",
    message: "'tag' must be a string literal"
  },
  invalid_shadow_attribute: {
    code: "invalid-shadow-attribute",
    message: "'shadow' must be either 'open' or 'none'"
  },
  invalid_props_attribute: {
    code: "invalid-props-attribute",
    message: "'props' must be a statically analyzable object literal of the form '{ [key: string]: { attribute?: string; reflect?: boolean; type?: 'String' | 'Boolean' | 'Number' | 'Array' | 'Object' }'"
  },
  invalid_namespace_property: (
    /**
    * @param {string} namespace
    * @param {string} [suggestion]
    */
    (namespace, suggestion) => ({
      code: "invalid-namespace-property",
      message: `Invalid namespace '${namespace}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : "")
    })
  ),
  invalid_namespace_attribute: {
    code: "invalid-namespace-attribute",
    message: "The 'namespace' attribute must be a string literal representing a valid namespace"
  },
  invalid_attribute_value: (
    /** @param {string} name */
    (name49) => ({
      code: `invalid-${name49}-value`,
      message: `${name49} attribute must be true or false`
    })
  ),
  invalid_options_attribute_unknown: (
    /** @param {string} name */
    (name49) => ({
      code: "invalid-options-attribute",
      message: `<svelte:options> unknown attribute '${name49}'`
    })
  ),
  invalid_options_attribute: {
    code: "invalid-options-attribute",
    message: "<svelte:options> can only have static 'tag', 'namespace', 'accessors', 'immutable' and 'preserveWhitespace' attributes"
  },
  css_invalid_global: {
    code: "css-invalid-global",
    message: ":global(...) can be at the start or end of a selector sequence, but not in the middle"
  },
  css_invalid_global_selector: {
    code: "css-invalid-global-selector",
    message: ":global(...) must contain a single selector"
  },
  css_invalid_global_selector_position: {
    code: "css-invalid-global-selector-position",
    message: ":global(...) not at the start of a selector sequence should not contain type or universal selectors"
  },
  css_invalid_selector: (
    /** @param {string} selector */
    (selector2) => ({
      code: "css-invalid-selector",
      message: `Invalid selector "${selector2}"`
    })
  ),
  duplicate_animation: {
    code: "duplicate-animation",
    message: "An element can only have one 'animate' directive"
  },
  invalid_animation_immediate: {
    code: "invalid-animation",
    message: "An element that uses the animate directive must be the immediate child of a keyed each block"
  },
  invalid_animation_key: {
    code: "invalid-animation",
    message: "An element that uses the animate directive must be used inside a keyed each block. Did you forget to add a key to your each block?"
  },
  invalid_animation_sole: {
    code: "invalid-animation",
    message: "An element that uses the animate directive must be the sole child of a keyed each block"
  },
  invalid_animation_dynamic_element: {
    code: "invalid-animation",
    message: "<svelte:element> cannot have a animate directive"
  },
  invalid_directive_value: {
    code: "invalid-directive-value",
    message: "Can only bind to an identifier (e.g. `foo`) or a member expression (e.g. `foo.bar` or `foo[baz]`)"
  },
  invalid_const_placement: {
    code: "invalid-const-placement",
    message: "{@const} must be the immediate child of {#if}, {:else if}, {:else}, {#each}, {:then}, {:catch}, <svelte:fragment> or <Component>"
  },
  invalid_const_declaration: (
    /** @param {string} name */
    (name49) => ({
      code: "invalid-const-declaration",
      message: `'${name49}' has already been declared`
    })
  ),
  invalid_const_update: (
    /** @param {string} name */
    (name49) => ({
      code: "invalid-const-update",
      message: `'${name49}' is declared using {@const ...} and is read-only`
    })
  ),
  cyclical_const_tags: (
    /** @param {string[]} cycle */
    (cycle) => ({
      code: "cyclical-const-tags",
      message: `Cyclical dependency detected: ${cycle.join(" → ")}`
    })
  ),
  invalid_component_style_directive: {
    code: "invalid-component-style-directive",
    message: "Style directives cannot be used on components"
  },
  invalid_var_declaration: {
    code: "invalid_var_declaration",
    message: '"var" scope should not extend outside the reactive block'
  },
  invalid_style_directive_modifier: (
    /** @param {string} valid */
    (valid) => ({
      code: "invalid-style-directive-modifier",
      message: `Valid modifiers for style directives are: ${valid}`
    })
  )
};

// node_modules/svelte/src/compiler/compile/nodes/shared/Expression.js
var regex_contains_term_function_expression = /FunctionExpression/;
var Expression = class {
  /**
   * @param {import('../../Component.js').default} component  *
   * @param {import('../interfaces.js').INode} owner  *
   * @param {import('./TemplateScope.js').default} template_scope  *
   * @param {import('estree').Node} info  *
   * @param {boolean} [lazy]  undefined
   */
  constructor(component, owner, template_scope, info, lazy) {
    /** @type {'Expression'} */
    __publicField(this, "type", "Expression");
    /** @type {import('../../Component.js').default} */
    __publicField(this, "component");
    /** @type {import('../interfaces.js').INode} */
    __publicField(this, "owner");
    /** @type {import('estree').Node} */
    __publicField(this, "node");
    /** @type {Set<string>} */
    __publicField(this, "references", /* @__PURE__ */ new Set());
    /**
     * Dependencies declared in the script block
     * @type {Set<string>}
     */
    __publicField(this, "dependencies", /* @__PURE__ */ new Set());
    /**
     * Dependencies declared in the HTML-like template section
     * @type {Set<string>}
     */
    __publicField(this, "contextual_dependencies", /* @__PURE__ */ new Set());
    /** @type {import('./TemplateScope.js').default} */
    __publicField(this, "template_scope");
    /** @type {import('../../utils/scope.js').Scope} */
    __publicField(this, "scope");
    /** @type {WeakMap<import('estree').Node, import('../../utils/scope.js').Scope>} */
    __publicField(this, "scope_map");
    /** @type {Array<import('estree').Node | import('estree').Node[]>} */
    __publicField(this, "declarations", []);
    /** @type {boolean} */
    __publicField(this, "uses_context", false);
    /** @type {import('estree').Node} */
    __publicField(this, "manipulated");
    Object.defineProperties(this, {
      component: {
        value: component
      }
    });
    this.node = info;
    this.template_scope = template_scope;
    this.owner = owner;
    const { dependencies, contextual_dependencies, references } = this;
    let { map, scope } = create_scopes(info);
    this.scope = scope;
    this.scope_map = map;
    const expression = this;
    let function_expression;
    walk(info, {
      /**
       * @param {any} node
       * @param {import('estree').Node} parent
       * @param {string} key
       */
      enter(node, parent, key) {
        if (key === "key" && /** @type {import('estree').Property} */
        parent.shorthand)
          return;
        if (node.type === "MetaProperty")
          return this.skip();
        if (map.has(node)) {
          scope = map.get(node);
        }
        if (!function_expression && regex_contains_term_function_expression.test(node.type)) {
          function_expression = node;
        }
        if (is_reference(node, parent)) {
          const { name: name49, nodes } = flatten_reference(node);
          references.add(name49);
          if (scope.has(name49))
            return;
          if (name49[0] === "$") {
            const store_name = name49.slice(1);
            if (template_scope.names.has(store_name) || scope.has(store_name)) {
              return component.error(node, compiler_errors_default.contextual_store);
            }
          }
          if (template_scope.is_let(name49)) {
            if (!lazy) {
              contextual_dependencies.add(name49);
              dependencies.add(name49);
            }
          } else if (template_scope.names.has(name49)) {
            expression.uses_context = true;
            contextual_dependencies.add(name49);
            const owner2 = template_scope.get_owner(name49);
            const is_index = owner2.type === "EachBlock" && owner2.key && name49 === owner2.index;
            if (!lazy || is_index) {
              template_scope.dependencies_for_name.get(name49).forEach((name50) => dependencies.add(name50));
            }
          } else {
            if (!lazy) {
              const variable = component.var_lookup.get(name49);
              if (!variable || !variable.imported || variable.mutated || variable.reassigned) {
                dependencies.add(name49);
              }
            }
            component.add_reference(node, name49);
            component.warn_if_undefined(name49, nodes[0], template_scope, owner);
          }
          this.skip();
        }
        let names;
        let deep = false;
        if (function_expression) {
          if (node.type === "AssignmentExpression") {
            deep = node.left.type === "MemberExpression";
            names = extract_names(deep ? get_object(node.left) : node.left);
          } else if (node.type === "UpdateExpression") {
            deep = node.argument.type === "MemberExpression";
            names = extract_names(get_object(node.argument));
          }
        }
        if (names) {
          names.forEach((name49) => {
            var _a;
            if (template_scope.names.has(name49)) {
              if (template_scope.is_const(name49)) {
                component.error(node, compiler_errors_default.invalid_const_update(name49));
              }
              template_scope.dependencies_for_name.get(name49).forEach((name50) => {
                const variable = component.var_lookup.get(name50);
                if (variable)
                  variable[deep ? "mutated" : "reassigned"] = true;
              });
              const each_block = template_scope.get_owner(name49);
              each_block.has_binding = true;
            } else {
              component.add_reference(node, name49);
              const variable = component.var_lookup.get(name49);
              if (variable) {
                variable[deep ? "mutated" : "reassigned"] = true;
              }
              const declaration = (_a = scope.find_owner(name49)) == null ? void 0 : _a.declarations.get(name49);
              if (declaration) {
                if (
                  /** @type {import('estree').VariableDeclaration} */
                  declaration.kind === "const" && !deep
                ) {
                  component.error(node, {
                    code: "assignment-to-const",
                    message: "You are assigning to a const"
                  });
                }
              } else if (variable && variable.writable === false && !deep) {
                component.error(node, {
                  code: "assignment-to-const",
                  message: "You are assigning to a const"
                });
              }
            }
          });
        }
      },
      /** @type {import('estree-walker').SyncHandler} */
      leave(node) {
        if (map.has(node)) {
          scope = scope.parent;
        }
        if (node === function_expression) {
          function_expression = null;
        }
      }
    });
  }
  dynamic_dependencies() {
    return Array.from(this.dependencies).filter((name49) => {
      if (this.template_scope.is_let(name49))
        return true;
      if (is_reserved_keyword(name49))
        return true;
      const variable = this.component.var_lookup.get(name49);
      return is_dynamic(variable);
    });
  }
  dynamic_contextual_dependencies() {
    return Array.from(this.contextual_dependencies).filter((name49) => {
      return Array.from(this.template_scope.dependencies_for_name.get(name49)).some(
        (variable_name) => {
          const variable = this.component.var_lookup.get(variable_name);
          return is_dynamic(variable);
        }
      );
    });
  }
  // TODO move this into a render-dom wrapper?
  /**
   * @param {import('../../render_dom/Block.js').default} [block]
   * @param {string | void} [ctx]
   */
  manipulate(block, ctx) {
    if (this.manipulated)
      return this.manipulated;
    const { component, declarations, scope_map: map, template_scope, owner } = this;
    let scope = this.scope;
    let function_expression;
    let dependencies;
    let contextual_dependencies;
    const node = walk(this.node, {
      /** @type {import('estree-walker').SyncHandler} */
      enter(node2, parent) {
        if (node2.type === "Property" && node2.shorthand) {
          node2.value = clone2(node2.value);
          node2.shorthand = false;
        }
        if (map.has(node2)) {
          scope = map.get(node2);
        }
        if (node2.type === "Identifier" && is_reference(node2, parent)) {
          const { name: name49 } = flatten_reference(node2);
          if (scope.has(name49))
            return;
          if (function_expression) {
            if (template_scope.names.has(name49)) {
              contextual_dependencies.add(name49);
              template_scope.dependencies_for_name.get(name49).forEach((dependency) => {
                dependencies.add(dependency);
              });
            } else {
              dependencies.add(name49);
              component.add_reference(node2, name49);
            }
          } else if (is_contextual(component, template_scope, name49)) {
            const reference = block.renderer.reference(node2, ctx);
            this.replace(reference);
          }
          this.skip();
        }
        if (!function_expression) {
          if (node2.type === "AssignmentExpression") {
          }
          if (node2.type === "FunctionExpression" || node2.type === "ArrowFunctionExpression") {
            function_expression = node2;
            dependencies = /* @__PURE__ */ new Set();
            contextual_dependencies = /* @__PURE__ */ new Set();
          }
        }
      },
      /** @type {import('estree-walker').SyncHandler} */
      leave(node2, parent) {
        if (map.has(node2))
          scope = scope.parent;
        if (node2 === function_expression) {
          const id2 = component.get_unique_name(sanitize(get_function_name(node2, owner)));
          const declaration = b`const ${id2} = ${node2}`;
          const extract_functions = () => {
            const deps = Array.from(contextual_dependencies);
            const function_expression2 = (
              /** @type {import('estree').FunctionExpression} */
              node2
            );
            const has_args = function_expression2.params.length > 0;
            function_expression2.params = [
              ...deps.map(
                (name49) => (
                  /** @type {import('estree').Identifier} */
                  { type: "Identifier", name: name49 }
                )
              ),
              ...function_expression2.params
            ];
            const context_args = deps.map((name49) => block.renderer.reference(name49, ctx));
            component.partly_hoisted.push(declaration);
            block.renderer.add_to_context(id2.name);
            const callee = block.renderer.reference(id2);
            this.replace(id2);
            const func_declaration = has_args ? b`function ${id2}(...args) {
								return ${callee}(${context_args}, ...args);
							}` : b`function ${id2}() {
								return ${callee}(${context_args});
							}`;
            return { deps, func_declaration };
          };
          if (owner.type === "ConstTag") {
            if (contextual_dependencies.size === 0) {
              let child_scope = scope;
              walk(node2, {
                /** @type {import('estree-walker').SyncHandler} */
                enter(node3, parent2) {
                  if (map.has(node3))
                    child_scope = map.get(node3);
                  if (node3.type === "Identifier" && is_reference(node3, parent2)) {
                    if (child_scope.has(node3.name))
                      return;
                    this.replace(block.renderer.reference(node3, ctx));
                  }
                },
                /** @param {import('estree').Node} node */
                leave(node3) {
                  if (map.has(node3))
                    child_scope = child_scope.parent;
                }
              });
            } else {
              const { func_declaration } = extract_functions();
              this.replace(func_declaration[0]);
            }
          } else if (dependencies.size === 0 && contextual_dependencies.size === 0) {
            component.fully_hoisted.push(declaration);
            this.replace(id2);
            component.add_var(node2, {
              name: id2.name,
              internal: true,
              hoistable: true,
              referenced: true
            });
          } else if (contextual_dependencies.size === 0) {
            component.partly_hoisted.push(declaration);
            block.renderer.add_to_context(id2.name);
            this.replace(block.renderer.reference(id2));
          } else {
            const { deps, func_declaration } = extract_functions();
            if (owner.type === "Attribute" && owner.parent.name === "slot") {
              const dep_scopes = new Set(deps.map((name49) => template_scope.get_owner(name49)));
              let node3 = owner.parent;
              while (node3 && !dep_scopes.has(node3)) {
                node3 = node3.parent;
              }
              const func_expression = func_declaration[0];
              if (node3.type === "SlotTemplate") {
                this.replace(func_expression);
              } else {
                const func_id = component.get_unique_name(id2.name + "_func");
                block.renderer.add_to_context(func_id.name, true);
                walk(func_expression, {
                  /** @param {import('estree').Node} node */
                  enter(node4) {
                    if (node4.type === "Identifier" && node4.name === "#ctx") {
                      node4.name = "child_ctx";
                    }
                  }
                });
                template_scope.get_owner(deps[0]).contexts.push({
                  type: "DestructuredVariable",
                  key: func_id,
                  modifier: () => func_expression,
                  default_modifier: (node4) => node4
                });
                this.replace(block.renderer.reference(func_id));
              }
            } else {
              declarations.push(func_declaration);
            }
          }
          function_expression = null;
          dependencies = null;
          contextual_dependencies = null;
          if (parent && parent.type === "Property") {
            parent.method = false;
          }
        }
        if (node2.type === "AssignmentExpression" || node2.type === "UpdateExpression") {
          const assignee = node2.type === "AssignmentExpression" ? node2.left : node2.argument;
          const object_name = get_object(assignee).name;
          if (scope.has(object_name))
            return;
          const names = new Set(extract_names(
            /** @type {import('estree').Node} */
            assignee
          ));
          const traced = /* @__PURE__ */ new Set();
          names.forEach((name49) => {
            const dependencies2 = template_scope.dependencies_for_name.get(name49);
            if (dependencies2) {
              dependencies2.forEach((name50) => traced.add(name50));
            } else {
              traced.add(name49);
            }
          });
          const context = block.bindings.get(object_name);
          if (context) {
            const { snippet, object, property: property2 } = context;
            const replaced = replace_object(assignee, snippet);
            if (node2.type === "AssignmentExpression") {
              node2.left = replaced;
            } else {
              node2.argument = replaced;
            }
            contextual_dependencies.add(object.name);
            contextual_dependencies.add(property2.name);
          }
          this.replace(invalidate(block.renderer, scope, node2, traced));
        }
      }
    });
    if (declarations.length > 0) {
      block.maintain_context = true;
      declarations.forEach((declaration) => {
        block.chunks.init.push(declaration);
      });
    }
    return this.manipulated = /** @type {import('estree').Node} */
    node;
  }
};
function get_function_name(_node, parent) {
  if (parent.type === "EventHandler") {
    return `${parent.name}_handler`;
  }
  if (parent.type === "Action") {
    return `${parent.name}_function`;
  }
  return "func";
}

// node_modules/svelte/src/compiler/compile/nodes/shared/Context.js
function unpack_destructuring({
  contexts,
  node,
  modifier = (node2) => node2,
  default_modifier = (node2) => node2,
  scope,
  component,
  context_rest_properties,
  in_rest_element = false
}) {
  if (!node)
    return;
  if (node.type === "Identifier") {
    contexts.push({
      type: "DestructuredVariable",
      key: (
        /** @type {import('estree').Identifier} */
        node
      ),
      modifier,
      default_modifier
    });
    if (in_rest_element) {
      context_rest_properties.set(node.name, node);
    }
    component.used_names.add(node.name);
  } else if (node.type === "ArrayPattern") {
    node.elements.forEach((element, i) => {
      if (!element) {
        return;
      } else if (element.type === "RestElement") {
        unpack_destructuring({
          contexts,
          node: element.argument,
          modifier: (node2) => (
            /** @type {import('estree').Node} */
            x`${modifier(node2)}.slice(${i})`
          ),
          default_modifier,
          scope,
          component,
          context_rest_properties,
          in_rest_element: true
        });
      } else if (element.type === "AssignmentPattern") {
        const n2 = contexts.length;
        mark_referenced(element.right, scope, component);
        unpack_destructuring({
          contexts,
          node: element.left,
          modifier: (node2) => x`${modifier(node2)}[${i}]`,
          default_modifier: (node2, to_ctx) => (
            /** @type {import('estree').Node} */
            x`${node2} !== undefined ? ${node2} : ${update_reference(
              contexts,
              n2,
              element.right,
              to_ctx
            )}`
          ),
          scope,
          component,
          context_rest_properties,
          in_rest_element
        });
      } else {
        unpack_destructuring({
          contexts,
          node: element,
          modifier: (node2) => (
            /** @type {import('estree').Node} */
            x`${modifier(node2)}[${i}]`
          ),
          default_modifier,
          scope,
          component,
          context_rest_properties,
          in_rest_element
        });
      }
    });
  } else if (node.type === "ObjectPattern") {
    const used_properties = [];
    node.properties.forEach((property2) => {
      if (property2.type === "RestElement") {
        unpack_destructuring({
          contexts,
          node: property2.argument,
          modifier: (node2) => (
            /** @type {import('estree').Node} */
            x`@object_without_properties(${modifier(node2)}, [${used_properties}])`
          ),
          default_modifier,
          scope,
          component,
          context_rest_properties,
          in_rest_element: true
        });
      } else if (property2.type === "Property") {
        const key = property2.key;
        const value = property2.value;
        let new_modifier;
        if (property2.computed) {
          const property_name = component.get_unique_name("computed_property");
          contexts.push({
            type: "ComputedProperty",
            property_name,
            key
          });
          new_modifier = (node2) => x`${modifier(node2)}[${property_name}]`;
          used_properties.push(x`${property_name}`);
        } else if (key.type === "Identifier") {
          const property_name = key.name;
          new_modifier = (node2) => x`${modifier(node2)}.${property_name}`;
          used_properties.push(x`"${property_name}"`);
        } else if (key.type === "Literal") {
          const property_name = key.value;
          new_modifier = (node2) => x`${modifier(node2)}["${property_name}"]`;
          used_properties.push(x`"${property_name}"`);
        }
        if (value.type === "AssignmentPattern") {
          const n2 = contexts.length;
          mark_referenced(value.right, scope, component);
          unpack_destructuring({
            contexts,
            node: value.left,
            modifier: new_modifier,
            default_modifier: (node2, to_ctx) => (
              /** @type {import('estree').Node} */
              x`${node2} !== undefined ? ${node2} : ${update_reference(
                contexts,
                n2,
                value.right,
                to_ctx
              )}`
            ),
            scope,
            component,
            context_rest_properties,
            in_rest_element
          });
        } else {
          unpack_destructuring({
            contexts,
            node: value,
            modifier: new_modifier,
            default_modifier,
            scope,
            component,
            context_rest_properties,
            in_rest_element
          });
        }
      }
    });
  }
}
function update_reference(contexts, n2, expression, to_ctx) {
  const find_from_context = (node) => {
    for (let i = n2; i < contexts.length; i++) {
      const cur_context = contexts[i];
      if (cur_context.type !== "DestructuredVariable")
        continue;
      const { key } = cur_context;
      if (node.name === key.name) {
        throw new Error(`Cannot access '${node.name}' before initialization`);
      }
    }
    return to_ctx(node.name);
  };
  if (expression.type === "Identifier") {
    return find_from_context(expression);
  }
  expression = /** @type {import('estree').Expression} */
  clone2(expression);
  walk(expression, {
    enter(node, parent) {
      if (is_reference(
        /** @type {import('is-reference').NodeWithPropertyDefinition} */
        node,
        /** @type {import('is-reference').NodeWithPropertyDefinition} */
        parent
      )) {
        this.replace(find_from_context(
          /** @type {import('estree').Identifier} */
          node
        ));
        this.skip();
      }
    }
  });
  return expression;
}
function mark_referenced(node, scope, component) {
  walk(node, {
    enter(node2, parent) {
      if (is_reference(node2, parent)) {
        const { name: name49 } = flatten_reference(node2);
        if (!scope.is_let(name49) && !scope.names.has(name49)) {
          component.add_reference(node2, name49);
        }
      }
    }
  });
}

// node_modules/svelte/src/compiler/compile/nodes/ConstTag.js
var allowed_parents = /* @__PURE__ */ new Set([
  "EachBlock",
  "CatchBlock",
  "ThenBlock",
  "InlineComponent",
  "SlotTemplate",
  "IfBlock",
  "ElseBlock"
]);
var ConstTag = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./interfaces.js').INodeAllowConstTag} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').ConstTag} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {import('./shared/Context.js').Context[]} */
    __publicField(this, "contexts", []);
    /** @type {import('../../interfaces.js').ConstTag} */
    __publicField(this, "node");
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    /** @type {Map<string, import('estree').Node>} */
    __publicField(this, "context_rest_properties", /* @__PURE__ */ new Map());
    /** @type {Set<string>} */
    __publicField(this, "assignees", /* @__PURE__ */ new Set());
    /** @type {Set<string>} */
    __publicField(this, "dependencies", /* @__PURE__ */ new Set());
    if (!allowed_parents.has(parent.type)) {
      component.error(info, compiler_errors_default.invalid_const_placement);
    }
    this.node = info;
    this.scope = scope;
    const { assignees, dependencies } = this;
    extract_identifiers(info.expression.left).forEach(({ name: name49 }) => {
      assignees.add(name49);
      const owner = this.scope.get_owner(name49);
      if (owner === parent) {
        component.error(info, compiler_errors_default.invalid_const_declaration(name49));
      }
    });
    walk(info.expression.right, {
      /**
       * @type {import('estree-walker').SyncHandler}
       */
      enter(node, parent2) {
        if (is_reference(
          /** @type {import('is-reference').NodeWithPropertyDefinition} */
          node,
          /** @type {import('is-reference').NodeWithPropertyDefinition} */
          parent2
        )) {
          const identifier = get_object(node);
          const { name: name49 } = identifier;
          dependencies.add(name49);
        }
      }
    });
  }
  parse_expression() {
    unpack_destructuring({
      contexts: this.contexts,
      node: this.node.expression.left,
      scope: this.scope,
      component: this.component,
      context_rest_properties: this.context_rest_properties
    });
    this.expression = new Expression(this.component, this, this.scope, this.node.expression.right);
    this.contexts.forEach((context) => {
      if (context.type !== "DestructuredVariable")
        return;
      const owner = this.scope.get_owner(context.key.name);
      if (owner && owner.type === "ConstTag" && owner.parent === this.parent) {
        this.component.error(
          this.node,
          compiler_errors_default.invalid_const_declaration(context.key.name)
        );
      }
      this.scope.add(context.key.name, this.expression.dependencies, this);
    });
  }
};

// node_modules/svelte/src/compiler/compile/nodes/PendingBlock.js
var PendingBlock = class extends AbstractBlock {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    this.children = map_children(component, parent, scope, info.children);
    if (!info.skip) {
      this.warn_if_empty_block();
    }
  }
};

// node_modules/svelte/src/compiler/compile/nodes/CatchBlock.js
var CatchBlock = class extends AbstractBlock {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./AwaitBlock.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    /** @type {import('./ConstTag.js').default[]} */
    __publicField(this, "const_tags");
    this.scope = scope.child();
    if (parent.catch_node) {
      parent.catch_contexts.forEach((context) => {
        if (context.type !== "DestructuredVariable")
          return;
        this.scope.add(context.key.name, parent.expression.dependencies, this);
      });
    }
    [this.const_tags, this.children] = get_const_tags(info.children, component, this, parent);
    if (!info.skip) {
      this.warn_if_empty_block();
    }
  }
};

// node_modules/svelte/src/compiler/compile/nodes/AwaitBlock.js
var AwaitBlock = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {import('./shared/Context.js').Context[]} */
    __publicField(this, "then_contexts");
    /** @type {import('./shared/Context.js').Context[]} */
    __publicField(this, "catch_contexts");
    /** @type {import('estree').Node | null} */
    __publicField(this, "then_node");
    /** @type {import('estree').Node | null} */
    __publicField(this, "catch_node");
    /** @type {import('./PendingBlock.js').default} */
    __publicField(this, "pending");
    /** @type {import('./ThenBlock.js').default} */
    __publicField(this, "then");
    /** @type {import('./CatchBlock.js').default} */
    __publicField(this, "catch");
    /** @type {Map<string, import('estree').Node>} */
    __publicField(this, "context_rest_properties", /* @__PURE__ */ new Map());
    this.cannot_use_innerhtml();
    this.not_static_content();
    this.expression = new Expression(component, this, scope, info.expression);
    this.then_node = info.value;
    this.catch_node = info.error;
    if (this.then_node) {
      this.then_contexts = [];
      unpack_destructuring({
        contexts: this.then_contexts,
        node: info.value,
        scope,
        component,
        context_rest_properties: this.context_rest_properties
      });
    }
    if (this.catch_node) {
      this.catch_contexts = [];
      unpack_destructuring({
        contexts: this.catch_contexts,
        node: info.error,
        scope,
        component,
        context_rest_properties: this.context_rest_properties
      });
    }
    this.pending = new PendingBlock(component, this, scope, info.pending);
    this.then = new ThenBlock(component, this, scope, info.then);
    this.catch = new CatchBlock(component, this, scope, info.catch);
  }
};

// node_modules/svelte/src/compiler/compile/nodes/EventHandler.js
var regex_contains_term_function_expression2 = /FunctionExpression/;
var EventHandler = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} template_scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, template_scope, info) {
    super(component, parent, template_scope, info);
    /** @type {string} */
    __publicField(this, "name");
    /** @type {Set<string>} */
    __publicField(this, "modifiers");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {import('estree').Identifier} */
    __publicField(this, "handler_name");
    /** */
    __publicField(this, "uses_context", false);
    /** */
    __publicField(this, "can_make_passive", false);
    this.name = info.name;
    this.modifiers = new Set(info.modifiers);
    if (info.expression) {
      this.expression = new Expression(component, this, template_scope, info.expression);
      this.uses_context = this.expression.uses_context;
      if (regex_contains_term_function_expression2.test(info.expression.type) && info.expression.params.length === 0) {
        this.can_make_passive = true;
      } else if (info.expression.type === "Identifier") {
        let node = component.node_for_declaration.get(info.expression.name);
        if (node) {
          if (node.type === "VariableDeclaration") {
            const declarator = node.declarations.find(
              (d) => (
                /** @type {import('estree').Identifier} */
                d.id.name === info.expression.name
              )
            );
            node = declarator && declarator.init;
          }
          if (node && (node.type === "FunctionExpression" || node.type === "FunctionDeclaration" || node.type === "ArrowFunctionExpression") && node.params.length === 0) {
            this.can_make_passive = true;
          }
        }
      }
    } else {
      this.handler_name = component.get_unique_name(`${sanitize(this.name)}_handler`);
    }
  }
  /** @returns {boolean} */
  get reassigned() {
    if (!this.expression) {
      return false;
    }
    const node = this.expression.node;
    if (regex_contains_term_function_expression2.test(node.type)) {
      return false;
    }
    return this.expression.dynamic_dependencies().length > 0;
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Action.js
var Action = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component  *
   * @param {import('./shared/Node.js').default} parent  *
   * @param {import('./shared/TemplateScope.js').default} scope  *
   * @param {import('../../interfaces.js').Directive} info  undefined
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {string} */
    __publicField(this, "name");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {boolean} */
    __publicField(this, "uses_context");
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "template_scope");
    const object = info.name.split(".")[0];
    component.warn_if_undefined(object, info, scope);
    this.name = info.name;
    component.add_reference(
      /** @type {any} */
      this,
      object
    );
    this.expression = info.expression ? new Expression(component, this, scope, info.expression) : null;
    this.template_scope = scope;
    this.uses_context = this.expression && this.expression.uses_context;
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Body.js
var Body = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').Element} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./EventHandler.js').default[]} */
    __publicField(this, "handlers", []);
    /** @type {import('./Action.js').default[]} */
    __publicField(this, "actions", []);
    info.attributes.forEach((node) => {
      if (node.type === "EventHandler") {
        this.handlers.push(new EventHandler(component, this, scope, node));
      } else if (node.type === "Action") {
        this.actions.push(new Action(component, this, scope, node));
      } else {
      }
    });
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Comment.js
var Comment2 = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {string} */
    __publicField(this, "data");
    /** @type {string[]} */
    __publicField(this, "ignores");
    this.data = info.data;
    this.ignores = info.ignores;
  }
};

// node_modules/svelte/src/compiler/compile/nodes/ElseBlock.js
var ElseBlock = class extends AbstractBlock {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    /** @type {import('./ConstTag.js').default[]} */
    __publicField(this, "const_tags");
    this.scope = scope.child();
    [this.const_tags, this.children] = get_const_tags(info.children, component, this, this);
    this.warn_if_empty_block();
  }
};

// node_modules/svelte/src/compiler/compile/nodes/EachBlock.js
var EachBlock = class extends AbstractBlock {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('estree').Node} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {import('estree').Node} */
    __publicField(this, "context_node");
    /** @type {string} */
    __publicField(this, "iterations");
    /** @type {string} */
    __publicField(this, "index");
    /** @type {string} */
    __publicField(this, "context");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "key");
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    /** @type {import('./shared/Context.js').Context[]} */
    __publicField(this, "contexts");
    /** @type {import('./ConstTag.js').default[]} */
    __publicField(this, "const_tags");
    /** @type {boolean} */
    __publicField(this, "has_animation");
    /** */
    __publicField(this, "has_binding", false);
    /** */
    __publicField(this, "has_index_binding", false);
    /** @type {Map<string, import('estree').Node>} */
    __publicField(this, "context_rest_properties");
    /** @type {import('./ElseBlock.js').default} */
    __publicField(this, "else");
    this.cannot_use_innerhtml();
    this.not_static_content();
    this.expression = new Expression(component, this, scope, info.expression);
    this.context = info.context.name || "each";
    this.context_node = info.context;
    this.index = info.index;
    this.scope = scope.child();
    this.context_rest_properties = /* @__PURE__ */ new Map();
    this.contexts = [];
    unpack_destructuring({
      contexts: this.contexts,
      node: info.context,
      scope,
      component,
      context_rest_properties: this.context_rest_properties
    });
    this.contexts.forEach((context) => {
      if (context.type !== "DestructuredVariable")
        return;
      this.scope.add(context.key.name, this.expression.dependencies, this);
    });
    if (this.index) {
      const dependencies = info.key ? this.expression.dependencies : /* @__PURE__ */ new Set([]);
      this.scope.add(this.index, dependencies, this);
    }
    this.key = info.key ? new Expression(component, this, this.scope, info.key) : null;
    this.has_animation = false;
    [this.const_tags, this.children] = get_const_tags(info.children, component, this, this);
    if (this.has_animation) {
      this.children = this.children.filter(
        (child) => !is_empty_node(child) && !is_comment_node(child)
      );
      if (this.children.length !== 1) {
        const child = this.children.find(
          (child2) => !!/** @type {import('./Element.js').default} */
          child2.animation
        );
        component.error(
          /** @type {import('./Element.js').default} */
          child.animation,
          compiler_errors_default.invalid_animation_sole
        );
        return;
      }
    }
    this.warn_if_empty_block();
    this.else = info.else ? new ElseBlock(component, this, this.scope, info.else) : null;
  }
};
function is_empty_node(node) {
  return node.type === "Text" && node.data.trim() === "";
}
function is_comment_node(node) {
  return node.type === "Comment";
}

// node_modules/svelte/src/compiler/compile/nodes/Binding.js
var read_only_media_attributes = /* @__PURE__ */ new Set([
  "duration",
  "buffered",
  "seekable",
  "played",
  "seeking",
  "ended",
  "videoHeight",
  "videoWidth",
  "naturalWidth",
  "naturalHeight",
  "readyState"
]);
var Binding = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./Element.js').default | import('./InlineComponent.js').default | import('./Window.js').default | import('./Document.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {string} */
    __publicField(this, "name");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {import('estree').Node} */
    __publicField(this, "raw_expression");
    // TODO exists only for bind:this — is there a more elegant solution?
    /** @type {boolean} */
    __publicField(this, "is_contextual");
    /** @type {boolean} */
    __publicField(this, "is_readonly");
    if (info.expression.type !== "Identifier" && info.expression.type !== "MemberExpression") {
      component.error(info, compiler_errors_default.invalid_directive_value);
      return;
    }
    this.name = info.name;
    this.expression = new Expression(component, this, scope, info.expression);
    this.raw_expression = clone2(info.expression);
    const { name: name49 } = get_object(this.expression.node);
    this.is_contextual = Array.from(this.expression.references).some(
      (name50) => scope.names.has(name50)
    );
    if (this.is_contextual)
      this.validate_binding_rest_properties(scope);
    if (scope.is_let(name49)) {
      component.error(this, compiler_errors_default.invalid_binding_let);
      return;
    } else if (scope.names.has(name49)) {
      if (scope.is_await(name49)) {
        component.error(this, compiler_errors_default.invalid_binding_await);
        return;
      }
      if (scope.is_const(name49)) {
        component.error(this, compiler_errors_default.invalid_binding_const);
      }
      scope.dependencies_for_name.get(name49).forEach((name50) => {
        const variable = component.var_lookup.get(name50);
        if (variable) {
          variable.mutated = true;
        }
      });
    } else {
      const variable = component.var_lookup.get(name49);
      if (!variable || variable.global) {
        component.error(
          /** @type {any} */
          this.expression.node,
          compiler_errors_default.binding_undeclared(name49)
        );
        return;
      }
      variable[this.expression.node.type === "MemberExpression" ? "mutated" : "reassigned"] = true;
      if (info.expression.type === "Identifier" && !variable.writable) {
        component.error(
          /** @type {any} */
          this.expression.node,
          compiler_errors_default.invalid_binding_writable
        );
        return;
      }
    }
    const type = parent.get_static_attribute_value("type");
    this.is_readonly = regex_dimensions.test(this.name) || regex_box_size.test(this.name) || is_element(parent) && (parent.is_media_node() && read_only_media_attributes.has(this.name) || parent.name === "input" && type === "file");
  }
  is_readonly_media_attribute() {
    return read_only_media_attributes.has(this.name);
  }
  /** @param {import('./shared/TemplateScope.js').default} scope */
  validate_binding_rest_properties(scope) {
    this.expression.references.forEach((name49) => {
      const each_block = scope.get_owner(name49);
      if (each_block && each_block.type === "EachBlock") {
        const rest_node = each_block.context_rest_properties.get(name49);
        if (rest_node) {
          this.component.warn(
            /** @type {any} */
            rest_node,
            compiler_warnings_default.invalid_rest_eachblock_binding(name49)
          );
        }
      }
    });
  }
};
function is_element(node) {
  return !!/** @type {any} */
  node.is_media_node;
}

// node_modules/svelte/src/compiler/compile/nodes/Document.js
var valid_bindings = ["fullscreenElement", "visibilityState"];
var Document = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').Element} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./EventHandler.js').default[]} */
    __publicField(this, "handlers", []);
    /** @type {import('./Binding.js').default[]} */
    __publicField(this, "bindings", []);
    /** @type {import('./Action.js').default[]} */
    __publicField(this, "actions", []);
    info.attributes.forEach((node) => {
      if (node.type === "EventHandler") {
        this.handlers.push(new EventHandler(component, this, scope, node));
      } else if (node.type === "Binding") {
        if (!~valid_bindings.indexOf(node.name)) {
          const match = fuzzymatch(node.name, valid_bindings);
          if (match) {
            return component.error(
              node,
              compiler_errors_default.invalid_binding_on(
                node.name,
                "<svelte:document>",
                ` (did you mean '${match}'?)`
              )
            );
          } else {
            return component.error(
              node,
              compiler_errors_default.invalid_binding_on(
                node.name,
                "<svelte:document>",
                ` — valid bindings are ${list(valid_bindings)}`
              )
            );
          }
        }
        this.bindings.push(new Binding(component, this, scope, node));
      } else if (node.type === "Action") {
        this.actions.push(new Action(component, this, scope, node));
      } else {
      }
    });
    this.validate();
  }
  /** @private */
  validate() {
    const handlers_map = /* @__PURE__ */ new Set();
    this.handlers.forEach((handler) => handlers_map.add(handler.name));
    if (handlers_map.has("mouseenter") || handlers_map.has("mouseleave")) {
      this.component.warn(this, compiler_warnings_default.avoid_mouse_events_on_document);
    }
  }
};

// node_modules/svelte/src/compiler/compile/utils/stringify.js
function string_literal(data2) {
  return {
    type: "Literal",
    value: data2
  };
}
var escaped = {
  '"': "&quot;",
  "'": "&#39;",
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;"
};
var regex_html_characters_to_escape = /["'&<>]/g;
function escape_html(html2) {
  return String(html2).replace(regex_html_characters_to_escape, (match) => escaped[match]);
}
var regex_template_characters_to_escape = /(\${|`|\\)/g;
function escape_template(str) {
  return str.replace(regex_template_characters_to_escape, "\\$1");
}

// node_modules/svelte/src/compiler/compile/utils/add_to_set.js
function add_to_set(a, b2) {
  b2.forEach((item) => {
    a.add(item);
  });
}

// node_modules/svelte/src/compiler/compile/nodes/Attribute.js
var Attribute = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    /** @type {string} */
    __publicField(this, "name");
    /** @type {boolean} */
    __publicField(this, "is_spread");
    /** @type {boolean} */
    __publicField(this, "is_true");
    /** @type {boolean} */
    __publicField(this, "is_static");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {Array<import('./Text.js').default | import('./shared/Expression.js').default>} */
    __publicField(this, "chunks");
    /** @type {Set<string>} */
    __publicField(this, "dependencies");
    this.scope = scope;
    if (info.type === "Spread") {
      this.name = null;
      this.is_spread = true;
      this.is_true = false;
      this.expression = new Expression(component, this, scope, info.expression);
      this.dependencies = this.expression.dependencies;
      this.chunks = null;
      this.is_static = false;
    } else {
      this.name = info.name;
      this.is_true = info.value === true;
      this.is_static = true;
      this.dependencies = /* @__PURE__ */ new Set();
      this.chunks = this.is_true ? [] : info.value.map((node) => {
        if (node.type === "Text")
          return node;
        this.is_static = false;
        const expression = new Expression(component, this, scope, node.expression);
        add_to_set(this.dependencies, expression.dependencies);
        return expression;
      });
    }
    if (this.dependencies.size > 0) {
      parent.cannot_use_innerhtml();
      parent.not_static_content();
    }
    if (this.name && this.name.includes(":") && !this.name.startsWith("xmlns:") && !this.name.startsWith("xlink:") && !this.name.startsWith("xml:")) {
      component.warn(this, compiler_warnings_default.illegal_attribute_character);
    }
  }
  get_dependencies() {
    if (this.is_spread)
      return this.expression.dynamic_dependencies();
    const dependencies = /* @__PURE__ */ new Set();
    this.chunks.forEach((chunk) => {
      if (chunk.type === "Expression") {
        add_to_set(dependencies, chunk.dynamic_dependencies());
      }
    });
    return Array.from(dependencies);
  }
  /** @param {any} block */
  get_value(block) {
    if (this.is_true)
      return x`true`;
    if (this.chunks.length === 0)
      return x`""`;
    if (this.chunks.length === 1) {
      return this.chunks[0].type === "Text" ? string_literal(
        /** @type {import('./Text.js').default} */
        this.chunks[0].data
      ) : (
        /** @type {import('./shared/Expression.js').default} */
        this.chunks[0].manipulate(
          block
        )
      );
    }
    let expression = this.chunks.map(
      /** @param {any} chunk */
      (chunk) => chunk.type === "Text" ? string_literal(chunk.data) : chunk.manipulate(block)
    ).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
    if (this.chunks[0].type !== "Text") {
      expression = x`"" + ${expression}`;
    }
    return expression;
  }
  get_static_value() {
    if (!this.is_static)
      return null;
    return this.is_true ? true : this.chunks[0] ? (
      // method should be called only when `is_static = true`
      /** @type {import('./Text.js').default} */
      this.chunks[0].data
    ) : "";
  }
  should_cache() {
    return this.is_static ? false : this.chunks.length === 1 ? (
      // @ts-ignore todo: probably error
      this.chunks[0].node.type !== "Identifier" || this.scope.names.has(this.chunks[0].node.name)
    ) : true;
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Transition.js
var Transition = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./Element.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {string} */
    __publicField(this, "name");
    /** @type {string} */
    __publicField(this, "directive");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {boolean} */
    __publicField(this, "is_local");
    component.warn_if_undefined(info.name, info, scope);
    this.name = info.name;
    component.add_reference(
      /** @type {any} */
      this,
      info.name.split(".")[0]
    );
    this.directive = info.intro && info.outro ? "transition" : info.intro ? "in" : "out";
    this.is_local = !info.modifiers.includes("global");
    if (info.intro && parent.intro || info.outro && parent.outro) {
      const parent_transition = parent.intro || parent.outro;
      component.error(
        info,
        compiler_errors_default.duplicate_transition(this.directive, parent_transition.directive)
      );
      return;
    }
    this.expression = info.expression ? new Expression(component, this, scope, info.expression) : null;
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Animation.js
var Animation = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component  *
   * @param {import('./Element.js').default} parent  *
   * @param {import('./shared/TemplateScope.js').default} scope  *
   * @param {import('../../interfaces.js').TemplateNode} info  undefined
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {string} */
    __publicField(this, "name");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    component.warn_if_undefined(info.name, info, scope);
    this.name = info.name;
    component.add_reference(
      /** @type {any} */
      this,
      info.name.split(".")[0]
    );
    if (parent.animation) {
      component.error(this, compiler_errors_default.duplicate_animation);
      return;
    }
    const block = parent.parent;
    if (!block || block.type !== "EachBlock") {
      component.error(this, compiler_errors_default.invalid_animation_immediate);
      return;
    }
    if (!block.key) {
      component.error(this, compiler_errors_default.invalid_animation_key);
      return;
    }
    block.has_animation = true;
    this.expression = info.expression ? new Expression(component, this, scope, info.expression, true) : null;
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Class.js
var Class = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {string} */
    __publicField(this, "name");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    this.name = info.name;
    this.expression = info.expression ? new Expression(component, this, scope, info.expression) : null;
  }
};

// node_modules/svelte/src/compiler/compile/utils/nodes_to_template_literal.js
function nodes_to_template_literal(value) {
  const literal2 = {
    type: "TemplateLiteral",
    expressions: [],
    quasis: []
  };
  let quasi = {
    type: "TemplateElement",
    value: { raw: "", cooked: null },
    tail: false
  };
  value.forEach((node) => {
    if (node.type === "Text") {
      quasi.value.raw += node.raw;
    } else if (node.type === "MustacheTag") {
      literal2.quasis.push(quasi);
      literal2.expressions.push(
        /** @type {any} */
        node.expression
      );
      quasi = {
        type: "TemplateElement",
        value: { raw: "", cooked: null },
        tail: false
      };
    }
  });
  quasi.tail = true;
  literal2.quasis.push(quasi);
  return literal2;
}

// node_modules/svelte/src/compiler/compile/nodes/StyleDirective.js
var valid_modifiers = /* @__PURE__ */ new Set(["important"]);
var StyleDirective = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {string} */
    __publicField(this, "name");
    /** @type {Set<string>} */
    __publicField(this, "modifiers");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {boolean} */
    __publicField(this, "should_cache");
    this.name = info.name;
    this.modifiers = new Set(info.modifiers);
    for (const modifier of this.modifiers) {
      if (!valid_modifiers.has(modifier)) {
        component.error(
          this,
          compiler_errors_default.invalid_style_directive_modifier(list([...valid_modifiers]))
        );
      }
    }
    if (info.value === true || info.value.length === 1 && info.value[0].type === "MustacheTag") {
      const identifier = info.value === true ? {
        type: "Identifier",
        start: info.end - info.name.length,
        end: info.end,
        name: info.name
      } : info.value[0].expression;
      this.expression = new Expression(component, this, scope, identifier);
      this.should_cache = false;
    } else {
      const raw_expression = nodes_to_template_literal(info.value);
      this.expression = new Expression(component, this, scope, raw_expression);
      this.should_cache = raw_expression.expressions.length > 0;
    }
  }
  get important() {
    return this.modifiers.has("important");
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Text.js
var elements_without_text = /* @__PURE__ */ new Set(["audio", "datalist", "dl", "optgroup", "select", "video"]);
var regex_ends_with_svg = /svg$/;
var regex_non_whitespace_characters2 = /[\S\u00A0]/;
var Text = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./interfaces.js').INode} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {string} */
    __publicField(this, "data");
    /** @type {boolean} */
    __publicField(this, "synthetic");
    this.data = info.data;
    this.synthetic = info.synthetic || false;
  }
  should_skip() {
    if (regex_non_whitespace_character.test(this.data))
      return false;
    const parent_element = this.find_nearest(/(?:Element|InlineComponent|SlotTemplate|Head)/);
    if (!parent_element)
      return false;
    if (parent_element.type === "Head")
      return true;
    if (parent_element.type === "InlineComponent")
      return parent_element.children.length === 1 && this === parent_element.children[0];
    if (regex_ends_with_svg.test(parent_element.namespace)) {
      if (this.prev && this.prev.type === "Element" && this.prev.name === "tspan")
        return false;
    }
    return parent_element.namespace || elements_without_text.has(parent_element.name);
  }
  /** @returns {boolean} */
  keep_space() {
    if (this.component.component_options.preserveWhitespace)
      return true;
    return this.within_pre();
  }
  /** @returns {boolean} */
  within_pre() {
    let node = this.parent;
    while (node) {
      if (node.type === "Element" && node.name === "pre") {
        return true;
      }
      node = node.parent;
    }
    return false;
  }
  /** @returns {boolean} */
  use_space() {
    if (this.component.compile_options.preserveWhitespace)
      return false;
    if (regex_non_whitespace_characters2.test(this.data))
      return false;
    return !this.within_pre();
  }
};

// node_modules/svelte/src/compiler/utils/namespaces.js
var foreign = "https://svelte.dev/docs/special-elements#svelte-options";
var html = "http://www.w3.org/1999/xhtml";
var mathml = "http://www.w3.org/1998/Math/MathML";
var svg = "http://www.w3.org/2000/svg";
var xlink = "http://www.w3.org/1999/xlink";
var xml = "http://www.w3.org/XML/1998/namespace";
var xmlns = "http://www.w3.org/2000/xmlns";
var valid_namespaces = [
  "foreign",
  "html",
  "mathml",
  "svg",
  "xlink",
  "xml",
  "xmlns",
  foreign,
  html,
  mathml,
  svg,
  xlink,
  xml,
  xmlns
];
var namespaces = (
  /** @type {const} */
  { foreign, html, mathml, svg, xlink, xml, xmlns }
);

// node_modules/svelte/src/compiler/compile/utils/contenteditable.js
var CONTENTEDITABLE_BINDINGS = ["textContent", "innerHTML", "innerText"];
function is_input_or_textarea(node) {
  return node.name === "textarea" || node.name === "input";
}
function is_attr_contenteditable(attribute) {
  return attribute.name === "contenteditable";
}
function has_contenteditable_attr(node) {
  return node.attributes.some(is_attr_contenteditable);
}
function is_contenteditable(node) {
  return !is_input_or_textarea(node) && has_contenteditable_attr(node);
}
function is_name_contenteditable(name49) {
  return CONTENTEDITABLE_BINDINGS.includes(name49);
}
function get_contenteditable_attr(node) {
  return node.attributes.find(is_attr_contenteditable);
}

// node_modules/svelte/src/compiler/compile/utils/hash.js
var regex_return_characters = /\r/g;
function hash(str) {
  str = str.replace(regex_return_characters, "");
  let hash2 = 5381;
  let i = str.length;
  while (i--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return (hash2 >>> 0).toString(36);
}

// node_modules/svelte/src/compiler/compile/nodes/Let.js
var applicable = /* @__PURE__ */ new Set(["Identifier", "ObjectExpression", "ArrayExpression", "Property"]);
var Let = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('estree').Identifier} */
    __publicField(this, "name");
    /** @type {import('estree').Identifier} */
    __publicField(this, "value");
    /** @type {string[]} */
    __publicField(this, "names", []);
    this.name = { type: "Identifier", name: info.name };
    const { names } = this;
    if (info.expression) {
      this.value = info.expression;
      walk(info.expression, {
        /** @param {import('estree').Identifier | import('estree').BasePattern} node */
        enter(node) {
          if (!applicable.has(node.type)) {
            return component.error(
              /** @type {any} */
              node,
              compiler_errors_default.invalid_let
            );
          }
          if (node.type === "Identifier") {
            names.push(
              /** @type {import('estree').Identifier} */
              node.name
            );
          }
          if (node.type === "ArrayExpression") {
            node.type = "ArrayPattern";
          }
          if (node.type === "ObjectExpression") {
            node.type = "ObjectPattern";
          }
        }
      });
    } else {
      names.push(this.name.name);
    }
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Element.js
var import_aria_query2 = __toESM(require_lib(), 1);

// node_modules/svelte/src/compiler/compile/utils/a11y.js
var import_aria_query = __toESM(require_lib(), 1);
var import_axobject_query = __toESM(require_lib2(), 1);
var aria_roles = import_aria_query.roles.keys();
var abstract_roles = new Set(aria_roles.filter((role) => import_aria_query.roles.get(role).abstract));
var non_abstract_roles = aria_roles.filter((name49) => !abstract_roles.has(name49));
var non_interactive_roles = new Set(
  non_abstract_roles.filter((name49) => {
    const role = import_aria_query.roles.get(name49);
    return (
      // 'toolbar' does not descend from widget, but it does support
      // aria-activedescendant, thus in practice we treat it as a widget.
      // focusable tabpanel elements are recommended if any panels in a set contain content where the first element in the panel is not focusable.
      // 'generic' is meant to have no semantic meaning.
      // 'cell' is treated as CellRole by the AXObject which is interactive, so we treat 'cell' it as interactive as well.
      !["toolbar", "tabpanel", "generic", "cell"].includes(name49) && !role.superClass.some((classes) => classes.includes("widget"))
    );
  }).concat(
    // The `progressbar` is descended from `widget`, but in practice, its
    // value is always `readonly`, so we treat it as a non-interactive role.
    "progressbar"
  )
);
var interactive_roles = new Set(
  non_abstract_roles.filter(
    (name49) => !non_interactive_roles.has(name49) && // 'generic' is meant to have no semantic meaning.
    name49 !== "generic"
  )
);
function is_non_interactive_roles(role) {
  return non_interactive_roles.has(role);
}
function is_interactive_roles(role) {
  return interactive_roles.has(role);
}
function is_abstract_role(role) {
  return abstract_roles.has(role);
}
var presentation_roles = /* @__PURE__ */ new Set(["presentation", "none"]);
function is_presentation_role(role) {
  return presentation_roles.has(role);
}
function is_hidden_from_screen_reader(tag_name, attribute_map) {
  var _a;
  if (tag_name === "input") {
    const type = (_a = attribute_map.get("type")) == null ? void 0 : _a.get_static_value();
    if (type && type === "hidden") {
      return true;
    }
  }
  const aria_hidden = attribute_map.get("aria-hidden");
  if (!aria_hidden)
    return false;
  if (!aria_hidden.is_static)
    return true;
  const aria_hidden_value = aria_hidden.get_static_value();
  return aria_hidden_value === true || aria_hidden_value === "true";
}
function has_disabled_attribute(attribute_map) {
  const disabled_attr = attribute_map.get("disabled");
  const disabled_attr_value = disabled_attr && disabled_attr.get_static_value();
  if (disabled_attr_value) {
    return true;
  }
  const aria_disabled_attr = attribute_map.get("aria-disabled");
  if (aria_disabled_attr) {
    const aria_disabled_attr_value = aria_disabled_attr.get_static_value();
    if (aria_disabled_attr_value === true) {
      return true;
    }
  }
  return false;
}
var non_interactive_element_role_schemas = [];
import_aria_query.elementRoles.entries().forEach(([schema, roles2]) => {
  if ([...roles2].every((role) => role !== "generic" && non_interactive_roles.has(role))) {
    non_interactive_element_role_schemas.push(schema);
  }
});
var interactive_element_role_schemas = [];
import_aria_query.elementRoles.entries().forEach(([schema, roles2]) => {
  if ([...roles2].every((role) => interactive_roles.has(role))) {
    interactive_element_role_schemas.push(schema);
  }
});
var interactive_ax_objects = new Set(
  [...import_axobject_query.AXObjects.keys()].filter((name49) => import_axobject_query.AXObjects.get(name49).type === "widget")
);
var non_interactive_ax_objects = new Set(
  [...import_axobject_query.AXObjects.keys()].filter(
    (name49) => ["windows", "structure"].includes(import_axobject_query.AXObjects.get(name49).type)
  )
);
var interactive_element_ax_object_schemas = [];
import_axobject_query.elementAXObjects.entries().forEach(([schema, ax_object]) => {
  if ([...ax_object].every((role) => interactive_ax_objects.has(role))) {
    interactive_element_ax_object_schemas.push(schema);
  }
});
var non_interactive_element_ax_object_schemas = [];
import_axobject_query.elementAXObjects.entries().forEach(([schema, ax_object]) => {
  if ([...ax_object].every((role) => non_interactive_ax_objects.has(role))) {
    non_interactive_element_ax_object_schemas.push(schema);
  }
});
function match_schema(schema, tag_name, attribute_map) {
  if (schema.name !== tag_name)
    return false;
  if (!schema.attributes)
    return true;
  return schema.attributes.every((schema_attribute) => {
    const attribute = attribute_map.get(schema_attribute.name);
    if (!attribute)
      return false;
    if (schema_attribute.value && schema_attribute.value !== attribute.get_static_value()) {
      return false;
    }
    return true;
  });
}
var ElementInteractivity = (
  /** @type {const} */
  {
    Interactive: "interactive",
    NonInteractive: "non-interactive",
    Static: "static"
  }
);
function element_interactivity(tag_name, attribute_map) {
  if (interactive_element_role_schemas.some((schema) => match_schema(schema, tag_name, attribute_map))) {
    return ElementInteractivity.Interactive;
  }
  if (tag_name !== "header" && non_interactive_element_role_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.NonInteractive;
  }
  if (interactive_element_ax_object_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.Interactive;
  }
  if (non_interactive_element_ax_object_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.NonInteractive;
  }
  return ElementInteractivity.Static;
}
function is_interactive_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.Interactive;
}
function is_non_interactive_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.NonInteractive;
}
function is_static_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.Static;
}
function is_semantic_role_element(role, tag_name, attribute_map) {
  for (const [schema, ax_object] of import_axobject_query.elementAXObjects.entries()) {
    if (schema.name === tag_name && (!schema.attributes || schema.attributes.every(
      (attr) => attribute_map.has(attr.name) && attribute_map.get(attr.name).get_static_value() === attr.value
    ))) {
      for (const name49 of ax_object) {
        const roles2 = import_axobject_query.AXObjectRoles.get(name49);
        if (roles2) {
          for (const { name: name50 } of roles2) {
            if (name50 === role) {
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}
var address_type_tokens = /* @__PURE__ */ new Set(["shipping", "billing"]);
var autofill_field_name_tokens = /* @__PURE__ */ new Set([
  "",
  "on",
  "off",
  "name",
  "honorific-prefix",
  "given-name",
  "additional-name",
  "family-name",
  "honorific-suffix",
  "nickname",
  "username",
  "new-password",
  "current-password",
  "one-time-code",
  "organization-title",
  "organization",
  "street-address",
  "address-line1",
  "address-line2",
  "address-line3",
  "address-level4",
  "address-level3",
  "address-level2",
  "address-level1",
  "country",
  "country-name",
  "postal-code",
  "cc-name",
  "cc-given-name",
  "cc-additional-name",
  "cc-family-name",
  "cc-number",
  "cc-exp",
  "cc-exp-month",
  "cc-exp-year",
  "cc-csc",
  "cc-type",
  "transaction-currency",
  "transaction-amount",
  "language",
  "bday",
  "bday-day",
  "bday-month",
  "bday-year",
  "sex",
  "url",
  "photo"
]);
var contact_type_tokens = /* @__PURE__ */ new Set(["home", "work", "mobile", "fax", "pager"]);
var autofill_contact_field_name_tokens = /* @__PURE__ */ new Set([
  "tel",
  "tel-country-code",
  "tel-national",
  "tel-area-code",
  "tel-local",
  "tel-local-prefix",
  "tel-local-suffix",
  "tel-extension",
  "email",
  "impp"
]);
function is_valid_autocomplete(autocomplete) {
  if (autocomplete === true) {
    return false;
  } else if (!autocomplete) {
    return true;
  }
  const tokens = autocomplete.trim().toLowerCase().split(regex_whitespaces);
  if (typeof tokens[0] === "string" && tokens[0].startsWith("section-")) {
    tokens.shift();
  }
  if (address_type_tokens.has(tokens[0])) {
    tokens.shift();
  }
  if (autofill_field_name_tokens.has(tokens[0])) {
    tokens.shift();
  } else {
    if (contact_type_tokens.has(tokens[0])) {
      tokens.shift();
    }
    if (autofill_contact_field_name_tokens.has(tokens[0])) {
      tokens.shift();
    } else {
      return false;
    }
  }
  if (tokens[0] === "webauthn") {
    tokens.shift();
  }
  return tokens.length === 0;
}

// node_modules/svelte/src/compiler/compile/nodes/Element.js
var aria_attributes = "activedescendant atomic autocomplete busy checked colcount colindex colspan controls current describedby description details disabled dropeffect errormessage expanded flowto grabbed haspopup hidden invalid keyshortcuts label labelledby level live modal multiline multiselectable orientation owns placeholder posinset pressed readonly relevant required roledescription rowcount rowindex rowspan selected setsize sort valuemax valuemin valuenow valuetext".split(
  " "
);
var aria_attribute_set = new Set(aria_attributes);
var aria_roles2 = import_aria_query2.roles.keys();
var aria_role_set = new Set(aria_roles2);
var a11y_required_attributes = {
  a: ["href"],
  area: ["alt", "aria-label", "aria-labelledby"],
  // html-has-lang
  html: ["lang"],
  // iframe-has-title
  iframe: ["title"],
  img: ["alt"],
  object: ["title", "aria-label", "aria-labelledby"]
};
var a11y_distracting_elements = /* @__PURE__ */ new Set(["blink", "marquee"]);
var a11y_required_content = /* @__PURE__ */ new Set([
  // anchor-has-content
  "a",
  // heading-has-content
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6"
]);
var a11y_labelable = /* @__PURE__ */ new Set([
  "button",
  "input",
  "keygen",
  "meter",
  "output",
  "progress",
  "select",
  "textarea"
]);
var a11y_interactive_handlers = /* @__PURE__ */ new Set([
  // Keyboard events
  "keypress",
  "keydown",
  "keyup",
  // Click events
  "click",
  "contextmenu",
  "dblclick",
  "drag",
  "dragend",
  "dragenter",
  "dragexit",
  "dragleave",
  "dragover",
  "dragstart",
  "drop",
  "mousedown",
  "mouseenter",
  "mouseleave",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup"
]);
var a11y_recommended_interactive_handlers = /* @__PURE__ */ new Set([
  "click",
  "mousedown",
  "mouseup",
  "keypress",
  "keydown",
  "keyup"
]);
var a11y_nested_implicit_semantics = /* @__PURE__ */ new Map([
  ["header", "banner"],
  ["footer", "contentinfo"]
]);
var a11y_implicit_semantics = /* @__PURE__ */ new Map([
  ["a", "link"],
  ["area", "link"],
  ["article", "article"],
  ["aside", "complementary"],
  ["body", "document"],
  ["button", "button"],
  ["datalist", "listbox"],
  ["dd", "definition"],
  ["dfn", "term"],
  ["dialog", "dialog"],
  ["details", "group"],
  ["dt", "term"],
  ["fieldset", "group"],
  ["figure", "figure"],
  ["form", "form"],
  ["h1", "heading"],
  ["h2", "heading"],
  ["h3", "heading"],
  ["h4", "heading"],
  ["h5", "heading"],
  ["h6", "heading"],
  ["hr", "separator"],
  ["img", "img"],
  ["li", "listitem"],
  ["link", "link"],
  ["main", "main"],
  ["menu", "list"],
  ["meter", "progressbar"],
  ["nav", "navigation"],
  ["ol", "list"],
  ["option", "option"],
  ["optgroup", "group"],
  ["output", "status"],
  ["progress", "progressbar"],
  ["section", "region"],
  ["summary", "button"],
  ["table", "table"],
  ["tbody", "rowgroup"],
  ["textarea", "textbox"],
  ["tfoot", "rowgroup"],
  ["thead", "rowgroup"],
  ["tr", "row"],
  ["ul", "list"]
]);
var menuitem_type_to_implicit_role = /* @__PURE__ */ new Map([
  ["command", "menuitem"],
  ["checkbox", "menuitemcheckbox"],
  ["radio", "menuitemradio"]
]);
var input_type_to_implicit_role = /* @__PURE__ */ new Map([
  ["button", "button"],
  ["image", "button"],
  ["reset", "button"],
  ["submit", "button"],
  ["checkbox", "checkbox"],
  ["radio", "radio"],
  ["range", "slider"],
  ["number", "spinbutton"],
  ["email", "textbox"],
  ["search", "searchbox"],
  ["tel", "textbox"],
  ["text", "textbox"],
  ["url", "textbox"]
]);
var a11y_non_interactive_element_to_interactive_role_exceptions = {
  ul: ["listbox", "menu", "menubar", "radiogroup", "tablist", "tree", "treegrid"],
  ol: ["listbox", "menu", "menubar", "radiogroup", "tablist", "tree", "treegrid"],
  li: ["menuitem", "option", "row", "tab", "treeitem"],
  table: ["grid"],
  td: ["gridcell"],
  fieldset: ["radiogroup", "presentation"]
};
var combobox_if_list = /* @__PURE__ */ new Set(["email", "search", "tel", "text", "url"]);
function input_implicit_role(attribute_map) {
  const type_attribute = attribute_map.get("type");
  if (!type_attribute || !type_attribute.is_static)
    return;
  const type = (
    /** @type {string} */
    type_attribute.get_static_value()
  );
  const list_attribute_exists = attribute_map.has("list");
  if (list_attribute_exists && combobox_if_list.has(type)) {
    return "combobox";
  }
  return input_type_to_implicit_role.get(type);
}
function menuitem_implicit_role(attribute_map) {
  const type_attribute = attribute_map.get("type");
  if (!type_attribute || !type_attribute.is_static)
    return;
  const type = (
    /** @type {string} */
    type_attribute.get_static_value()
  );
  return menuitem_type_to_implicit_role.get(type);
}
function get_implicit_role(name49, attribute_map) {
  if (name49 === "menuitem") {
    return menuitem_implicit_role(attribute_map);
  } else if (name49 === "input") {
    return input_implicit_role(attribute_map);
  } else {
    return a11y_implicit_semantics.get(name49);
  }
}
var invisible_elements = /* @__PURE__ */ new Set(["meta", "html", "script", "style"]);
var valid_modifiers2 = /* @__PURE__ */ new Set([
  "preventDefault",
  "stopPropagation",
  "stopImmediatePropagation",
  "capture",
  "once",
  "passive",
  "nonpassive",
  "self",
  "trusted"
]);
var passive_events = /* @__PURE__ */ new Set(["wheel", "touchstart", "touchmove", "touchend", "touchcancel"]);
var react_attributes = /* @__PURE__ */ new Map([
  ["className", "class"],
  ["htmlFor", "for"]
]);
var attributes_to_compact_whitespace = ["class", "style"];
function is_parent(parent, elements) {
  let check = false;
  while (parent) {
    const parent_name = (
      /** @type {Element} */
      parent.name
    );
    if (elements.includes(parent_name)) {
      check = true;
      break;
    }
    if (parent.type === "Element") {
      break;
    }
    parent = parent.parent;
  }
  return check;
}
function get_namespace(parent, element, explicit_namespace) {
  const parent_element = parent.find_nearest(/^Element/);
  if (!parent_element) {
    return explicit_namespace || (is_svg(element.name) ? namespaces.svg : null);
  }
  if (parent_element.namespace !== namespaces.foreign) {
    if (is_svg(element.name.toLowerCase()))
      return namespaces.svg;
    if (parent_element.name.toLowerCase() === "foreignobject")
      return null;
  }
  return parent_element.namespace;
}
function is_valid_aria_attribute_value(schema, value) {
  switch (schema.type) {
    case "boolean":
      return typeof value === "boolean";
    case "string":
    case "id":
      return typeof value === "string";
    case "tristate":
      return typeof value === "boolean" || value === "mixed";
    case "integer":
    case "number":
      return typeof value !== "boolean" && isNaN(Number(value)) === false;
    case "token":
      return (schema.values || []).indexOf(typeof value === "string" ? value.toLowerCase() : value) > -1;
    case "idlist":
      return typeof value === "string" && value.split(regex_any_repeated_whitespaces).every((id2) => typeof id2 === "string");
    case "tokenlist":
      return typeof value === "string" && value.split(regex_any_repeated_whitespaces).every((token) => (schema.values || []).indexOf(token.toLowerCase()) > -1);
    default:
      return false;
  }
}
var regex_any_repeated_whitespaces = /[\s]+/g;
var regex_heading_tags = /^h[1-6]$/;
var regex_illegal_attribute_character = /(^[0-9-.])|[\^$@%&#?!|()[\]{}^*+~;]/;
var Element = class _Element extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {any} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {string} */
    __publicField(this, "name");
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    /** @type {import('./Action.js').default[]} */
    __publicField(this, "actions", []);
    /** @type {import('./Binding.js').default[]} */
    __publicField(this, "bindings", []);
    /** @type {import('./Class.js').default[]} */
    __publicField(this, "classes", []);
    /** @type {import('./StyleDirective.js').default[]} */
    __publicField(this, "styles", []);
    /** @type {import('./EventHandler.js').default[]} */
    __publicField(this, "handlers", []);
    /** @type {import('./Let.js').default[]} */
    __publicField(this, "lets", []);
    /** @type {import('./Transition.js').default} */
    __publicField(this, "intro", null);
    /** @type {import('./Transition.js').default} */
    __publicField(this, "outro", null);
    /** @type {import('./Animation.js').default} */
    __publicField(this, "animation", null);
    /** @type {import('./interfaces.js').INode[]} */
    __publicField(this, "children");
    /** @type {string} */
    __publicField(this, "namespace");
    /** @type {boolean} */
    __publicField(this, "needs_manual_style_scoping");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "tag_expr");
    /** @type {boolean} */
    __publicField(this, "contains_a11y_label");
    this.name = info.name;
    if (info.name === "svelte:element") {
      if (typeof info.tag !== "string") {
        this.tag_expr = new Expression(component, this, scope, info.tag);
      } else {
        this.tag_expr = new Expression(
          component,
          this,
          scope,
          /** @type {import('estree').Literal} */
          string_literal(info.tag)
        );
        this.name = info.tag;
      }
    } else {
      this.tag_expr = new Expression(
        component,
        this,
        scope,
        /** @type {import('estree').Literal} */
        string_literal(this.name)
      );
    }
    this.namespace = get_namespace(
      /** @type {Element} */
      parent,
      this,
      component.namespace
    );
    if (this.namespace !== namespaces.foreign) {
      if (this.name === "pre" || this.name === "textarea") {
        const first = info.children[0];
        if (first && first.type === "Text") {
          first.data = first.data.replace(regex_starts_with_newline, "");
        }
      }
      if (this.name === "textarea") {
        if (info.children.length > 0) {
          const value_attribute = get_value_attribute(info.attributes);
          if (value_attribute) {
            component.error(value_attribute, compiler_errors_default.textarea_duplicate_value);
            return;
          }
          info.attributes.push({
            type: "Attribute",
            name: "value",
            value: info.children
          });
          info.children = [];
        }
      }
      if (this.name === "option") {
        const value_attribute = get_value_attribute(info.attributes);
        if (!value_attribute) {
          info.attributes.push({
            type: "Attribute",
            name: "value",
            value: info.children,
            synthetic: true
          });
        }
      }
    }
    const has_let = info.attributes.some((node) => node.type === "Let");
    if (has_let) {
      scope = scope.child();
    }
    const order = ["Binding"];
    info.attributes.sort((a, b2) => order.indexOf(a.type) - order.indexOf(b2.type));
    info.attributes.forEach((node) => {
      switch (node.type) {
        case "Action":
          this.actions.push(new Action(component, this, scope, node));
          break;
        case "Attribute":
        case "Spread":
          if (node.name === "xmlns")
            this.namespace = node.value[0].data;
          this.attributes.push(new Attribute(component, this, scope, node));
          break;
        case "Binding":
          this.bindings.push(new Binding(component, this, scope, node));
          break;
        case "Class":
          this.classes.push(new Class(component, this, scope, node));
          break;
        case "StyleDirective":
          this.styles.push(new StyleDirective(component, this, scope, node));
          break;
        case "EventHandler":
          this.handlers.push(new EventHandler(component, this, scope, node));
          break;
        case "Let": {
          const l = new Let(component, this, scope, node);
          this.lets.push(l);
          const dependencies = /* @__PURE__ */ new Set([l.name.name]);
          l.names.forEach((name49) => {
            scope.add(name49, dependencies, this);
          });
          break;
        }
        case "Transition": {
          const transition = new Transition(component, this, scope, node);
          if (node.intro)
            this.intro = transition;
          if (node.outro)
            this.outro = transition;
          break;
        }
        case "Animation":
          this.animation = new Animation(component, this, scope, node);
          break;
        default:
          throw new Error(`Not implemented: ${node.type}`);
      }
    });
    this.scope = scope;
    this.children = map_children(component, this, this.scope, info.children);
    this.validate();
    this.optimise();
    component.apply_stylesheet(this);
    if (this.parent) {
      if (this.actions.length > 0 || this.animation || this.bindings.length > 0 || this.classes.length > 0 || this.intro || this.outro || this.handlers.length > 0 || this.styles.length > 0 || this.name === "option" || this.is_dynamic_element || this.tag_expr.dynamic_dependencies().length || component.compile_options.dev) {
        this.parent.cannot_use_innerhtml();
        this.parent.not_static_content();
      }
    }
  }
  get is_dynamic_element() {
    return this.name === "svelte:element";
  }
  validate() {
    if (this.component.var_lookup.has(this.name) && this.component.var_lookup.get(this.name).imported && !is_svg(this.name) && !is_html(this.name)) {
      this.component.warn(this, compiler_warnings_default.component_name_lowercase(this.name));
    }
    this.validate_attributes();
    this.validate_event_handlers();
    if (this.namespace === namespaces.foreign) {
      this.validate_bindings_foreign();
    } else {
      this.validate_attributes_a11y();
      this.validate_special_cases();
      this.validate_bindings();
      this.validate_content();
    }
  }
  validate_attributes() {
    const { component, parent } = this;
    this.attributes.forEach((attribute) => {
      if (attribute.is_spread)
        return;
      const name49 = attribute.name.toLowerCase();
      if (regex_illegal_attribute_character.test(name49)) {
        return component.error(attribute, compiler_errors_default.illegal_attribute(name49));
      }
      if (name49 === "slot") {
        if (!attribute.is_static) {
          return component.error(attribute, compiler_errors_default.invalid_slot_attribute);
        }
        if (component.slot_outlets.has(name49)) {
          return component.error(attribute, compiler_errors_default.duplicate_slot_attribute(name49));
        }
        if (!(parent.type === "SlotTemplate" || within_custom_element(parent))) {
          return component.error(attribute, compiler_errors_default.invalid_slotted_content);
        }
      }
      if (this.namespace !== namespaces.foreign) {
        if (name49 === "is") {
          component.warn(attribute, compiler_warnings_default.avoid_is);
        }
        if (react_attributes.has(attribute.name)) {
          component.warn(
            attribute,
            compiler_warnings_default.invalid_html_attribute(
              attribute.name,
              react_attributes.get(attribute.name)
            )
          );
        }
      }
    });
  }
  validate_attributes_a11y() {
    const { component, attributes, handlers: handlers3 } = this;
    const attribute_map = /* @__PURE__ */ new Map();
    const handlers_map = /* @__PURE__ */ new Map();
    attributes.forEach((attribute) => attribute_map.set(attribute.name, attribute));
    handlers3.forEach((handler) => handlers_map.set(handler.name, handler));
    attributes.forEach((attribute) => {
      if (attribute.is_spread)
        return;
      const name49 = attribute.name.toLowerCase();
      if (name49.startsWith("aria-")) {
        if (invisible_elements.has(this.name)) {
          component.warn(attribute, compiler_warnings_default.a11y_aria_attributes(this.name));
        }
        const type = name49.slice(5);
        if (!aria_attribute_set.has(type)) {
          const match = fuzzymatch(type, aria_attributes);
          component.warn(attribute, compiler_warnings_default.a11y_unknown_aria_attribute(type, match));
        }
        if (name49 === "aria-hidden" && regex_heading_tags.test(this.name)) {
          component.warn(attribute, compiler_warnings_default.a11y_hidden(this.name));
        }
        let value = attribute.get_static_value();
        if (value === "true")
          value = true;
        if (value === "false")
          value = false;
        if (value !== null && value !== void 0 && import_aria_query2.aria.has(
          /** @type {import('aria-query').ARIAProperty} */
          name49
        )) {
          const schema = import_aria_query2.aria.get(
            /** @type {import('aria-query').ARIAProperty} */
            name49
          );
          if (!is_valid_aria_attribute_value(schema, value)) {
            component.warn(
              attribute,
              compiler_warnings_default.a11y_incorrect_attribute_type(schema, name49)
            );
          }
        }
        if (name49 === "aria-activedescendant" && !this.is_dynamic_element && !is_interactive_element(this.name, attribute_map) && !attribute_map.has("tabindex")) {
          component.warn(attribute, compiler_warnings_default.a11y_aria_activedescendant_has_tabindex);
        }
      }
      if (name49 === "role") {
        if (invisible_elements.has(this.name)) {
          component.warn(attribute, compiler_warnings_default.a11y_misplaced_role(this.name));
        }
        const value = attribute.get_static_value();
        if (typeof value === "string") {
          value.split(regex_any_repeated_whitespaces).forEach(
            /** @param {import('aria-query').ARIARoleDefinitionKey} current_role */
            (current_role) => {
              var _a;
              if (current_role && is_abstract_role(current_role)) {
                component.warn(attribute, compiler_warnings_default.a11y_no_abstract_role(current_role));
              } else if (current_role && !aria_role_set.has(current_role)) {
                const match = fuzzymatch(current_role, aria_roles2);
                component.warn(attribute, compiler_warnings_default.a11y_unknown_role(current_role, match));
              }
              if (current_role === get_implicit_role(this.name, attribute_map) && // <ul role="list"> is ok because CSS list-style:none removes the semantics and this is a way to bring them back
              !["ul", "ol", "li"].includes(this.name)) {
                component.warn(attribute, compiler_warnings_default.a11y_no_redundant_roles(current_role));
              }
              const is_parent_section_or_article = is_parent(this.parent, ["section", "article"]);
              if (!is_parent_section_or_article) {
                const has_nested_redundant_role = current_role === a11y_nested_implicit_semantics.get(this.name);
                if (has_nested_redundant_role) {
                  component.warn(
                    attribute,
                    compiler_warnings_default.a11y_no_redundant_roles(current_role)
                  );
                }
              }
              if (!this.is_dynamic_element && !is_semantic_role_element(current_role, this.name, attribute_map)) {
                const role2 = import_aria_query2.roles.get(current_role);
                if (role2) {
                  const required_role_props = Object.keys(role2.requiredProps);
                  const has_missing_props = required_role_props.some(
                    (prop) => !attributes.find((a) => a.name === prop)
                  );
                  if (has_missing_props) {
                    component.warn(
                      attribute,
                      compiler_warnings_default.a11y_role_has_required_aria_props(
                        current_role,
                        required_role_props
                      )
                    );
                  }
                }
              }
              if (!has_disabled_attribute(attribute_map) && !is_hidden_from_screen_reader(this.name, attribute_map) && !is_presentation_role(current_role) && is_interactive_roles(current_role) && is_static_element(this.name, attribute_map) && !attribute_map.get("tabindex")) {
                const has_interactive_handlers = handlers3.some(
                  (handler) => a11y_interactive_handlers.has(handler.name)
                );
                if (has_interactive_handlers) {
                  component.warn(
                    this,
                    compiler_warnings_default.a11y_interactive_supports_focus(current_role)
                  );
                }
              }
              if (is_interactive_element(this.name, attribute_map) && (is_non_interactive_roles(current_role) || is_presentation_role(current_role))) {
                component.warn(
                  this,
                  compiler_warnings_default.a11y_no_interactive_element_to_noninteractive_role(
                    current_role,
                    this.name
                  )
                );
              }
              if (is_non_interactive_element(this.name, attribute_map) && is_interactive_roles(current_role) && !((_a = a11y_non_interactive_element_to_interactive_role_exceptions[this.name]) == null ? void 0 : _a.includes(
                current_role
              ))) {
                component.warn(
                  this,
                  compiler_warnings_default.a11y_no_noninteractive_element_to_interactive_role(
                    current_role,
                    this.name
                  )
                );
              }
            }
          );
        }
      }
      if (name49 === "accesskey") {
        component.warn(attribute, compiler_warnings_default.a11y_accesskey);
      }
      if (name49 === "autofocus") {
        component.warn(attribute, compiler_warnings_default.a11y_autofocus);
      }
      if (name49 === "scope" && !this.is_dynamic_element && this.name !== "th") {
        component.warn(attribute, compiler_warnings_default.a11y_misplaced_scope);
      }
      if (name49 === "tabindex") {
        const value = attribute.get_static_value();
        if (!isNaN(value) && +value > 0) {
          component.warn(attribute, compiler_warnings_default.a11y_positive_tabindex);
        }
      }
    });
    if (handlers_map.has("click")) {
      const role2 = attribute_map.get("role");
      const is_non_presentation_role = (role2 == null ? void 0 : role2.is_static) && !is_presentation_role(
        /** @type {import('aria-query').ARIARoleDefinitionKey} */
        role2.get_static_value()
      );
      if (!this.is_dynamic_element && !is_hidden_from_screen_reader(this.name, attribute_map) && (!role2 || is_non_presentation_role) && !is_interactive_element(this.name, attribute_map) && !this.attributes.find((attr) => attr.is_spread)) {
        const has_key_event = handlers_map.has("keydown") || handlers_map.has("keyup") || handlers_map.has("keypress");
        if (!has_key_event) {
          component.warn(this, compiler_warnings_default.a11y_click_events_have_key_events);
        }
      }
    }
    const role = attribute_map.get("role");
    const role_static_value = (
      /** @type {import('aria-query').ARIARoleDefinitionKey} */
      role == null ? void 0 : role.get_static_value()
    );
    const role_value = (
      /** @type {import('aria-query').ARIARoleDefinitionKey} */
      role ? role_static_value : get_implicit_role(this.name, attribute_map)
    );
    if (!this.is_dynamic_element && !is_interactive_element(this.name, attribute_map) && !is_interactive_roles(role_static_value)) {
      const tab_index = attribute_map.get("tabindex");
      if (tab_index && (!tab_index.is_static || Number(tab_index.get_static_value()) >= 0)) {
        component.warn(this, compiler_warnings_default.a11y_no_noninteractive_tabindex);
      }
    }
    if (typeof role_value === "string" && import_aria_query2.roles.has(role_value)) {
      const { props } = import_aria_query2.roles.get(role_value);
      const invalid_aria_props = new Set(import_aria_query2.aria.keys().filter((attribute) => !(attribute in props)));
      const is_implicit = role_value && role === void 0;
      attributes.filter((prop) => prop.type !== "Spread").forEach((prop) => {
        if (invalid_aria_props.has(
          /** @type {import('aria-query').ARIAProperty} */
          prop.name
        )) {
          component.warn(
            prop,
            compiler_warnings_default.a11y_role_supports_aria_props(
              prop.name,
              role_value,
              is_implicit,
              this.name
            )
          );
        }
      });
    }
    if (!has_contenteditable_attr(this) && !is_hidden_from_screen_reader(this.name, attribute_map) && !is_presentation_role(role_static_value) && (!is_interactive_element(this.name, attribute_map) && is_non_interactive_roles(role_static_value) || is_non_interactive_element(this.name, attribute_map) && !role)) {
      const has_interactive_handlers = handlers3.some(
        (handler) => a11y_recommended_interactive_handlers.has(handler.name)
      );
      if (has_interactive_handlers) {
        component.warn(
          this,
          compiler_warnings_default.a11y_no_noninteractive_element_interactions(this.name)
        );
      }
    }
    const has_dynamic_role = attribute_map.get("role") && !attribute_map.get("role").is_static;
    if (!has_dynamic_role && !is_hidden_from_screen_reader(this.name, attribute_map) && !is_presentation_role(role_static_value) && !is_interactive_element(this.name, attribute_map) && !is_interactive_roles(role_static_value) && !is_non_interactive_element(this.name, attribute_map) && !is_non_interactive_roles(role_static_value) && !is_abstract_role(role_static_value)) {
      const interactive_handlers = handlers3.map((handler) => handler.name).filter((handler_name) => a11y_interactive_handlers.has(handler_name));
      if (interactive_handlers.length > 0) {
        component.warn(
          this,
          compiler_warnings_default.a11y_no_static_element_interactions(this.name, interactive_handlers)
        );
      }
    }
  }
  validate_special_cases() {
    const { component, attributes, handlers: handlers3 } = this;
    const attribute_map = /* @__PURE__ */ new Map();
    const handlers_map = /* @__PURE__ */ new Map();
    attributes.forEach((attribute) => attribute_map.set(attribute.name, attribute));
    handlers3.forEach((handler) => handlers_map.set(handler.name, handler));
    if (this.name === "a") {
      const href_attribute = attribute_map.get("href") || attribute_map.get("xlink:href");
      const id_attribute = attribute_map.get("id");
      const name_attribute = attribute_map.get("name");
      const target_attribute = attribute_map.get("target");
      const aria_label_attribute = attribute_map.get("aria-label");
      if (component.compile_options.legacy && target_attribute && target_attribute.get_static_value() === "_blank" && href_attribute) {
        const href_static_value = href_attribute.get_static_value() ? href_attribute.get_static_value().toLowerCase() : null;
        if (href_static_value === null || href_static_value.match(/^(https?:)?\/\//i)) {
          const rel = attribute_map.get("rel");
          if (rel == null || rel.is_static) {
            const rel_values = rel ? rel.get_static_value().split(regex_any_repeated_whitespaces) : [];
            if (!rel || !rel_values.includes("noreferrer")) {
              component.warn(this, {
                code: "security-anchor-rel-noreferrer",
                message: 'Security: Anchor with "target=_blank" should have rel attribute containing the value "noreferrer"'
              });
            }
          }
        }
      }
      if (aria_label_attribute) {
        const aria_value = aria_label_attribute.get_static_value();
        if (aria_value != "") {
          this.contains_a11y_label = true;
        }
      }
      if (href_attribute) {
        const href_value = href_attribute.get_static_value();
        if (href_value === "" || href_value === "#" || /^\W*javascript:/i.test(href_value)) {
          component.warn(
            href_attribute,
            compiler_warnings_default.a11y_invalid_attribute(href_attribute.name, href_value)
          );
        }
      } else {
        const id_attribute_valid = id_attribute && id_attribute.get_static_value() !== "";
        const name_attribute_valid = name_attribute && name_attribute.get_static_value() !== "";
        if (!id_attribute_valid && !name_attribute_valid) {
          component.warn(this, compiler_warnings_default.a11y_missing_attribute("a", "an", "href"));
        }
      }
    } else {
      const required_attributes = a11y_required_attributes[this.name];
      if (required_attributes) {
        const has_attribute = required_attributes.some((name49) => attribute_map.has(name49));
        if (!has_attribute) {
          should_have_attribute(this, required_attributes);
        }
      }
    }
    if (this.name === "input") {
      const type = attribute_map.get("type");
      if (type && type.get_static_value() === "image") {
        const required_attributes = ["alt", "aria-label", "aria-labelledby"];
        const has_attribute = required_attributes.some((name49) => attribute_map.has(name49));
        if (!has_attribute) {
          should_have_attribute(this, required_attributes, 'input type="image"');
        }
      }
      const autocomplete = attribute_map.get("autocomplete");
      if (type && autocomplete) {
        const type_value = type.get_static_value();
        const autocomplete_value = autocomplete.get_static_value();
        if (!is_valid_autocomplete(autocomplete_value)) {
          component.warn(
            autocomplete,
            compiler_warnings_default.a11y_autocomplete_valid(type_value, autocomplete_value)
          );
        }
      }
    }
    if (this.name === "img") {
      const alt_attribute = attribute_map.get("alt");
      const aria_hidden_attribute = attribute_map.get("aria-hidden");
      const aria_hidden_exist = aria_hidden_attribute && aria_hidden_attribute.get_static_value();
      if (alt_attribute && !aria_hidden_exist) {
        const alt_value = alt_attribute.get_static_value();
        if (/\b(image|picture|photo)\b/i.test(alt_value)) {
          component.warn(this, compiler_warnings_default.a11y_img_redundant_alt);
        }
      }
    }
    if (this.name === "label") {
      const has_input_child = (children) => {
        if (children.some(
          (child) => child instanceof _Element && (a11y_labelable.has(child.name) || child.name === "slot")
        )) {
          return true;
        }
        for (const child of children) {
          if (!("children" in child) || child.children.length === 0) {
            continue;
          }
          if (has_input_child(child.children)) {
            return true;
          }
        }
        return false;
      };
      if (!attribute_map.has("for") && !has_input_child(this.children)) {
        component.warn(this, compiler_warnings_default.a11y_label_has_associated_control);
      }
    }
    if (this.name === "video") {
      const aria_hidden_attribute = attribute_map.get("aria-hidden");
      const aria_hidden_exist = aria_hidden_attribute && aria_hidden_attribute.get_static_value();
      if (attribute_map.has("muted") || aria_hidden_exist === "true") {
        return;
      }
      let has_caption;
      const track = this.children.find(
        /** @param {Element} i */
        (i) => i.name === "track"
      );
      if (track) {
        has_caption = track.attributes.find(
          (a) => a.name === "kind" && a.get_static_value() === "captions"
        );
      }
      if (!has_caption) {
        component.warn(this, compiler_warnings_default.a11y_media_has_caption);
      }
    }
    if (a11y_distracting_elements.has(this.name)) {
      component.warn(this, compiler_warnings_default.a11y_distracting_elements(this.name));
    }
    if (this.name === "figcaption") {
      let { parent } = this;
      let is_figure_parent = false;
      while (parent) {
        if (
          /** @type {Element} */
          parent.name === "figure"
        ) {
          is_figure_parent = true;
          break;
        }
        if (parent.type === "Element") {
          break;
        }
        parent = parent.parent;
      }
      if (!is_figure_parent) {
        component.warn(this, compiler_warnings_default.a11y_structure_immediate);
      }
    }
    if (this.name === "figure") {
      const children = this.children.filter((node) => {
        if (node.type === "Comment")
          return false;
        if (node.type === "Text")
          return regex_non_whitespace_character.test(node.data);
        return true;
      });
      const index = children.findIndex(
        (child) => (
          /** @type {Element} */
          child.name === "figcaption"
        )
      );
      if (index !== -1 && index !== 0 && index !== children.length - 1) {
        component.warn(children[index], compiler_warnings_default.a11y_structure_first_or_last);
      }
    }
    if (handlers_map.has("mouseover") && !handlers_map.has("focus")) {
      component.warn(
        this,
        compiler_warnings_default.a11y_mouse_events_have_key_events("mouseover", "focus")
      );
    }
    if (handlers_map.has("mouseout") && !handlers_map.has("blur")) {
      component.warn(this, compiler_warnings_default.a11y_mouse_events_have_key_events("mouseout", "blur"));
    }
  }
  validate_bindings_foreign() {
    this.bindings.forEach((binding) => {
      if (binding.name !== "this") {
        return this.component.error(binding, compiler_errors_default.invalid_binding_foreign(binding.name));
      }
    });
  }
  validate_bindings() {
    const { component } = this;
    const check_type_attribute = () => {
      const attribute = this.attributes.find(
        /** @param {import('./Attribute.js').default} attribute */
        (attribute2) => attribute2.name === "type"
      );
      if (!attribute)
        return null;
      if (!attribute.is_static) {
        return component.error(attribute, compiler_errors_default.invalid_type);
      }
      const value = attribute.get_static_value();
      if (value === true) {
        return component.error(attribute, compiler_errors_default.missing_type);
      }
      return value;
    };
    this.bindings.forEach((binding) => {
      const { name: name49 } = binding;
      if (name49 === "value") {
        if (this.name !== "input" && this.name !== "textarea" && this.name !== "select") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_elements(this.name, "value")
          );
        }
        if (this.name === "select") {
          const attribute = this.attributes.find(
            /** @param {import('./Attribute.js').default} attribute */
            (attribute2) => attribute2.name === "multiple"
          );
          if (attribute && !attribute.is_static) {
            return component.error(attribute, compiler_errors_default.dynamic_multiple_attribute);
          }
        } else {
          check_type_attribute();
        }
      } else if (name49 === "checked" || name49 === "indeterminate") {
        if (this.name !== "input") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_elements(this.name, name49)
          );
        }
        const type = check_type_attribute();
        if (type !== "checkbox") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_no_checkbox(name49, type === "radio")
          );
        }
      } else if (name49 === "group") {
        if (this.name !== "input") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_elements(this.name, "group")
          );
        }
        const type = check_type_attribute();
        if (type !== "checkbox" && type !== "radio") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_element_with(
              '<input type="checkbox"> or <input type="radio">',
              "group"
            )
          );
        }
      } else if (name49 === "files") {
        if (this.name !== "input") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_elements(this.name, "files")
          );
        }
        const type = check_type_attribute();
        if (type !== "file") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_element_with('<input type="file">', "files")
          );
        }
      } else if (name49 === "open") {
        if (this.name !== "details") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_element_with("<details>", name49)
          );
        }
      } else if (name49 === "currentTime" || name49 === "duration" || name49 === "paused" || name49 === "buffered" || name49 === "seekable" || name49 === "played" || name49 === "volume" || name49 === "muted" || name49 === "playbackRate" || name49 === "seeking" || name49 === "ended" || name49 === "readyState") {
        if (this.name !== "audio" && this.name !== "video") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_element_with("audio> or <video>", name49)
          );
        }
      } else if (name49 === "videoHeight" || name49 === "videoWidth") {
        if (this.name !== "video") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_element_with("<video>", name49)
          );
        }
      } else if (regex_dimensions.test(name49)) {
        if (this.name === "svg" && (name49 === "offsetWidth" || name49 === "offsetHeight")) {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_on(
              binding.name,
              `<svg>. Use '${name49.replace("offset", "client")}' instead`
            )
          );
        } else if (is_svg(this.name)) {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_on(binding.name, "SVG elements")
          );
        } else if (is_void(this.name)) {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_on(
              binding.name,
              `void elements like <${this.name}>. Use a wrapper element instead`
            )
          );
        }
      } else if (name49 === "naturalWidth" || name49 === "naturalHeight") {
        if (this.name !== "img") {
          return component.error(
            binding,
            compiler_errors_default.invalid_binding_element_with("<img>", name49)
          );
        }
      } else if (is_name_contenteditable(name49)) {
        const contenteditable = get_contenteditable_attr(this);
        if (!contenteditable) {
          return component.error(binding, compiler_errors_default.missing_contenteditable_attribute);
        } else if (contenteditable && !contenteditable.is_static) {
          return component.error(
            contenteditable,
            compiler_errors_default.dynamic_contenteditable_attribute
          );
        }
      } else if (name49 !== "this" && !regex_box_size.test(name49)) {
        return component.error(binding, compiler_errors_default.invalid_binding(binding.name));
      }
    });
  }
  validate_content() {
    if (!a11y_required_content.has(this.name))
      return;
    if (this.contains_a11y_label)
      return;
    if (this.bindings.some((binding) => ["textContent", "innerHTML"].includes(binding.name)))
      return;
    if (this.children.length === 0) {
      this.component.warn(this, compiler_warnings_default.a11y_missing_content(this.name));
    }
  }
  validate_event_handlers() {
    const { component } = this;
    this.handlers.forEach((handler) => {
      if (handler.modifiers.has("passive") && handler.modifiers.has("preventDefault")) {
        return component.error(
          handler,
          compiler_errors_default.invalid_event_modifier_combination("passive", "preventDefault")
        );
      }
      if (handler.modifiers.has("passive") && handler.modifiers.has("nonpassive")) {
        return component.error(
          handler,
          compiler_errors_default.invalid_event_modifier_combination("passive", "nonpassive")
        );
      }
      handler.modifiers.forEach((modifier) => {
        if (!valid_modifiers2.has(modifier)) {
          return component.error(
            handler,
            compiler_errors_default.invalid_event_modifier(list(Array.from(valid_modifiers2)))
          );
        }
        if (modifier === "passive") {
          if (passive_events.has(handler.name)) {
            if (handler.can_make_passive) {
              component.warn(handler, compiler_warnings_default.redundant_event_modifier_for_touch);
            }
          } else {
            component.warn(handler, compiler_warnings_default.redundant_event_modifier_passive);
          }
        }
        if (component.compile_options.legacy && (modifier === "once" || modifier === "passive")) {
          return component.error(handler, compiler_errors_default.invalid_event_modifier_legacy(modifier));
        }
      });
      if (passive_events.has(handler.name) && handler.can_make_passive && !handler.modifiers.has("preventDefault") && !handler.modifiers.has("nonpassive")) {
        handler.modifiers.add("passive");
      }
    });
  }
  is_media_node() {
    return this.name === "audio" || this.name === "video";
  }
  add_css_class() {
    if (this.attributes.some((attr) => attr.is_spread)) {
      this.needs_manual_style_scoping = true;
      return;
    }
    const { id: id2 } = this.component.stylesheet;
    const class_attribute = this.attributes.find((a) => a.name === "class");
    if (class_attribute && !class_attribute.is_true) {
      if (class_attribute.chunks.length === 1 && class_attribute.chunks[0].type === "Text") {
        class_attribute.chunks[0].data += ` ${id2}`;
      } else {
        class_attribute.chunks.push(
          new Text(
            this.component,
            this,
            this.scope,
            /** @type {any} */
            {
              type: "Text",
              data: ` ${id2}`,
              synthetic: true
            }
          )
        );
      }
    } else {
      this.attributes.push(
        new Attribute(
          this.component,
          this,
          this.scope,
          /** @type {any} */
          {
            type: "Attribute",
            name: "class",
            value: [{ type: "Text", data: id2, synthetic: true }]
          }
        )
      );
    }
  }
  get slot_template_name() {
    return (
      /** @type {string} */
      this.attributes.find((attribute) => attribute.name === "slot").get_static_value()
    );
  }
  optimise() {
    attributes_to_compact_whitespace.forEach((attribute_name) => {
      const attribute = this.attributes.find((a) => a.name === attribute_name);
      if (attribute && !attribute.is_true) {
        attribute.chunks.forEach((chunk, index) => {
          if (chunk.type === "Text") {
            let data2 = chunk.data.replace(regex_any_repeated_whitespaces, " ");
            if (index === 0) {
              data2 = data2.trimLeft();
            } else if (index === attribute.chunks.length - 1) {
              data2 = data2.trimRight();
            }
            chunk.data = data2;
          }
        });
      }
    });
  }
  get can_use_textcontent() {
    return this.is_static_content && this.children.every((node) => node.type === "Text" || node.type === "MustacheTag");
  }
  get can_optimise_to_html_string() {
    const can_use_textcontent = this.can_use_textcontent;
    const is_template_with_text_content = this.name === "template" && can_use_textcontent;
    return !is_template_with_text_content && !this.namespace && (this.can_use_innerhtml || can_use_textcontent) && this.children.length > 0;
  }
  get can_optimise_hydration() {
    const is_static_text_content = this.is_static_content && this.children.every((node) => node.type === "Text");
    return this.can_optimise_to_html_string && (this.can_use_innerhtml || is_static_text_content);
  }
  hash() {
    return `svelte-${hash(this.component.source.slice(this.start, this.end))}`;
  }
};
var regex_starts_with_vowel = /^[aeiou]/;
function should_have_attribute(node, attributes, name49 = node.name) {
  const article = regex_starts_with_vowel.test(attributes[0]) ? "an" : "a";
  const sequence = attributes.length > 1 ? attributes.slice(0, -1).join(", ") + ` or ${attributes[attributes.length - 1]}` : attributes[0];
  node.component.warn(node, compiler_warnings_default.a11y_missing_attribute(name49, article, sequence));
}
var regex_minus_sign = /-/;
function within_custom_element(parent) {
  while (parent) {
    if (parent.type === "InlineComponent")
      return false;
    if (parent.type === "Element") {
      if (regex_minus_sign.test(parent.name) || parent.is_dynamic_element)
        return true;
    }
    parent = parent.parent;
  }
  return false;
}
function get_value_attribute(attributes) {
  let node_value;
  attributes.forEach((node) => {
    if (node.type !== "Spread" && node.name.toLowerCase() === "value") {
      node_value = node;
    }
    if (node.type === "Spread") {
      walk(
        /** @type {any} */
        node.expression,
        {
          enter(node2) {
            if (node_value) {
              this.skip();
            }
            if (node2.type === "Identifier") {
              if (
                /** @type {import('estree').Identifier} */
                node2.name.toLowerCase() === "value"
              ) {
                node_value = node2;
              }
            }
          }
        }
      );
    }
  });
  return node_value;
}

// node_modules/svelte/src/compiler/compile/nodes/Head.js
var Head = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {any[]} */
    __publicField(this, "children");
    // TODO
    /** @type {string} */
    __publicField(this, "id");
    this.cannot_use_innerhtml();
    if (info.attributes.length) {
      component.error(info.attributes[0], compiler_errors_default.invalid_attribute_head);
      return;
    }
    this.children = map_children(
      component,
      parent,
      scope,
      info.children.filter((child) => {
        return child.type !== "Text" || regex_non_whitespace_character.test(child.data);
      })
    );
    if (this.children.length > 0) {
      this.id = `svelte-${hash(this.component.source.slice(this.start, this.end))}`;
    }
  }
};

// node_modules/svelte/src/compiler/compile/nodes/IfBlock.js
var IfBlock = class extends AbstractBlock {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {import('./ElseBlock.js').default} */
    __publicField(this, "else");
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    /** @type {import('./ConstTag.js').default[]} */
    __publicField(this, "const_tags");
    this.scope = scope.child();
    this.cannot_use_innerhtml();
    this.not_static_content();
    this.expression = new Expression(component, this, this.scope, info.expression);
    [this.const_tags, this.children] = get_const_tags(info.children, component, this, this);
    this.else = info.else ? new ElseBlock(component, this, scope, info.else) : null;
    this.warn_if_empty_block();
  }
};

// node_modules/svelte/src/compiler/compile/nodes/InlineComponent.js
var InlineComponent = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {string} */
    __publicField(this, "name");
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    /** @type {import('./Binding.js').default[]} */
    __publicField(this, "bindings", []);
    /** @type {import('./EventHandler.js').default[]} */
    __publicField(this, "handlers", []);
    /** @type {import('./Attribute.js').default[]} */
    __publicField(this, "css_custom_properties", []);
    /** @type {import('./interfaces.js').INode[]} */
    __publicField(this, "children");
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    /** @type {string} */
    __publicField(this, "namespace");
    /** @type {Attribute[]} */
    __publicField(this, "let_attributes");
    this.cannot_use_innerhtml();
    this.not_static_content();
    if (info.name !== "svelte:component" && info.name !== "svelte:self") {
      const name49 = info.name.split(".")[0];
      component.warn_if_undefined(name49, info, scope);
      component.add_reference(
        /** @type {any} */
        this,
        name49
      );
    }
    this.name = info.name;
    this.namespace = get_namespace2(parent, component.namespace);
    this.expression = this.name === "svelte:component" ? new Expression(component, this, scope, info.expression) : null;
    const let_attributes = this.let_attributes = [];
    info.attributes.forEach(
      /** @param {import('../../interfaces.js').BaseDirective | import('../../interfaces.js').Attribute | import('../../interfaces.js').SpreadAttribute} node */
      (node) => {
        switch (node.type) {
          case "Action":
            return component.error(node, compiler_errors_default.invalid_action);
          case "Attribute":
            if (node.name.startsWith("--")) {
              this.css_custom_properties.push(new Attribute(component, this, scope, node));
              break;
            }
          case "Spread":
            this.attributes.push(new Attribute(component, this, scope, node));
            break;
          case "Binding":
            this.bindings.push(new Binding(component, this, scope, node));
            break;
          case "Class":
            return component.error(node, compiler_errors_default.invalid_class);
          case "EventHandler":
            this.handlers.push(new EventHandler(component, this, scope, node));
            break;
          case "Let":
            let_attributes.push(node);
            break;
          case "Transition":
            return component.error(node, compiler_errors_default.invalid_transition);
          case "StyleDirective":
            return component.error(node, compiler_errors_default.invalid_component_style_directive);
          case "Animation":
            return component.error(node, compiler_errors_default.invalid_animation);
          default:
            throw new Error(`Not implemented: ${node.type}`);
        }
      }
    );
    this.scope = scope;
    this.handlers.forEach((handler) => {
      handler.modifiers.forEach((modifier) => {
        if (modifier !== "once") {
          return component.error(handler, compiler_errors_default.invalid_event_modifier_component);
        }
      });
    });
    const children = [];
    for (let i = info.children.length - 1; i >= 0; i--) {
      const child = info.children[i];
      if (child.type === "SlotTemplate") {
        children.push(child);
        info.children.splice(i, 1);
      } else if ((child.type === "Element" || child.type === "InlineComponent" || child.type === "Slot") && child.attributes.find((attribute) => attribute.name === "slot")) {
        const slot_template = {
          start: child.start,
          end: child.end,
          type: "SlotTemplate",
          name: "svelte:fragment",
          attributes: [],
          children: [child]
        };
        for (let i2 = child.attributes.length - 1; i2 >= 0; i2--) {
          const attribute = child.attributes[i2];
          if (attribute.type === "Let") {
            slot_template.attributes.push(attribute);
            child.attributes.splice(i2, 1);
          } else if (attribute.type === "Attribute" && attribute.name === "slot") {
            slot_template.attributes.push(attribute);
          }
        }
        for (let i2 = child.children.length - 1; i2 >= 0; i2--) {
          const child_child = child.children[i2];
          if (child_child.type === "ConstTag") {
            slot_template.children.push(child_child);
            child.children.splice(i2, 1);
          }
        }
        children.push(slot_template);
        info.children.splice(i, 1);
      } else if (child.type === "Comment" && children.length > 0) {
        children[children.length - 1].children.unshift(child);
      }
    }
    if (info.children.some((node) => not_whitespace_text(node))) {
      children.push({
        start: info.start,
        end: info.end,
        type: "SlotTemplate",
        name: "svelte:fragment",
        attributes: [],
        children: info.children
      });
    }
    if (let_attributes.length) {
      children.forEach((child) => {
        const slot = child.attributes.find((attribute) => attribute.name === "slot");
        if (!slot || slot.value[0].data === "default") {
          child.attributes.push(...let_attributes);
        }
      });
    }
    this.children = map_children(component, this, this.scope, children);
  }
  get slot_template_name() {
    return (
      /** @type {string} */
      this.attributes.find((attribute) => attribute.name === "slot").get_static_value()
    );
  }
};
function not_whitespace_text(node) {
  return !(node.type === "Text" && regex_only_whitespaces.test(node.data));
}
function get_namespace2(parent, explicit_namespace) {
  const parent_element = parent.find_nearest(/^Element/);
  if (!parent_element) {
    return explicit_namespace;
  }
  return parent_element.namespace;
}

// node_modules/svelte/src/compiler/compile/nodes/KeyBlock.js
var KeyBlock = class extends AbstractBlock {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/Expression.js').default} */
    __publicField(this, "expression");
    this.cannot_use_innerhtml();
    this.not_static_content();
    this.expression = new Expression(component, this, scope, info.expression);
    this.children = map_children(component, this, scope, info.children);
    this.warn_if_empty_block();
  }
};

// node_modules/svelte/src/compiler/compile/nodes/shared/Tag.js
var Tag = class extends Node3 {
  /**
   * @param {any} component
   * @param {any} parent
   * @param {any} scope
   * @param {any} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./Expression.js').default} */
    __publicField(this, "expression");
    /** @type {boolean} */
    __publicField(this, "should_cache");
    component.tags.push(this);
    this.cannot_use_innerhtml();
    this.expression = new Expression(component, this, scope, info.expression);
    this.should_cache = info.expression.type !== "Identifier" || this.expression.dependencies.size && scope.names.has(info.expression.name);
  }
  is_dependencies_static() {
    return this.expression.dynamic_contextual_dependencies().length === 0 && this.expression.dynamic_dependencies().length === 0;
  }
  check_if_content_dynamic() {
    if (!this.is_dependencies_static()) {
      this.not_static_content();
    }
  }
};

// node_modules/svelte/src/compiler/compile/nodes/MustacheTag.js
var MustacheTag = class extends Tag {
};

// node_modules/svelte/src/compiler/compile/nodes/Options.js
var Options = class extends Node3 {
};

// node_modules/svelte/src/compiler/compile/nodes/RawMustacheTag.js
var RawMustacheTag = class extends Tag {
  /**
   * @param {any} component
   * @param {any} parent
   * @param {any} scope
   * @param {any} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    this.cannot_use_innerhtml();
    this.not_static_content();
  }
};

// node_modules/svelte/src/compiler/compile/nodes/DebugTag.js
var DebugTag = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./interfaces.js').INode} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/Expression.js').default[]} */
    __publicField(this, "expressions");
    this.expressions = info.identifiers.map(
      /** @param {import('estree').Node} node */
      (node) => {
        return new Expression(component, parent, scope, node);
      }
    );
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Slot.js
var Slot = class extends Element {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./interfaces.js').INode} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {'Slot'} */
    // @ts-ignore Slot elements have the 'Slot' type, but TypeScript doesn't allow us to have 'Slot' when it extends Element
    __publicField(this, "type", "Slot");
    /** @type {string} */
    __publicField(this, "slot_name");
    /** @type {Map<string, import('./Attribute.js').default>} */
    __publicField(this, "values", /* @__PURE__ */ new Map());
    info.attributes.forEach((attr) => {
      if (attr.type !== "Attribute" && attr.type !== "Spread") {
        return component.error(attr, compiler_errors_default.invalid_slot_directive);
      }
      if (attr.name === "name") {
        if (attr.value.length !== 1 || attr.value[0].type !== "Text") {
          return component.error(attr, compiler_errors_default.dynamic_slot_name);
        }
        this.slot_name = attr.value[0].data;
        if (this.slot_name === "default") {
          return component.error(attr, compiler_errors_default.invalid_slot_name);
        }
      }
      this.values.set(attr.name, new Attribute(component, this, scope, attr));
    });
    if (!this.slot_name)
      this.slot_name = "default";
    component.slots.set(this.slot_name, this);
    this.cannot_use_innerhtml();
    this.not_static_content();
  }
};

// node_modules/svelte/src/compiler/compile/nodes/SlotTemplate.js
var SlotTemplate = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./interfaces.js').INode} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {any} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    /** @type {import('./interfaces.js').INode[]} */
    __publicField(this, "children");
    /** @type {import('./Let.js').default[]} */
    __publicField(this, "lets", []);
    /** @type {import('./ConstTag.js').default[]} */
    __publicField(this, "const_tags");
    /** @type {import('./Attribute.js').default} */
    __publicField(this, "slot_attribute");
    /** @type {string} */
    __publicField(this, "slot_template_name", "default");
    this.validate_slot_template_placement();
    scope = scope.child();
    info.attributes.forEach((node) => {
      switch (node.type) {
        case "Let": {
          const l = new Let(component, this, scope, node);
          this.lets.push(l);
          const dependencies = /* @__PURE__ */ new Set([l.name.name]);
          l.names.forEach((name49) => {
            scope.add(name49, dependencies, this);
          });
          break;
        }
        case "Attribute": {
          if (node.name === "slot") {
            this.slot_attribute = new Attribute(component, this, scope, node);
            if (!this.slot_attribute.is_static) {
              return component.error(node, compiler_errors_default.invalid_slot_attribute);
            }
            const value = this.slot_attribute.get_static_value();
            if (typeof value === "boolean") {
              return component.error(node, compiler_errors_default.invalid_slot_attribute_value_missing);
            }
            this.slot_template_name = /** @type {string} */
            value;
            break;
          }
          throw new Error(`Invalid attribute '${node.name}' in <svelte:fragment>`);
        }
        default:
          throw new Error(`Not implemented: ${node.type}`);
      }
    });
    this.scope = scope;
    [this.const_tags, this.children] = get_const_tags(info.children, component, this, this);
  }
  validate_slot_template_placement() {
    if (this.parent.type !== "InlineComponent") {
      return this.component.error(this, compiler_errors_default.invalid_slotted_content_fragment);
    }
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Title.js
var Title = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/map_children.js').Children} */
    __publicField(this, "children");
    /** @type {boolean} */
    __publicField(this, "should_cache");
    this.children = map_children(component, parent, scope, info.children);
    if (info.attributes.length > 0) {
      component.error(info.attributes[0], compiler_errors_default.illegal_attribute_title);
      return;
    }
    info.children.forEach((child) => {
      if (child.type !== "Text" && child.type !== "MustacheTag") {
        return component.error(child, compiler_errors_default.illegal_structure_title);
      }
    });
    this.should_cache = info.children.length === 1 ? info.children[0].type !== "Identifier" || scope.names.has(info.children[0].name) : true;
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Window.js
var valid_bindings2 = [
  "innerWidth",
  "innerHeight",
  "outerWidth",
  "outerHeight",
  "scrollX",
  "scrollY",
  "devicePixelRatio",
  "online"
];
var Window = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./shared/Node.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./EventHandler.js').default[]} */
    __publicField(this, "handlers", []);
    /** @type {import('./Binding.js').default[]} */
    __publicField(this, "bindings", []);
    /** @type {import('./Action.js').default[]} */
    __publicField(this, "actions", []);
    info.attributes.forEach((node) => {
      if (node.type === "EventHandler") {
        this.handlers.push(new EventHandler(component, this, scope, node));
      } else if (node.type === "Binding") {
        if (node.expression.type !== "Identifier") {
          const { parts } = flatten_reference(node.expression);
          return component.error(node.expression, compiler_errors_default.invalid_binding_window(parts));
        }
        if (!~valid_bindings2.indexOf(node.name)) {
          const match = node.name === "width" ? "innerWidth" : node.name === "height" ? "innerHeight" : fuzzymatch(node.name, valid_bindings2);
          if (match) {
            return component.error(
              node,
              compiler_errors_default.invalid_binding_on(
                node.name,
                "<svelte:window>",
                ` (did you mean '${match}'?)`
              )
            );
          } else {
            return component.error(
              node,
              compiler_errors_default.invalid_binding_on(
                node.name,
                "<svelte:window>",
                ` — valid bindings are ${list(valid_bindings2)}`
              )
            );
          }
        }
        this.bindings.push(new Binding(component, this, scope, node));
      } else if (node.type === "Action") {
        this.actions.push(new Action(component, this, scope, node));
      } else {
      }
    });
  }
};

// node_modules/svelte/src/compiler/utils/push_array.js
function push_array2(array, items) {
  for (let i = 0; i < items.length; i++) {
    array.push(items[i]);
  }
}

// node_modules/svelte/src/compiler/compile/nodes/shared/map_children.js
function get_constructor(type) {
  switch (type) {
    case "AwaitBlock":
      return AwaitBlock;
    case "Body":
      return Body;
    case "Comment":
      return Comment2;
    case "ConstTag":
      return ConstTag;
    case "Document":
      return Document;
    case "EachBlock":
      return EachBlock;
    case "Element":
      return Element;
    case "Head":
      return Head;
    case "IfBlock":
      return IfBlock;
    case "InlineComponent":
      return InlineComponent;
    case "KeyBlock":
      return KeyBlock;
    case "MustacheTag":
      return MustacheTag;
    case "Options":
      return Options;
    case "RawMustacheTag":
      return RawMustacheTag;
    case "DebugTag":
      return DebugTag;
    case "Slot":
      return Slot;
    case "SlotTemplate":
      return SlotTemplate;
    case "Text":
      return Text;
    case "Title":
      return Title;
    case "Window":
      return Window;
    default:
      throw new Error(`Not implemented: ${type}`);
  }
}
function map_children(component, parent, scope, children) {
  let last = null;
  let ignores = [];
  return children.map((child) => {
    const constructor = get_constructor(child.type);
    const use_ignores = child.type !== "Text" && child.type !== "Comment" && ignores.length;
    if (use_ignores)
      component.push_ignores(ignores);
    const node = new constructor(component, parent, scope, child);
    if (use_ignores)
      component.pop_ignores(), ignores = [];
    if (node.type === "Comment" && node.ignores.length) {
      push_array2(ignores, node.ignores);
    }
    if (last)
      last.next = node;
    node.prev = last;
    last = node;
    return node;
  });
}

// node_modules/svelte/src/compiler/compile/utils/check_graph_for_cycles.js
function check_graph_for_cycles(edges) {
  const graph = edges.reduce((g, edge) => {
    const [u, v] = edge;
    if (!g.has(u))
      g.set(u, []);
    if (!g.has(v))
      g.set(v, []);
    g.get(u).push(v);
    return g;
  }, /* @__PURE__ */ new Map());
  const visited = /* @__PURE__ */ new Set();
  const on_stack = /* @__PURE__ */ new Set();
  const cycles = [];
  function visit(v) {
    visited.add(v);
    on_stack.add(v);
    graph.get(v).forEach((w) => {
      if (!visited.has(w)) {
        visit(w);
      } else if (on_stack.has(w)) {
        cycles.push([...on_stack, w]);
      }
    });
    on_stack.delete(v);
  }
  graph.forEach((_, v) => {
    if (!visited.has(v)) {
      visit(v);
    }
  });
  return cycles[0];
}

// node_modules/svelte/src/compiler/compile/nodes/shared/get_const_tags.js
function get_const_tags(children, component, node, parent) {
  const const_tags = [];
  const others = [];
  for (const child of children) {
    if (child.type === "ConstTag") {
      const_tags.push(
        /** @type {import('../../../interfaces.js').ConstTag} */
        child
      );
    } else {
      others.push(child);
    }
  }
  const consts_nodes = const_tags.map((tag2) => new ConstTag(component, node, node.scope, tag2));
  const sorted_consts_nodes = sort_consts_nodes(consts_nodes, component);
  sorted_consts_nodes.forEach((node2) => node2.parse_expression());
  const children_nodes = map_children(component, parent, node.scope, others);
  return [
    sorted_consts_nodes,
    /** @type {Array<Exclude<import('../interfaces.js').INode, ConstTag>>} */
    children_nodes
  ];
}
function sort_consts_nodes(consts_nodes, component) {
  const sorted_consts_nodes = [];
  const unsorted_consts_nodes = consts_nodes.map((node) => {
    return {
      assignees: node.assignees,
      dependencies: node.dependencies,
      node
    };
  });
  const lookup = /* @__PURE__ */ new Map();
  unsorted_consts_nodes.forEach((node) => {
    node.assignees.forEach((name49) => {
      if (!lookup.has(name49)) {
        lookup.set(name49, []);
      }
      lookup.get(name49).push(node);
    });
  });
  const cycle = check_graph_for_cycles(
    unsorted_consts_nodes.reduce((acc, node) => {
      node.assignees.forEach((v) => {
        node.dependencies.forEach((w) => {
          if (!node.assignees.has(w)) {
            acc.push([v, w]);
          }
        });
      });
      return acc;
    }, [])
  );
  if (cycle && cycle.length) {
    const node_list = lookup.get(cycle[0]);
    const node = node_list[0];
    component.error(node.node, compiler_errors_default.cyclical_const_tags(cycle));
  }
  const add_node = (node) => {
    if (sorted_consts_nodes.includes(node))
      return;
    node.dependencies.forEach((name49) => {
      if (node.assignees.has(name49))
        return;
      const earlier_nodes = lookup.get(name49);
      if (earlier_nodes) {
        earlier_nodes.forEach(add_node);
      }
    });
    sorted_consts_nodes.push(node);
  };
  unsorted_consts_nodes.forEach(add_node);
  return sorted_consts_nodes.map((node) => node.node);
}

// node_modules/svelte/src/compiler/compile/nodes/ThenBlock.js
var ThenBlock = class extends AbstractBlock {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('./AwaitBlock.js').default} parent
   * @param {import('./shared/TemplateScope.js').default} scope
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, parent, scope, info) {
    super(component, parent, scope, info);
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    /** @type {import('./ConstTag.js').default[]} */
    __publicField(this, "const_tags");
    this.scope = scope.child();
    if (parent.then_node) {
      parent.then_contexts.forEach((context) => {
        if (context.type !== "DestructuredVariable")
          return;
        this.scope.add(context.key.name, parent.expression.dependencies, this);
      });
    }
    [this.const_tags, this.children] = get_const_tags(info.children, component, this, parent);
    if (!info.skip) {
      this.warn_if_empty_block();
    }
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/add_const_tags.js
function add_const_tags(block, const_tags, ctx) {
  const const_tags_props = [];
  const_tags.forEach((const_tag, i) => {
    const name49 = `#constants_${i}`;
    const_tags_props.push(b`const ${name49} = ${const_tag.expression.manipulate(block, ctx)}`);
    const to_ctx = (name50) => block.renderer.context_lookup.has(name50) ? x`${ctx}[${block.renderer.context_lookup.get(name50).index}]` : (
      /** @type {import('code-red').Node} */
      { type: "Identifier", name: name50 }
    );
    const_tag.contexts.forEach((context) => {
      if (context.type === "DestructuredVariable") {
        const_tags_props.push(
          b`${ctx}[${block.renderer.context_lookup.get(context.key.name).index}] = ${context.default_modifier(context.modifier({ type: "Identifier", name: name49 }), to_ctx)}`
        );
      } else {
        const expression = new Expression(
          block.renderer.component,
          const_tag,
          const_tag.scope,
          context.key
        );
        const_tags_props.push(
          b`const ${context.property_name} = ${expression.manipulate(block, ctx)}`
        );
      }
    });
  });
  return const_tags_props;
}
function add_const_tags_context(renderer, const_tags) {
  const_tags.forEach((const_tag) => {
    const_tag.contexts.forEach((context) => {
      if (context.type !== "DestructuredVariable")
        return;
      renderer.add_to_context(context.key.name, true);
    });
  });
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/AwaitBlock.js
var AwaitBlockBranch = class extends Wrapper {
  /**
   * @param {Status} status
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {AwaitBlockWrapper} parent
   * @param {import('../../nodes/PendingBlock.js').default | import('../../nodes/ThenBlock.js').default | import('../../nodes/CatchBlock.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(status, renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @typedef {'pending' | 'then' | 'catch'} Status */
    /** @type {import('../Block.js').default} */
    __publicField(this, "block");
    /** @type {import('./Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {boolean} */
    __publicField(this, "is_dynamic");
    __publicField(this, "var", null);
    /** @type {Status} */
    __publicField(this, "status");
    /** @type {string} */
    __publicField(this, "value");
    /** @type {import('estree').Literal} */
    __publicField(this, "value_index");
    /** @type {import('../../nodes/shared/Context.js').Context[]} */
    __publicField(this, "value_contexts");
    /** @type {boolean} */
    __publicField(this, "is_destructured");
    this.status = status;
    this.block = block.child({
      comment: create_debugging_comment(node, this.renderer.component),
      name: this.renderer.component.get_unique_name(`create_${status}_block`),
      type: status
    });
    this.add_context(parent.node[status + "_node"], parent.node[status + "_contexts"]);
    this.fragment = new FragmentWrapper(
      renderer,
      this.block,
      this.node.children,
      parent,
      strip_whitespace,
      next_sibling
    );
    this.is_dynamic = this.block.dependencies.size > 0;
  }
  /**
   * @param {import('estree').Node | null} node
   * @param {import('../../nodes/shared/Context.js').Context[]} contexts
   */
  add_context(node, contexts) {
    if (!node)
      return;
    if (node.type === "Identifier") {
      this.value = node.name;
      this.renderer.add_to_context(this.value, true);
    } else {
      contexts.forEach((context) => {
        if (context.type !== "DestructuredVariable")
          return;
        this.renderer.add_to_context(context.key.name, true);
      });
      this.value = this.block.parent.get_unique_name("value").name;
      this.value_contexts = contexts;
      this.renderer.add_to_context(this.value, true);
      this.is_destructured = true;
    }
    this.value_index = this.renderer.context_lookup.get(this.value).index;
    if (this.has_consts(this.node)) {
      add_const_tags_context(this.renderer, this.node.const_tags);
    }
  }
  /**
   * @param {import('../../nodes/PendingBlock.js').default | import('../../nodes/ThenBlock.js').default | import('../../nodes/CatchBlock.js').default} node
   * @returns {node is import('../../nodes/ThenBlock.js').default | import('../../nodes/CatchBlock.js').default}
   */
  has_consts(node) {
    return node instanceof ThenBlock || node instanceof CatchBlock;
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    this.fragment.render(block, parent_node, parent_nodes);
    if (this.is_destructured || this.has_consts(this.node) && this.node.const_tags.length > 0) {
      this.render_get_context();
    }
  }
  render_get_context() {
    const props = this.is_destructured ? this.value_contexts.map((prop) => {
      if (prop.type === "ComputedProperty") {
        const expression = new Expression(
          this.renderer.component,
          this.node,
          this.has_consts(this.node) ? this.node.scope : null,
          prop.key
        );
        return b`const ${prop.property_name} = ${expression.manipulate(this.block, "#ctx")};`;
      } else {
        const to_ctx = (name49) => this.renderer.reference(name49);
        return b`#ctx[${this.block.renderer.context_lookup.get(prop.key.name).index}] = ${prop.default_modifier(prop.modifier(x`#ctx[${this.value_index}]`), to_ctx)};`;
      }
    }) : null;
    const const_tags_props = this.has_consts(this.node) ? add_const_tags(this.block, this.node.const_tags, "#ctx") : null;
    const get_context2 = this.block.renderer.component.get_unique_name(`get_${this.status}_context`);
    this.block.renderer.blocks.push(b`
			function ${get_context2}(#ctx) {
				${props}
				${const_tags_props}
			}
		`);
    this.block.chunks.declarations.push(b`${get_context2}(#ctx)`);
    if (this.block.has_update_method) {
      this.block.chunks.update.unshift(b`${get_context2}(#ctx)`);
    }
  }
};
var AwaitBlockWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/AwaitBlock.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @type {AwaitBlockBranch} */
    __publicField(this, "pending");
    /** @type {AwaitBlockBranch} */
    __publicField(this, "then");
    /** @type {AwaitBlockBranch} */
    __publicField(this, "catch");
    /** @type {import('estree').Identifier} */
    __publicField(this, "var", { type: "Identifier", name: "await_block" });
    block.add_dependencies(this.node.expression.dependencies);
    let is_dynamic3 = false;
    let has_intros = false;
    let has_outros = false;
    ["pending", "then", "catch"].forEach((status) => {
      const child = this.node[status];
      const branch = new AwaitBlockBranch(
        status,
        renderer,
        block,
        this,
        child,
        strip_whitespace,
        next_sibling
      );
      renderer.blocks.push(branch.block);
      if (branch.is_dynamic) {
        is_dynamic3 = true;
        block.add_dependencies(branch.block.dependencies);
      }
      if (branch.block.has_intros)
        has_intros = true;
      if (branch.block.has_outros)
        has_outros = true;
      this[status] = branch;
    });
    ["pending", "then", "catch"].forEach((status) => {
      this[status].block.has_update_method = is_dynamic3;
      this[status].block.has_intro_method = has_intros;
      this[status].block.has_outro_method = has_outros;
    });
    if (has_outros) {
      block.add_outro();
    }
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    const anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
    const update_mount_node = this.get_update_mount_node(anchor);
    const snippet = this.node.expression.manipulate(block);
    const info = block.get_unique_name("info");
    const promise = block.get_unique_name("promise");
    block.add_variable(promise);
    block.maintain_context = true;
    const info_props = x`{
			ctx: #ctx,
			current: null,
			token: null,
			hasCatch: ${this.catch.node.start !== null ? "true" : "false"},
			pending: ${this.pending.block.name},
			then: ${this.then.block.name},
			catch: ${this.catch.block.name},
			value: ${this.then.value_index},
			error: ${this.catch.value_index},
			blocks: ${this.pending.block.has_outro_method && x`[,,,]`}
		}`;
    block.chunks.init.push(b`
			let ${info} = ${info_props};
		`);
    block.chunks.init.push(b`
			@handle_promise(${promise} = ${snippet}, ${info});
		`);
    block.chunks.create.push(b`
			${info}.block.c();
		`);
    if (parent_nodes && this.renderer.options.hydratable) {
      block.chunks.claim.push(b`
				${info}.block.l(${parent_nodes});
			`);
    }
    const initial_mount_node = parent_node || "#target";
    const anchor_node = parent_node ? "null" : "#anchor";
    const has_transitions = this.pending.block.has_intro_method || this.pending.block.has_outro_method;
    block.chunks.mount.push(b`
			${info}.block.m(${initial_mount_node}, ${info}.anchor = ${anchor_node});
			${info}.mount = () => ${update_mount_node};
			${info}.anchor = ${anchor};
		`);
    if (has_transitions) {
      block.chunks.intro.push(b`@transition_in(${info}.block);`);
    }
    const dependencies = this.node.expression.dynamic_dependencies();
    const update_await_block_branch = b`@update_await_block_branch(${info}, #ctx, #dirty)`;
    if (dependencies.length > 0) {
      const condition = x`
				${block.renderer.dirty(dependencies)} &&
				${promise} !== (${promise} = ${snippet}) &&
				@handle_promise(${promise}, ${info})`;
      block.chunks.update.push(b`${info}.ctx = #ctx;`);
      if (this.pending.block.has_update_method) {
        block.chunks.update.push(b`
					if (${condition}) {

					} else {
						${update_await_block_branch}
					}
				`);
      } else {
        block.chunks.update.push(b`
					${condition}
				`);
      }
    } else {
      if (this.pending.block.has_update_method) {
        block.chunks.update.push(b`
					${update_await_block_branch}
				`);
      }
    }
    if (this.pending.block.has_outro_method) {
      block.chunks.outro.push(b`
				for (let #i = 0; #i < 3; #i += 1) {
					const block = ${info}.blocks[#i];
					@transition_out(block);
				}
			`);
    }
    block.chunks.destroy.push(b`
			${info}.block.d(${parent_node ? null : "detaching"});
			${info}.token = null;
			${info} = null;
		`);
    [this.pending, this.then, this.catch].forEach((branch) => {
      branch.render(
        branch.block,
        null,
        /** @type {import('estree').Identifier} */
        x`#nodes`
      );
    });
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Element/EventHandler.js
var TRUE = x`true`;
var FALSE = x`false`;
var EventHandlerWrapper = class {
  /**
   * @param {import('../../../nodes/EventHandler.js').default} node
   * @param {import('../shared/Wrapper.js').default} parent
   */
  constructor(node, parent) {
    /** @type {import('../../../nodes/EventHandler.js').default} */
    __publicField(this, "node");
    /** @type {import('../shared/Wrapper.js').default} */
    __publicField(this, "parent");
    this.node = node;
    this.parent = parent;
    if (!node.expression) {
      this.parent.renderer.add_to_context(node.handler_name.name);
      this.parent.renderer.component.partly_hoisted.push(b`
				function ${node.handler_name.name}(event) {
					@bubble.call(this, $$self, event);
				}
			`);
    }
  }
  /** @param {import('../../Block.js').default} block */
  get_snippet(block) {
    const snippet = this.node.expression ? this.node.expression.manipulate(block) : block.renderer.reference(this.node.handler_name);
    if (this.node.reassigned) {
      block.maintain_context = true;
      return x`function () { if (@is_function(${snippet})) ${snippet}.apply(this, arguments); }`;
    }
    return snippet;
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {string | import('estree').Expression} target
   */
  render(block, target) {
    let snippet = this.get_snippet(block);
    if (this.node.modifiers.has("preventDefault"))
      snippet = x`@prevent_default(${snippet})`;
    if (this.node.modifiers.has("stopPropagation"))
      snippet = x`@stop_propagation(${snippet})`;
    if (this.node.modifiers.has("stopImmediatePropagation"))
      snippet = x`@stop_immediate_propagation(${snippet})`;
    if (this.node.modifiers.has("self"))
      snippet = x`@self(${snippet})`;
    if (this.node.modifiers.has("trusted"))
      snippet = x`@trusted(${snippet})`;
    const args = [];
    const opts = ["nonpassive", "passive", "once", "capture"].filter(
      (mod) => this.node.modifiers.has(mod)
    );
    if (opts.length) {
      if (opts.length === 1 && opts[0] === "capture") {
        args.push(TRUE);
      } else {
        args.push(
          x`{ ${opts.map((opt) => opt === "nonpassive" ? p`passive: false` : p`${opt}: true`)} }`
        );
      }
    } else if (block.renderer.options.dev) {
      args.push(FALSE);
    }
    if (block.renderer.options.dev) {
      args.push(this.node.modifiers.has("preventDefault") ? TRUE : FALSE);
      args.push(this.node.modifiers.has("stopPropagation") ? TRUE : FALSE);
      args.push(this.node.modifiers.has("stopImmediatePropagation") ? TRUE : FALSE);
    }
    block.event_listeners.push(x`@listen(${target}, "${this.node.name}", ${snippet}, ${args})`);
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/add_event_handlers.js
function add_event_handlers(block, target, handlers3) {
  handlers3.forEach((handler) => add_event_handler(block, target, handler));
}
function add_event_handler(block, target, handler) {
  handler.render(block, target);
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/add_actions.js
function add_actions(block, target, actions) {
  actions.forEach((action) => add_action(block, target, action));
}
var regex_invalid_variable_identifier_characters = /[^a-zA-Z0-9_$]/g;
function add_action(block, target, action) {
  const { expression, template_scope } = action;
  let snippet;
  let dependencies;
  if (expression) {
    snippet = expression.manipulate(block);
    dependencies = expression.dynamic_dependencies();
  }
  const id2 = block.get_unique_name(
    `${action.name.replace(regex_invalid_variable_identifier_characters, "_")}_action`
  );
  block.add_variable(id2);
  const [obj, ...properties3] = action.name.split(".");
  const fn = is_contextual(action.component, template_scope, obj) ? block.renderer.reference(obj) : obj;
  if (properties3.length) {
    const member_expression = properties3.reduce((lhs, rhs) => x`${lhs}.${rhs}`, fn);
    block.event_listeners.push(
      x`@action_destroyer(${id2} = ${member_expression}(${target}, ${snippet}))`
    );
  } else {
    block.event_listeners.push(
      x`@action_destroyer(${id2} = ${fn}.call(null, ${target}, ${snippet}))`
    );
  }
  if (dependencies && dependencies.length > 0) {
    let condition = x`${id2} && @is_function(${id2}.update)`;
    if (dependencies.length > 0) {
      condition = x`${condition} && ${block.renderer.dirty(dependencies)}`;
    }
    block.chunks.update.push(b`if (${condition}) ${id2}.update.call(null, ${snippet});`);
  }
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Body.js
var BodyWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/Body.js').default} node
   */
  constructor(renderer, block, parent, node) {
    super(renderer, block, parent, node);
    /** @type {import('./Element/EventHandler.js').default[]} */
    __publicField(this, "handlers");
    this.handlers = this.node.handlers.map((handler) => new EventHandlerWrapper(handler, this));
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} _parent_node
   * @param {import('estree').Identifier} _parent_nodes
   */
  render(block, _parent_node, _parent_nodes) {
    add_event_handlers(block, x`@_document.body`, this.handlers);
    add_actions(block, x`@_document.body`, this.node.actions);
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/DebugTag.js
var DebugTagWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/DebugTag.js').default} node
   * @param {boolean} _strip_whitespace
   * @param {import('./shared/Wrapper.js').default} _next_sibling
   */
  constructor(renderer, block, parent, node, _strip_whitespace, _next_sibling) {
    super(renderer, block, parent, node);
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} _parent_node
   * @param {import('estree').Identifier} _parent_nodes
   */
  render(block, _parent_node, _parent_nodes) {
    const { renderer } = this;
    const { component } = renderer;
    if (!renderer.options.dev)
      return;
    const { var_lookup } = component;
    const start = component.locate(this.node.start + 1);
    const end = { line: start.line, column: start.column + 6 };
    const loc = { start, end };
    const debug = {
      type: "DebuggerStatement",
      loc
    };
    if (this.node.expressions.length === 0) {
      block.chunks.create.push(debug);
      block.chunks.update.push(debug);
    } else {
      const log = {
        type: "Identifier",
        name: "log",
        loc
      };
      const dependencies = /* @__PURE__ */ new Set();
      this.node.expressions.forEach((expression) => {
        add_to_set(dependencies, expression.dependencies);
      });
      const contextual_identifiers = this.node.expressions.filter((e) => {
        const variable = var_lookup.get(
          /** @type {import('estree').Identifier} */
          e.node.name
        );
        return !(variable && variable.hoistable);
      }).map((e) => (
        /** @type {import('estree').Identifier} */
        e.node.name
      ));
      const logged_identifiers = this.node.expressions.map(
        (e) => p`${/** @type {import('estree').Identifier} */
        e.node.name}`
      );
      const debug_statements = b`
				${contextual_identifiers.map((name49) => b`const ${name49} = ${renderer.reference(name49)};`)}
				@_console.${log}({ ${logged_identifiers} });
				debugger;`;
      if (dependencies.size) {
        const condition = renderer.dirty(Array.from(dependencies));
        block.chunks.update.push(b`
					if (${condition}) {
						${debug_statements}
					}
				`);
      }
      block.chunks.create.push(b`{
				${debug_statements}
			}`);
    }
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Document.js
var associated_events = {
  fullscreenElement: ["fullscreenchange"],
  visibilityState: ["visibilitychange"]
};
var readonly = /* @__PURE__ */ new Set(["fullscreenElement", "visibilityState"]);
var DocumentWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/Document.js').default} node
   */
  constructor(renderer, block, parent, node) {
    super(renderer, block, parent, node);
    /** @type {import('./Element/EventHandler.js').default[]} */
    __publicField(this, "handlers");
    this.handlers = this.node.handlers.map((handler) => new EventHandlerWrapper(handler, this));
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} _parent_node
   * @param {import('estree').Identifier} _parent_nodes
   */
  render(block, _parent_node, _parent_nodes) {
    const { renderer } = this;
    const { component } = renderer;
    const events2 = {};
    const bindings = {};
    add_event_handlers(block, x`@_document`, this.handlers);
    add_actions(block, x`@_document`, this.node.actions);
    this.node.bindings.forEach((binding) => {
      const binding_name = (
        /** @type {import('estree').Identifier} */
        binding.expression.node.name
      );
      if (readonly.has(binding.name)) {
        renderer.readonly.add(binding_name);
      }
      bindings[binding.name] = binding_name;
      const binding_events = associated_events[binding.name];
      const property2 = binding.name;
      binding_events.forEach((associated_event) => {
        if (!events2[associated_event])
          events2[associated_event] = [];
        events2[associated_event].push({
          name: binding_name,
          value: property2
        });
      });
    });
    Object.keys(events2).forEach((event) => {
      const id2 = block.get_unique_name(`ondocument${event}`);
      const props = events2[event];
      renderer.add_to_context(id2.name);
      const fn = renderer.reference(id2.name);
      props.forEach((prop) => {
        renderer.meta_bindings.push(b`this._state.${prop.name} = @_document.${prop.value};`);
      });
      block.event_listeners.push(x`
				@listen(@_document, "${event}", ${fn})
			`);
      component.partly_hoisted.push(b`
				function ${id2}() {
					${props.map((prop) => renderer.invalidate(prop.name, x`${prop.name} = @_document.${prop.value}`))}
				}
			`);
      block.chunks.init.push(b`
				@add_render_callback(${fn});
			`);
      component.has_reactive_assignments = true;
    });
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/EachBlock.js
var ElseBlockWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/ElseBlock.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @type {import('../Block.js').default} */
    __publicField(this, "block");
    /** @type {import('./Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {boolean} */
    __publicField(this, "is_dynamic");
    __publicField(this, "var", null);
    add_const_tags_context(renderer, this.node.const_tags);
    this.block = block.child({
      comment: create_debugging_comment(node, this.renderer.component),
      name: this.renderer.component.get_unique_name("create_else_block"),
      type: "else"
    });
    this.fragment = new FragmentWrapper(
      renderer,
      this.block,
      this.node.children,
      parent,
      strip_whitespace,
      next_sibling
    );
    this.is_dynamic = this.block.dependencies.size > 0;
  }
};
var EachBlockWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/EachBlock.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @type {import('../Block.js').default} */
    __publicField(this, "block");
    /** @type {import('./Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {ElseBlockWrapper} */
    __publicField(this, "else");
    /**
     * @type {{
     * 		create_each_block: import('estree').Identifier;
     * 		each_block_value: import('estree').Identifier;
     * 		get_each_context: import('estree').Identifier;
     * 		iterations: import('estree').Identifier;
     * 		fixed_length: number;
     * 		data_length: import('estree').Node | number;
     * 		view_length: import('estree').Node | number;
     * 	}}
     */
    __publicField(this, "vars");
    /** @type {Array<import('estree').Node | import('estree').Node[]>} */
    __publicField(this, "context_props");
    /** @type {import('estree').Identifier} */
    __publicField(this, "index_name");
    /** @type {Array<import('estree').Node | import('estree').Node[]>} */
    __publicField(this, "updates", []);
    /** @type {Set<string>} */
    __publicField(this, "dependencies");
    /** @type {import('estree').Identifier} */
    __publicField(this, "var", { type: "Identifier", name: "each" });
    const { dependencies } = node.expression;
    block.add_dependencies(dependencies);
    this.node.contexts.forEach((context) => {
      if (context.type !== "DestructuredVariable")
        return;
      renderer.add_to_context(context.key.name, true);
    });
    add_const_tags_context(renderer, this.node.const_tags);
    this.block = block.child({
      comment: create_debugging_comment(this.node, this.renderer.component),
      name: renderer.component.get_unique_name("create_each_block"),
      type: "each",
      // @ts-ignore todo: probably error
      key: (
        /** @type {string} */
        node.key
      ),
      bindings: new Map(block.bindings)
    });
    this.block.has_animation = this.node.has_animation;
    this.index_name = this.node.index ? { type: "Identifier", name: this.node.index } : renderer.component.get_unique_name(`${this.node.context}_index`);
    const fixed_length = node.expression.node.type === "ArrayExpression" && node.expression.node.elements.every((element) => element.type !== "SpreadElement") ? node.expression.node.elements.length : null;
    let c2 = this.node.start + 2;
    while (renderer.component.source[c2] !== "e")
      c2 += 1;
    const start = renderer.component.locate(c2);
    const end = { line: start.line, column: start.column + 4 };
    const length2 = {
      type: "Identifier",
      name: "length",
      loc: { start, end }
    };
    const each_block_value = renderer.component.get_unique_name(`${this.var.name}_value`);
    const iterations = block.get_unique_name(`${this.var.name}_blocks`);
    renderer.add_to_context(each_block_value.name, true);
    renderer.add_to_context(this.index_name.name, true);
    this.vars = {
      create_each_block: this.block.name,
      each_block_value,
      get_each_context: renderer.component.get_unique_name(`get_${this.var.name}_context`),
      iterations,
      // optimisation for array literal
      fixed_length,
      data_length: fixed_length === null ? x`${each_block_value}.${length2}` : fixed_length,
      view_length: fixed_length === null ? x`${iterations}.length` : fixed_length
    };
    const object = get_object(node.expression.node);
    const store = object.type === "Identifier" && object.name[0] === "$" ? object.name.slice(1) : null;
    node.contexts.forEach((prop) => {
      if (prop.type !== "DestructuredVariable")
        return;
      this.block.bindings.set(prop.key.name, {
        object: this.vars.each_block_value,
        property: this.index_name,
        modifier: prop.modifier,
        snippet: prop.modifier(
          /** @type {import('estree').Node} */
          x`${this.vars.each_block_value}[${this.index_name}]`
        ),
        store
      });
    });
    if (this.node.index) {
      this.block.get_unique_name(this.node.index);
    }
    renderer.blocks.push(this.block);
    this.fragment = new FragmentWrapper(
      renderer,
      this.block,
      node.children,
      this,
      strip_whitespace,
      next_sibling
    );
    if (this.node.else) {
      this.else = new ElseBlockWrapper(
        renderer,
        block,
        this,
        this.node.else,
        strip_whitespace,
        next_sibling
      );
      renderer.blocks.push(this.else.block);
      if (this.else.is_dynamic) {
        this.block.add_dependencies(this.else.block.dependencies);
      }
    }
    block.add_dependencies(this.block.dependencies);
    if (this.block.has_outros || this.else && this.else.block.has_outros) {
      block.add_outro();
    }
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    if (this.fragment.nodes.length === 0)
      return;
    const { renderer } = this;
    const { component } = renderer;
    const needs_anchor = this.next ? !this.next.is_dom_node() : !parent_node || !this.parent.is_dom_node();
    const snippet = x`@ensure_array_like(${this.node.expression.manipulate(block)})`;
    block.chunks.init.push(b`let ${this.vars.each_block_value} = ${snippet};`);
    const initial_anchor_node = {
      type: "Identifier",
      name: parent_node ? "null" : "#anchor"
    };
    const initial_mount_node = parent_node || { type: "Identifier", name: "#target" };
    const update_anchor_node = needs_anchor ? block.get_unique_name(`${this.var.name}_anchor`) : this.next && this.next.var || { type: "Identifier", name: "null" };
    const update_mount_node = this.get_update_mount_node(
      /** @type {import('estree').Identifier} */
      update_anchor_node
    );
    const args = {
      block,
      parent_node,
      parent_nodes,
      snippet,
      initial_anchor_node,
      initial_mount_node,
      update_anchor_node,
      update_mount_node
    };
    const all_dependencies = new Set(this.block.dependencies);
    this.node.expression.dynamic_dependencies().forEach((dependency) => {
      all_dependencies.add(dependency);
    });
    if (this.node.key) {
      this.node.key.dynamic_dependencies().forEach((dependency) => {
        all_dependencies.add(dependency);
      });
    }
    this.dependencies = all_dependencies;
    if (this.node.key) {
      this.render_keyed(args);
    } else {
      this.render_unkeyed(args);
    }
    if (this.block.has_intro_method || this.block.has_outro_method) {
      block.chunks.intro.push(b`
				for (let #i = 0; #i < ${this.vars.data_length}; #i += 1) {
					@transition_in(${this.vars.iterations}[#i]);
				}
			`);
    }
    if (needs_anchor) {
      block.add_element(
        /** @type {import('estree').Identifier} */
        update_anchor_node,
        x`@empty()`,
        parent_nodes && x`@empty()`,
        parent_node
      );
    }
    if (this.else) {
      let else_ctx = x`#ctx`;
      if (this.else.node.const_tags.length > 0) {
        const get_ctx_name = this.renderer.component.get_unique_name("get_else_ctx");
        this.renderer.blocks.push(b`
					function ${get_ctx_name}(#ctx) {
						const child_ctx = #ctx.slice();
						${add_const_tags(block, this.else.node.const_tags, "child_ctx")}
						return child_ctx;
					}
				`);
        else_ctx = x`${get_ctx_name}(#ctx)`;
      }
      const each_block_else = component.get_unique_name(`${this.var.name}_else`);
      block.chunks.init.push(b`let ${each_block_else} = null;`);
      block.chunks.init.push(b`
				if (!${this.vars.data_length}) {
					${each_block_else} = ${this.else.block.name}(${else_ctx});
				}
			`);
      block.chunks.create.push(b`
				if (${each_block_else}) {
					${each_block_else}.c();
				}
			`);
      if (this.renderer.options.hydratable) {
        block.chunks.claim.push(b`
					if (${each_block_else}) {
						${each_block_else}.l(${parent_nodes});
					}
				`);
      }
      block.chunks.mount.push(b`
				if (${each_block_else}) {
					${each_block_else}.m(${initial_mount_node}, ${initial_anchor_node});
				}
			`);
      const has_transitions = !!(this.else.block.has_intro_method || this.else.block.has_outro_method);
      const destroy_block_else = this.else.block.has_outro_method ? b`
					@group_outros();
					@transition_out(${each_block_else}, 1, 1, () => {
						${each_block_else} = null;
					});
					@check_outros();` : b`
					${each_block_else}.d(1);
					${each_block_else} = null;`;
      if (this.else.block.has_update_method) {
        this.updates.push(b`
					if (!${this.vars.data_length} && ${each_block_else}) {
						${each_block_else}.p(${else_ctx}, #dirty);
					} else if (!${this.vars.data_length}) {
						${each_block_else} = ${this.else.block.name}(${else_ctx});
						${each_block_else}.c();
						${has_transitions && b`@transition_in(${each_block_else}, 1);`}
						${each_block_else}.m(${update_mount_node}, ${update_anchor_node});
					} else if (${each_block_else}) {
						${destroy_block_else};
					}
				`);
      } else {
        this.updates.push(b`
					if (${this.vars.data_length}) {
						if (${each_block_else}) {
							${destroy_block_else};
						}
					} else if (!${each_block_else}) {
						${each_block_else} = ${this.else.block.name}(${else_ctx});
						${each_block_else}.c();
						${has_transitions && b`@transition_in(${each_block_else}, 1);`}
						${each_block_else}.m(${update_mount_node}, ${update_anchor_node});
					}
				`);
      }
      block.chunks.destroy.push(b`
				if (${each_block_else}) ${each_block_else}.d(${parent_node ? "" : "detaching"});
			`);
    }
    if (this.updates.length) {
      block.chunks.update.push(b`
				if (${block.renderer.dirty(Array.from(all_dependencies))}) {
					${this.updates}
				}
			`);
    }
    this.fragment.render(
      this.block,
      null,
      /** @type {import('estree').Identifier} */
      x`#nodes`
    );
    if (this.else) {
      this.else.fragment.render(
        this.else.block,
        null,
        /** @type {import('estree').Identifier} */
        x`#nodes`
      );
    }
    this.context_props = this.node.contexts.map((prop) => {
      if (prop.type === "DestructuredVariable") {
        const to_ctx = (name49) => renderer.context_lookup.has(name49) ? x`child_ctx[${renderer.context_lookup.get(name49).index}]` : (
          /** @type {import('estree').Node} */
          { type: "Identifier", name: name49 }
        );
        return b`child_ctx[${renderer.context_lookup.get(prop.key.name).index}] = ${prop.default_modifier(prop.modifier(x`list[i]`), to_ctx)};`;
      } else {
        const expression = new Expression(
          this.renderer.component,
          this.node,
          this.node.scope,
          prop.key
        );
        return b`const ${prop.property_name} = ${expression.manipulate(block, "child_ctx")};`;
      }
    });
    if (this.node.has_binding)
      this.context_props.push(
        b`child_ctx[${renderer.context_lookup.get(this.vars.each_block_value.name).index}] = list;`
      );
    if (this.node.has_binding || this.node.has_index_binding || this.node.index)
      this.context_props.push(
        b`child_ctx[${renderer.context_lookup.get(this.index_name.name).index}] = i;`
      );
    renderer.blocks.push(b`
			function ${this.vars.get_each_context}(#ctx, list, i) {
				const child_ctx = #ctx.slice();
				${this.context_props}
				${add_const_tags(this.block, this.node.const_tags, "child_ctx")}
				return child_ctx;
			}
		`);
  }
  /**
   * @param {{
   * 		block: import('../Block.js').default;
   * 		parent_node: import('estree').Identifier;
   * 		parent_nodes: import('estree').Identifier;
   * 		snippet: import('estree').Node;
   * 		initial_anchor_node: import('estree').Identifier;
   * 		initial_mount_node: import('estree').Identifier;
   * 		update_anchor_node: import('estree').Identifier;
   * 		update_mount_node: import('estree').Identifier;
   * 	}} params
   */
  render_keyed({
    block,
    parent_node,
    parent_nodes,
    snippet,
    initial_anchor_node,
    initial_mount_node,
    update_anchor_node,
    update_mount_node
  }) {
    const { create_each_block, iterations, data_length, view_length } = this.vars;
    const get_key = block.get_unique_name("get_key");
    const lookup = block.get_unique_name(`${this.var.name}_lookup`);
    block.add_variable(iterations, x`[]`);
    block.add_variable(lookup, x`new @_Map()`);
    if (this.fragment.nodes[0].is_dom_node()) {
      this.block.first = this.fragment.nodes[0].var;
    } else {
      this.block.first = this.block.get_unique_name("first");
      this.block.add_element(this.block.first, x`@empty()`, parent_nodes && x`@empty()`, null);
    }
    block.chunks.init.push(b`
			const ${get_key} = #ctx => ${this.node.key.manipulate(block)};

			${this.renderer.options.dev && b`@validate_each_keys(#ctx, ${this.vars.each_block_value}, ${this.vars.get_each_context}, ${get_key});`}
			for (let #i = 0; #i < ${data_length}; #i += 1) {
				let child_ctx = ${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i);
				let key = ${get_key}(child_ctx);
				${lookup}.set(key, ${iterations}[#i] = ${create_each_block}(key, child_ctx));
			}
		`);
    block.chunks.create.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].c();
			}
		`);
    if (parent_nodes && this.renderer.options.hydratable) {
      block.chunks.claim.push(b`
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					${iterations}[#i].l(${parent_nodes});
				}
			`);
    }
    block.chunks.mount.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				if (${iterations}[#i]) {
					${iterations}[#i].m(${initial_mount_node}, ${initial_anchor_node});
				}
			}
		`);
    const dynamic = this.block.has_update_method;
    const destroy = this.node.has_animation ? this.block.has_outros ? "@fix_and_outro_and_destroy_block" : "@fix_and_destroy_block" : this.block.has_outros ? "@outro_and_destroy_block" : "@destroy_block";
    if (this.dependencies.size) {
      this.block.maintain_context = true;
      this.updates.push(b`
				${this.vars.each_block_value} = ${snippet};

				${this.block.has_outros && b`@group_outros();`}
				${this.node.has_animation && b`for (let #i = 0; #i < ${view_length}; #i += 1) ${iterations}[#i].r();`}
				${this.renderer.options.dev && b`@validate_each_keys(#ctx, ${this.vars.each_block_value}, ${this.vars.get_each_context}, ${get_key});`}
				${iterations} = @update_keyed_each(${iterations}, #dirty, ${get_key}, ${dynamic ? 1 : 0}, #ctx, ${this.vars.each_block_value}, ${lookup}, ${update_mount_node}, ${destroy}, ${create_each_block}, ${update_anchor_node}, ${this.vars.get_each_context});
				${this.node.has_animation && b`for (let #i = 0; #i < ${view_length}; #i += 1) ${iterations}[#i].a();`}
				${this.block.has_outros && b`@check_outros();`}
			`);
    }
    if (this.block.has_outros) {
      block.chunks.outro.push(b`
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					@transition_out(${iterations}[#i]);
				}
			`);
    }
    block.chunks.destroy.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].d(${parent_node ? null : "detaching"});
			}
		`);
  }
  /**
   * @param {{
   * 		block: import('../Block.js').default;
   * 		parent_nodes: import('estree').Identifier;
   * 		snippet: import('estree').Node;
   * 		initial_anchor_node: import('estree').Identifier;
   * 		initial_mount_node: import('estree').Identifier;
   * 		update_anchor_node: import('estree').Identifier;
   * 		update_mount_node: import('estree').Identifier;
   * 	}} params
   */
  render_unkeyed({
    block,
    parent_nodes,
    snippet,
    initial_anchor_node,
    initial_mount_node,
    update_anchor_node,
    update_mount_node
  }) {
    const { create_each_block, iterations, fixed_length, data_length, view_length } = this.vars;
    block.chunks.init.push(b`
			let ${iterations} = [];

			for (let #i = 0; #i < ${data_length}; #i += 1) {
				${iterations}[#i] = ${create_each_block}(${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i));
			}
		`);
    block.chunks.create.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].c();
			}
		`);
    if (parent_nodes && this.renderer.options.hydratable) {
      block.chunks.claim.push(b`
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					${iterations}[#i].l(${parent_nodes});
				}
			`);
    }
    block.chunks.mount.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				if (${iterations}[#i]) {
					${iterations}[#i].m(${initial_mount_node}, ${initial_anchor_node});
				}
			}
		`);
    if (this.dependencies.size) {
      const has_transitions = !!(this.block.has_intro_method || this.block.has_outro_method);
      const for_loop_body = this.block.has_update_method ? b`
					if (${iterations}[#i]) {
						${iterations}[#i].p(child_ctx, #dirty);
						${has_transitions && b`@transition_in(${this.vars.iterations}[#i], 1);`}
					} else {
						${iterations}[#i] = ${create_each_block}(child_ctx);
						${iterations}[#i].c();
						${has_transitions && b`@transition_in(${this.vars.iterations}[#i], 1);`}
						${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});
					}
				` : has_transitions ? b`
						if (${iterations}[#i]) {
							@transition_in(${this.vars.iterations}[#i], 1);
						} else {
							${iterations}[#i] = ${create_each_block}(child_ctx);
							${iterations}[#i].c();
							@transition_in(${this.vars.iterations}[#i], 1);
							${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});
						}
					` : b`
						if (!${iterations}[#i]) {
							${iterations}[#i] = ${create_each_block}(child_ctx);
							${iterations}[#i].c();
							${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});
						}
					`;
      const start = this.block.has_update_method ? 0 : "#old_length";
      let remove_old_blocks;
      if (this.block.has_outros) {
        const out = block.get_unique_name("out");
        block.chunks.init.push(b`
					const ${out} = i => @transition_out(${iterations}[i], 1, 1, () => {
						${iterations}[i] = null;
					});
				`);
        remove_old_blocks = b`
					@group_outros();
					for (#i = ${data_length}; #i < ${view_length}; #i += 1) {
						${out}(#i);
					}
					@check_outros();
				`;
      } else {
        remove_old_blocks = b`
					for (${this.block.has_update_method ? null : x`#i = ${data_length}`}; #i < ${this.block.has_update_method ? view_length : "#old_length"}; #i += 1) {
						${iterations}[#i].d(1);
					}
					${!fixed_length && b`${view_length} = ${data_length};`}
				`;
      }
      const update = b`
				${!this.block.has_update_method && b`const #old_length = ${this.vars.each_block_value}.length;`}
				${this.vars.each_block_value} = ${snippet};

				let #i;
				for (#i = ${start}; #i < ${data_length}; #i += 1) {
					const child_ctx = ${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i);

					${for_loop_body}
				}

				${remove_old_blocks}
			`;
      this.updates.push(update);
    }
    if (this.block.has_outros) {
      block.chunks.outro.push(b`
				${iterations} = ${iterations}.filter(@_Boolean);
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					@transition_out(${iterations}[#i]);
				}
			`);
    }
    block.chunks.destroy.push(b`@destroy_each(${iterations}, detaching);`);
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Text.js
var TextWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/Text.js').default} node
   * @param {string} data
   */
  constructor(renderer, block, parent, node, data2) {
    super(renderer, block, parent, node);
    /** @type {string} */
    __publicField(this, "_data");
    /** @type {boolean} */
    __publicField(this, "skip");
    /** @type {import('estree').Identifier} */
    __publicField(this, "var");
    this.skip = this.node.should_skip();
    this._data = data2;
    this.var = /** @type {unknown} */
    /** @type {import('estree').Identifier} */
    this.skip ? null : x`t`;
  }
  use_space() {
    return this.node.use_space();
  }
  set data(value) {
    this.node.data = this._data = value;
  }
  get data() {
    return this._data;
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    if (this.skip)
      return;
    const use_space = this.use_space();
    const string_literal2 = {
      type: "Literal",
      value: this.data,
      loc: {
        start: this.renderer.locate(this.node.start),
        end: this.renderer.locate(this.node.end)
      }
    };
    block.add_element(
      this.var,
      use_space ? x`@space()` : x`@text(${string_literal2})`,
      parent_nodes && (use_space ? x`@claim_space(${parent_nodes})` : x`@claim_text(${parent_nodes}, ${string_literal2})`),
      /** @type {import('estree').Identifier} */
      parent_node
    );
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Element/fix_attribute_casing.js
var svg_attributes = "accent-height accumulate additive alignment-baseline allowReorder alphabetic amplitude arabic-form ascent attributeName attributeType autoReverse azimuth baseFrequency baseline-shift baseProfile bbox begin bias by calcMode cap-height class clip clipPathUnits clip-path clip-rule color color-interpolation color-interpolation-filters color-profile color-rendering contentScriptType contentStyleType cursor cx cy d decelerate descent diffuseConstant direction display divisor dominant-baseline dur dx dy edgeMode elevation enable-background end exponent externalResourcesRequired fill fill-opacity fill-rule filter filterRes filterUnits flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight format from fr fx fy g1 g2 glyph-name glyph-orientation-horizontal glyph-orientation-vertical glyphRef gradientTransform gradientUnits hanging height href horiz-adv-x horiz-origin-x id ideographic image-rendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength kerning keyPoints keySplines keyTimes lang lengthAdjust letter-spacing lighting-color limitingConeAngle local marker-end marker-mid marker-start markerHeight markerUnits markerWidth mask maskContentUnits maskUnits mathematical max media method min mode name numOctaves offset onabort onactivate onbegin onclick onend onerror onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup onrepeat onresize onscroll onunload opacity operator order orient orientation origin overflow overline-position overline-thickness panose-1 paint-order pathLength patternContentUnits patternTransform patternUnits pointer-events points pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits r radius refX refY rendering-intent repeatCount repeatDur requiredExtensions requiredFeatures restart result rotate rx ry scale seed shape-rendering slope spacing specularConstant specularExponent speed spreadMethod startOffset stdDeviation stemh stemv stitchTiles stop-color stop-opacity strikethrough-position strikethrough-thickness string stroke stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width style surfaceScale systemLanguage tabindex tableValues target targetX targetY text-anchor text-decoration text-rendering textLength to transform type u1 u2 underline-position underline-thickness unicode unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical values version vert-adv-y vert-origin-x vert-origin-y viewBox viewTarget visibility width widths word-spacing writing-mode x x-height x1 x2 xChannelSelector xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y y1 y2 yChannelSelector z zoomAndPan".split(
  " "
);
var svg_attribute_lookup = /* @__PURE__ */ new Map();
svg_attributes.forEach((name49) => {
  svg_attribute_lookup.set(name49.toLowerCase(), name49);
});
function fix_attribute_casing(name49) {
  name49 = name49.toLowerCase();
  return svg_attribute_lookup.get(name49) || name49;
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Element/handle_select_value_binding.js
function handle_select_value_binding(attr, dependencies) {
  const { parent } = attr;
  if (parent.node.name === "select") {
    parent.select_binding_dependencies = dependencies;
    dependencies.forEach((prop) => {
      parent.renderer.component.indirect_dependencies.set(prop, /* @__PURE__ */ new Set());
    });
  }
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Element/Attribute.js
var non_textlike_input_types = /* @__PURE__ */ new Set([
  "button",
  "checkbox",
  "color",
  "date",
  "datetime-local",
  "file",
  "hidden",
  "image",
  "radio",
  "range",
  "reset",
  "submit"
]);
var BaseAttributeWrapper = class {
  /**
   * @param {import('./index.js').default} parent
   * @param {import('../../Block.js').default} block
   * @param {import('../../../nodes/Attribute.js').default} node
   */
  constructor(parent, block, node) {
    /** @type {import('../../../nodes/Attribute.js').default} */
    __publicField(this, "node");
    /** @type {import('./index.js').default} */
    __publicField(this, "parent");
    this.node = node;
    this.parent = parent;
    if (node.dependencies.size > 0) {
      block.add_dependencies(node.dependencies);
    }
  }
  /** @param {import('../../Block.js').default} _block */
  render(_block) {
  }
};
var regex_minus_sign2 = /-/;
var regex_invalid_variable_identifier_characters2 = /[^a-zA-Z_$]/g;
var AttributeWrapper = class extends BaseAttributeWrapper {
  constructor(parent, block, node) {
    super(parent, block, node);
    /** @type {any} */
    __publicField(this, "metadata");
    /** @type {string} */
    __publicField(this, "name");
    /** @type {string} */
    __publicField(this, "property_name");
    /** @type {boolean} */
    __publicField(this, "is_indirectly_bound_value");
    /** @type {boolean} */
    __publicField(this, "is_src");
    /** @type {boolean} */
    __publicField(this, "is_srcset");
    /** @type {boolean} */
    __publicField(this, "is_select_value_attribute");
    /** @type {boolean} */
    __publicField(this, "is_input_value");
    /** @type {boolean} */
    __publicField(this, "should_cache");
    /** @type {import('estree').Identifier} */
    __publicField(this, "last");
    if (node.dependencies.size > 0) {
      if (this.parent.node.name === "option" && node.name === "value") {
        let select = this.parent;
        while (select && (select.node.type !== "Element" || select.node.name !== "select")) {
          select = select.parent;
        }
        if (select && select.select_binding_dependencies) {
          select.select_binding_dependencies.forEach((prop) => {
            this.node.dependencies.forEach((dependency) => {
              if (this.node.scope.is_top_level(dependency)) {
                this.parent.renderer.component.indirect_dependencies.get(prop).add(dependency);
              }
            });
          });
        }
      }
      if (node.name === "value") {
        handle_select_value_binding(this, node.dependencies);
        this.parent.has_dynamic_value = true;
      }
    }
    if (this.parent.node.namespace == namespaces.foreign || this.parent.node.name.includes("-")) {
      this.name = this.node.name;
      this.metadata = this.get_metadata();
      this.is_indirectly_bound_value = false;
      this.property_name = null;
      this.is_select_value_attribute = false;
      this.is_input_value = false;
    } else {
      this.name = fix_attribute_casing(this.node.name);
      this.metadata = this.get_metadata();
      this.is_indirectly_bound_value = is_indirectly_bound_value(this);
      this.property_name = this.is_indirectly_bound_value ? "__value" : this.metadata && this.metadata.property_name;
      this.is_select_value_attribute = this.name === "value" && this.parent.node.name === "select";
      this.is_input_value = this.name === "value" && this.parent.node.name === "input";
    }
    this.is_src = this.name === "src" && (!this.parent.node.namespace || this.parent.node.namespace === namespaces.html);
    this.is_srcset = this.name === "srcset" && (!this.parent.node.namespace || this.parent.node.namespace === namespaces.html);
    this.should_cache = should_cache(this);
  }
  /** @param {import('../../Block.js').default} block */
  render(block) {
    const element = this.parent;
    const { name: name49, property_name, should_cache: should_cache2, is_indirectly_bound_value: is_indirectly_bound_value2 } = this;
    const method = regex_minus_sign2.test(element.node.name) ? "@set_custom_element_data" : name49.slice(0, 6) === "xlink:" ? "@xlink_attr" : "@attr";
    const is_legacy_input_type = element.renderer.component.compile_options.legacy && name49 === "type" && this.parent.node.name === "input";
    const dependencies = this.get_dependencies();
    const value = this.get_value(block);
    let updater;
    const init = this.get_init(block, value);
    if (is_legacy_input_type) {
      block.chunks.hydrate.push(b`@set_input_type(${element.var}, ${init});`);
      updater = b`@set_input_type(${element.var}, ${should_cache2 ? this.last : value});`;
    } else if (this.is_select_value_attribute) {
      const is_multiple_select = element.node.get_static_attribute_value("multiple");
      if (is_multiple_select) {
        updater = b`@select_options(${element.var}, ${value});`;
      } else {
        updater = b`@select_option(${element.var}, ${value});`;
      }
      block.chunks.mount.push(b`
				${updater}
			`);
    } else if (this.is_src) {
      block.chunks.hydrate.push(
        b`if (!@src_url_equal(${element.var}.src, ${init})) ${method}(${element.var}, "${name49}", ${this.last});`
      );
      updater = b`${method}(${element.var}, "${name49}", ${should_cache2 ? this.last : value});`;
    } else if (this.is_srcset) {
      block.chunks.hydrate.push(
        b`if (!@srcset_url_equal(${element.var}, ${init})) ${method}(${element.var}, "${name49}", ${this.last});`
      );
      updater = b`${method}(${element.var}, "${name49}", ${should_cache2 ? this.last : value});`;
    } else if (property_name) {
      block.chunks.hydrate.push(b`${element.var}.${property_name} = ${init};`);
      updater = block.renderer.options.dev ? b`@prop_dev(${element.var}, "${property_name}", ${should_cache2 ? this.last : value});` : b`${element.var}.${property_name} = ${should_cache2 ? this.last : value};`;
    } else {
      block.chunks.hydrate.push(b`${method}(${element.var}, "${name49}", ${init});`);
      updater = b`${method}(${element.var}, "${name49}", ${should_cache2 ? this.last : value});`;
    }
    if (is_indirectly_bound_value2) {
      const update_value = b`@set_input_value(${element.var}, ${element.var}.__value);`;
      block.chunks.hydrate.push(update_value);
      updater = b`
				${updater}
				${update_value};
			`;
    }
    if (this.node.name === "value" && dependencies.length > 0) {
      if (this.parent.bindings.some((binding) => binding.node.name === "group")) {
        this.parent.dynamic_value_condition = block.get_unique_name("value_has_changed");
        block.add_variable(this.parent.dynamic_value_condition, x`false`);
        updater = b`
					${updater}
					${this.parent.dynamic_value_condition} = true;
				`;
      }
    }
    if (dependencies.length > 0) {
      const condition = this.get_dom_update_conditions(block, block.renderer.dirty(dependencies));
      block.chunks.update.push(b`
				if (${condition}) {
					${updater}
				}`);
    }
    if (name49 === "autofocus") {
      block.autofocus = {
        element_var: element.var,
        condition_expression: this.node.is_true ? void 0 : value
      };
    }
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {any} value
   */
  get_init(block, value) {
    this.last = this.should_cache && block.get_unique_name(
      `${this.parent.var.name}_${this.name.replace(
        regex_invalid_variable_identifier_characters2,
        "_"
      )}_value`
    );
    if (this.should_cache)
      block.add_variable(this.last);
    return this.should_cache ? x`${this.last} = ${value}` : value;
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Node} dependency_condition
   */
  get_dom_update_conditions(block, dependency_condition) {
    const { property_name, should_cache: should_cache2, last } = this;
    const element = this.parent;
    const value = this.get_value(block);
    let condition = dependency_condition;
    if (should_cache2) {
      condition = this.is_src ? x`${condition} && (!@src_url_equal(${element.var}.src, (${last} = ${value})))` : x`${condition} && (${last} !== (${last} = ${value}))`;
    }
    if (this.is_input_value) {
      const type = element.node.get_static_attribute_value("type");
      if (type !== true && !non_textlike_input_types.has(type)) {
        condition = x`${condition} && ${element.var}.${property_name} !== ${should_cache2 ? last : value}`;
      }
    }
    if (block.has_outros) {
      condition = x`!#current || ${condition}`;
    }
    return condition;
  }
  get_dependencies() {
    const node_dependencies = this.node.get_dependencies();
    const dependencies = new Set(node_dependencies);
    node_dependencies.forEach((prop) => {
      const indirect_dependencies = this.parent.renderer.component.indirect_dependencies.get(prop);
      if (indirect_dependencies) {
        indirect_dependencies.forEach((indirect_dependency) => {
          dependencies.add(indirect_dependency);
        });
      }
    });
    return Array.from(dependencies);
  }
  get_metadata() {
    if (this.parent.node.namespace)
      return null;
    const metadata = attribute_lookup[this.name];
    if (metadata && metadata.applies_to && !metadata.applies_to.includes(this.parent.node.name))
      return null;
    return metadata;
  }
  /** @param {import('../../Block.js').default} block */
  get_value(block) {
    if (this.node.is_true) {
      if (this.metadata && boolean_attributes.has(this.metadata.property_name.toLowerCase())) {
        return x`true`;
      }
      return x`""`;
    }
    if (this.node.chunks.length === 0)
      return x`""`;
    if (this.node.chunks.length === 1) {
      return this.node.chunks[0].type === "Text" ? string_literal(
        /** @type {import('../../../nodes/Text.js').default} */
        this.node.chunks[0].data
      ) : (
        /** @type {import('../../../nodes/shared/Expression.js').default} */
        this.node.chunks[0].manipulate(block)
      );
    }
    let value = this.node.name === "class" ? this.get_class_name_text(block) : this.render_chunks(block).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
    if (this.node.chunks[0].type !== "Text") {
      value = x`"" + ${value}`;
    }
    return value;
  }
  /** @param {import('../../Block.js').default} block */
  get_class_name_text(block) {
    const scoped_css = this.node.chunks.some(
      (chunk) => chunk.synthetic
    );
    const rendered = this.render_chunks(block);
    if (scoped_css && rendered.length === 2) {
      rendered[0] = x`@null_to_empty(${rendered[0]})`;
    }
    return rendered.reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
  }
  /** @param {import('../../Block.js').default} block */
  render_chunks(block) {
    return this.node.chunks.map((chunk) => {
      if (chunk.type === "Text") {
        return string_literal(chunk.data);
      }
      return chunk.manipulate(block);
    });
  }
  stringify() {
    if (this.node.is_true)
      return "";
    const value = this.node.chunks;
    if (value.length === 0)
      return '=""';
    return `="${value.map((chunk) => {
      return chunk.type === "Text" ? chunk.data.replace(regex_double_quotes, '\\"') : `\${${chunk.manipulate()}}`;
    }).join("")}"`;
  }
};
var attribute_lookup = {
  allowfullscreen: { property_name: "allowFullscreen", applies_to: ["iframe"] },
  allowpaymentrequest: { property_name: "allowPaymentRequest", applies_to: ["iframe"] },
  async: { applies_to: ["script"] },
  autofocus: { applies_to: ["button", "input", "keygen", "select", "textarea"] },
  autoplay: { applies_to: ["audio", "video"] },
  checked: { applies_to: ["input"] },
  controls: { applies_to: ["audio", "video"] },
  default: { applies_to: ["track"] },
  defer: { applies_to: ["script"] },
  disabled: {
    applies_to: [
      "button",
      "fieldset",
      "input",
      "keygen",
      "optgroup",
      "option",
      "select",
      "textarea"
    ]
  },
  formnovalidate: { property_name: "formNoValidate", applies_to: ["button", "input"] },
  hidden: {},
  indeterminate: { applies_to: ["input"] },
  inert: {},
  ismap: { property_name: "isMap", applies_to: ["img"] },
  loop: { applies_to: ["audio", "bgsound", "video"] },
  multiple: { applies_to: ["input", "select"] },
  muted: { applies_to: ["audio", "video"] },
  nomodule: { property_name: "noModule", applies_to: ["script"] },
  novalidate: { property_name: "noValidate", applies_to: ["form"] },
  open: { applies_to: ["details", "dialog"] },
  playsinline: { property_name: "playsInline", applies_to: ["video"] },
  readonly: { property_name: "readOnly", applies_to: ["input", "textarea"] },
  required: { applies_to: ["input", "select", "textarea"] },
  reversed: { applies_to: ["ol"] },
  selected: { applies_to: ["option"] },
  value: {
    applies_to: [
      "button",
      "option",
      "input",
      "li",
      "meter",
      "progress",
      "param",
      "select",
      "textarea"
    ]
  }
};
Object.keys(attribute_lookup).forEach((name49) => {
  const metadata = attribute_lookup[name49];
  if (!metadata.property_name)
    metadata.property_name = name49;
});
function should_cache(attribute) {
  return attribute.is_src || attribute.is_srcset || attribute.node.should_cache();
}
var regex_contains_checked_or_group = /checked|group/;
function is_indirectly_bound_value(attribute) {
  const element = attribute.parent;
  return attribute.name === "value" && (element.node.name === "option" || // TODO check it's actually bound
  element.node.name === "input" && element.node.bindings.some(
    (binding) => regex_contains_checked_or_group.test(binding.name)
  ));
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Element/StyleAttribute.js
var StyleAttributeWrapper = class extends AttributeWrapper {
  /** @param {import('../../Block.js').default} block */
  render(block) {
    const style_props = optimize_style(this.node.chunks);
    if (!style_props)
      return super.render(block);
    style_props.forEach((prop) => {
      let value;
      if (is_dynamic2(prop.value)) {
        const prop_dependencies = /* @__PURE__ */ new Set();
        value = prop.value.map((chunk) => {
          if (chunk.type === "Text") {
            return string_literal(chunk.data);
          } else {
            add_to_set(prop_dependencies, chunk.dynamic_dependencies());
            return chunk.manipulate(block);
          }
        }).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
        if (prop_dependencies.size) {
          let condition = block.renderer.dirty(Array.from(prop_dependencies));
          if (block.has_outros) {
            condition = x`!#current || ${condition}`;
          }
          const update = b`
						if (${condition}) {
							@set_style(${this.parent.var}, "${prop.key}", ${value}, ${prop.important ? 1 : null});
						}`;
          block.chunks.update.push(update);
        }
      } else {
        value = string_literal(
          /** @type {import('../../../nodes/Text.js').default} */
          prop.value[0].data
        );
      }
      block.chunks.hydrate.push(
        b`@set_style(${this.parent.var}, "${prop.key}", ${value}, ${prop.important ? 1 : null});`
      );
    });
  }
};
var regex_style_prop_key = /^\s*([\w-]+):\s*/;
function optimize_style(value) {
  const props = [];
  let chunks = value.slice();
  while (chunks.length) {
    const chunk = chunks[0];
    if (chunk.type !== "Text")
      return null;
    const key_match = regex_style_prop_key.exec(chunk.data);
    if (!key_match)
      return null;
    const key = key_match[1];
    const offset2 = key_match.index + key_match[0].length;
    const remaining_data = chunk.data.slice(offset2);
    if (remaining_data) {
      chunks[0] = /** @type {import('../../../nodes/Text.js').default} */
      {
        start: chunk.start + offset2,
        end: chunk.end,
        type: "Text",
        data: remaining_data
      };
    } else {
      chunks.shift();
    }
    const result = get_style_value(chunks);
    props.push({ key, value: result.value, important: result.important });
    chunks = result.chunks;
  }
  return props;
}
var regex_important_flag = /\s*!important\s*$/;
var regex_semicolon_or_whitespace = /[;\s]/;
function get_style_value(chunks) {
  const value = [];
  let in_url = false;
  let quote_mark = null;
  let escaped2 = false;
  let closed = false;
  while (chunks.length && !closed) {
    const chunk = chunks.shift();
    if (chunk.type === "Text") {
      let c2 = 0;
      while (c2 < chunk.data.length) {
        const char = chunk.data[c2];
        if (escaped2) {
          escaped2 = false;
        } else if (char === "\\") {
          escaped2 = true;
        } else if (char === quote_mark) {
          quote_mark = null;
        } else if (char === '"' || char === "'") {
          quote_mark = char;
        } else if (char === ")" && in_url) {
          in_url = false;
        } else if (char === "u" && chunk.data.slice(c2, c2 + 4) === "url(") {
          in_url = true;
        } else if (char === ";" && !in_url && !quote_mark) {
          closed = true;
          break;
        }
        c2 += 1;
      }
      if (c2 > 0) {
        value.push(
          /** @type {import('../../../nodes/Text.js').default} */
          {
            type: "Text",
            start: chunk.start,
            end: chunk.start + c2,
            data: chunk.data.slice(0, c2)
          }
        );
      }
      while (regex_semicolon_or_whitespace.test(chunk.data[c2]))
        c2 += 1;
      const remaining_data = chunk.data.slice(c2);
      if (remaining_data) {
        chunks.unshift(
          /** @type {import('../../../nodes/Text.js').default} */
          {
            start: chunk.start + c2,
            end: chunk.end,
            type: "Text",
            data: remaining_data
          }
        );
        break;
      }
    } else {
      value.push(chunk);
    }
  }
  let important = false;
  const last_chunk = value[value.length - 1];
  if (last_chunk && last_chunk.type === "Text" && regex_important_flag.test(last_chunk.data)) {
    important = true;
    last_chunk.data = last_chunk.data.replace(regex_important_flag, "");
    if (!last_chunk.data)
      value.pop();
  }
  return {
    chunks,
    value,
    important
  };
}
function is_dynamic2(value) {
  return value.length > 1 || value[0].type !== "Text";
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Element/SpreadAttribute.js
var SpreadAttributeWrapper = class extends BaseAttributeWrapper {
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/mark_each_block_bindings.js
function mark_each_block_bindings(parent, binding) {
  binding.expression.references.forEach((name49) => {
    const each_block = parent.node.scope.get_owner(name49);
    if (each_block) {
      each_block.has_binding = true;
    }
  });
  if (binding.name === "group") {
    const add_index_binding = (name49) => {
      const each_block = parent.node.scope.get_owner(name49);
      if (each_block.type === "EachBlock") {
        each_block.has_index_binding = true;
        for (const dep of each_block.expression.contextual_dependencies) {
          add_index_binding(dep);
        }
      }
    };
    for (const name49 of binding.expression.contextual_dependencies) {
      add_index_binding(name49);
    }
  }
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Element/Binding.js
var BindingWrapper = class {
  /**
   * @param {import('../../Block.js').default} block
   * @param {import('../../../nodes/Binding.js').default} node
   * @param {import('./index.js').default | import('../InlineComponent/index.js').default} parent
   */
  constructor(block, node, parent) {
    /** @type {import('../../../nodes/Binding.js').default} */
    __publicField(this, "node");
    /** @type {import('./index.js').default | import('../InlineComponent/index.js').default} */
    __publicField(this, "parent");
    /** @type {string} */
    __publicField(this, "object");
    /**
     * @type {{
     * 		uses_context: boolean;
     * 		mutation: import('estree').Node | import('estree').Node[];
     * 		contextual_dependencies: Set<string>;
     * 		lhs?: import('estree').Node;
     * 	}}
     */
    __publicField(this, "handler");
    /** @type {import('estree').Node} */
    __publicField(this, "snippet");
    /** @type {boolean} */
    __publicField(this, "is_readonly");
    /** @type {boolean} */
    __publicField(this, "needs_lock");
    /** @type {import('../../Renderer.js').BindingGroup} */
    __publicField(this, "binding_group");
    this.node = node;
    this.parent = parent;
    const { dependencies } = this.node.expression;
    block.add_dependencies(dependencies);
    handle_select_value_binding(this, dependencies);
    if (node.is_contextual) {
      mark_each_block_bindings(this.parent, this.node);
    }
    this.object = get_object(this.node.expression.node).name;
    if (this.node.name === "group") {
      this.binding_group = get_binding_group(parent.renderer, this, block);
    }
    this.handler = get_event_handler(
      this,
      parent.renderer,
      block,
      this.object,
      this.node.raw_expression
    );
    this.snippet = this.node.expression.manipulate(block);
    this.is_readonly = this.node.is_readonly;
    this.needs_lock = this.node.name === "currentTime";
  }
  get_dependencies() {
    const dependencies = new Set(this.node.expression.dependencies);
    this.node.expression.dependencies.forEach((prop) => {
      const indirect_dependencies = this.parent.renderer.component.indirect_dependencies.get(prop);
      if (indirect_dependencies) {
        indirect_dependencies.forEach((indirect_dependency) => {
          dependencies.add(indirect_dependency);
        });
      }
    });
    if (this.binding_group) {
      this.binding_group.list_dependencies.forEach((dep) => dependencies.add(dep));
    }
    return dependencies;
  }
  get_update_dependencies() {
    const object = this.object;
    const dependencies = /* @__PURE__ */ new Set();
    if (this.node.expression.template_scope.names.has(object)) {
      this.node.expression.template_scope.dependencies_for_name.get(object).forEach((name49) => dependencies.add(name49));
    } else {
      dependencies.add(object);
    }
    const result = new Set(dependencies);
    dependencies.forEach((dependency) => {
      const indirect_dependencies = this.parent.renderer.component.indirect_dependencies.get(dependency);
      if (indirect_dependencies) {
        indirect_dependencies.forEach((indirect_dependency) => {
          result.add(indirect_dependency);
        });
      }
    });
    return result;
  }
  is_readonly_media_attribute() {
    return this.node.is_readonly_media_attribute();
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Identifier} lock
   */
  render(block, lock) {
    if (this.is_readonly)
      return;
    const { parent } = this;
    const update_conditions = this.needs_lock ? [x`!${lock}`] : [];
    const mount_conditions = [];
    let update_or_condition = null;
    const dependency_array = Array.from(this.get_dependencies());
    if (dependency_array.length > 0) {
      update_conditions.push(block.renderer.dirty(dependency_array));
    }
    if (parent.node.name === "input") {
      const type = parent.node.get_static_attribute_value("type");
      if (type === null || type === "" || type === "text" || type === "email" || type === "password" || type === "search" || type === "url") {
        update_conditions.push(x`${parent.var}.${this.node.name} !== ${this.snippet}`);
      } else if (type === "number") {
        update_conditions.push(x`@to_number(${parent.var}.${this.node.name}) !== ${this.snippet}`);
      }
    }
    let update_dom = get_dom_updater(parent, this, false);
    let mount_dom = get_dom_updater(parent, this, true);
    switch (this.node.name) {
      case "group": {
        block.renderer.add_to_context("$$binding_groups");
        this.binding_group.add_element(block, this.parent.var);
        if (
          /** @type {import('./index.js').default} */
          this.parent.has_dynamic_value
        ) {
          update_or_condition = /** @type {import('./index.js').default} */
          this.parent.dynamic_value_condition;
        }
        break;
      }
      case "textContent":
        update_conditions.push(x`${this.snippet} !== ${parent.var}.textContent`);
        mount_conditions.push(x`${this.snippet} !== void 0`);
        break;
      case "innerText":
        update_conditions.push(x`${this.snippet} !== ${parent.var}.innerText`);
        mount_conditions.push(x`${this.snippet} !== void 0`);
        break;
      case "innerHTML":
        update_conditions.push(x`${this.snippet} !== ${parent.var}.innerHTML`);
        mount_conditions.push(x`${this.snippet} !== void 0`);
        break;
      case "currentTime":
        update_conditions.push(x`!@_isNaN(${this.snippet})`);
        mount_dom = null;
        break;
      case "playbackRate":
      case "volume":
        update_conditions.push(x`!@_isNaN(${this.snippet})`);
        mount_conditions.push(x`!@_isNaN(${this.snippet})`);
        break;
      case "paused": {
        const last = block.get_unique_name(`${parent.var.name}_is_paused`);
        block.add_variable(last, x`true`);
        update_conditions.push(x`${last} !== (${last} = ${this.snippet})`);
        update_dom = b`${parent.var}[${last} ? "pause" : "play"]();`;
        mount_dom = null;
        break;
      }
      case "value":
        if (parent.node.get_static_attribute_value("type") === "file") {
          update_dom = null;
          mount_dom = null;
        }
    }
    if (update_dom) {
      if (update_conditions.length > 0) {
        let condition = update_conditions.reduce((lhs, rhs) => x`${lhs} && ${rhs}`);
        if (update_or_condition)
          condition = x`${update_or_condition} || (${condition})`;
        block.chunks.update.push(b`
					if (${condition}) {
						${update_dom}
					}
				`);
      } else {
        block.chunks.update.push(update_dom);
      }
    }
    if (mount_dom) {
      if (mount_conditions.length > 0) {
        const condition = mount_conditions.reduce((lhs, rhs) => x`${lhs} && ${rhs}`);
        block.chunks.mount.push(b`
					if (${condition}) {
						${mount_dom}
					}
				`);
      } else {
        block.chunks.mount.push(mount_dom);
      }
    }
  }
};
function get_dom_updater(element, binding, mounting) {
  const { node } = element;
  if (binding.is_readonly_media_attribute()) {
    return null;
  }
  if (binding.node.name === "this") {
    return null;
  }
  if (node.name === "select") {
    return node.get_static_attribute_value("multiple") === true ? b`@select_options(${element.var}, ${binding.snippet})` : mounting ? b`@select_option(${element.var}, ${binding.snippet}, true)` : b`@select_option(${element.var}, ${binding.snippet})`;
  }
  if (binding.node.name === "group") {
    const type = node.get_static_attribute_value("type");
    const condition = type === "checkbox" ? x`~(${binding.snippet} || []).indexOf(${element.var}.__value)` : x`${element.var}.__value === ${binding.snippet}`;
    return b`${element.var}.checked = ${condition};`;
  }
  if (binding.node.name === "value") {
    return b`@set_input_value(${element.var}, ${binding.snippet});`;
  }
  return b`${element.var}.${binding.node.name} = ${binding.snippet};`;
}
function get_binding_group(renderer, binding, block) {
  const value = binding.node;
  const { parts } = flatten_reference(value.raw_expression);
  let keypath = parts.join(".");
  const contexts = [];
  const contextual_dependencies = /* @__PURE__ */ new Set();
  const { template_scope } = value.expression;
  const add_contextual_dependency = (dep) => {
    contextual_dependencies.add(dep);
    const owner = template_scope.get_owner(dep);
    if (owner.type === "EachBlock") {
      for (const dep2 of owner.expression.contextual_dependencies) {
        add_contextual_dependency(dep2);
      }
    }
  };
  for (const dep of value.expression.contextual_dependencies) {
    add_contextual_dependency(dep);
  }
  for (const dep of contextual_dependencies) {
    const context = block.bindings.get(dep);
    let key;
    let name49;
    if (context) {
      key = context.object.name;
      name49 = context.property.name;
    } else {
      key = dep;
      name49 = dep;
    }
    keypath = `${key}@${keypath}`;
    contexts.push(name49);
  }
  if (!renderer.binding_groups.has(keypath)) {
    const index = renderer.binding_groups.size;
    const list_dependencies = /* @__PURE__ */ new Set();
    let parent = value.parent;
    while (parent) {
      if (parent.type === "EachBlock") {
        for (const dep of parent.expression.dynamic_dependencies()) {
          list_dependencies.add(dep);
        }
      }
      parent = parent.parent;
    }
    const elements = /* @__PURE__ */ new Map();
    contexts.forEach((context) => {
      renderer.add_to_context(context, true);
    });
    renderer.binding_groups.set(keypath, {
      binding_group: () => {
        let obj = x`$$binding_groups[${index}]`;
        if (contexts.length > 0) {
          contexts.forEach((secondary_index) => {
            obj = x`${obj}[${secondary_index}]`;
          });
        }
        return obj;
      },
      contexts,
      list_dependencies,
      keypath,
      add_element(block2, element) {
        if (!elements.has(block2)) {
          elements.set(block2, []);
        }
        elements.get(block2).push(element);
      },
      render(block2) {
        const local_name = block2.get_unique_name("binding_group");
        const binding_group2 = block2.renderer.reference("$$binding_groups");
        block2.add_variable(local_name);
        if (contexts.length > 0) {
          const indexes = {
            type: "ArrayExpression",
            elements: contexts.map((name49) => block2.renderer.reference(name49))
          };
          block2.chunks.init.push(
            b`${local_name} = @init_binding_group_dynamic(${binding_group2}[${index}], ${indexes})`
          );
          block2.chunks.update.push(
            b`if (${block2.renderer.dirty(
              Array.from(list_dependencies)
            )}) ${local_name}.u(${indexes})`
          );
        } else {
          block2.chunks.init.push(
            b`${local_name} = @init_binding_group(${binding_group2}[${index}])`
          );
        }
        block2.chunks.hydrate.push(b`${local_name}.p(${elements.get(block2)})`);
        block2.chunks.destroy.push(b`${local_name}.r()`);
      }
    });
  }
  const binding_group = renderer.binding_groups.get(keypath);
  block.binding_groups.add(binding_group);
  return binding_group;
}
function get_event_handler(binding, renderer, block, name49, lhs) {
  const contextual_dependencies = new Set(binding.node.expression.contextual_dependencies);
  const context = block.bindings.get(name49);
  let set_store;
  if (context) {
    const { object, property: property2, store, snippet } = context;
    lhs = replace_object(lhs, snippet);
    contextual_dependencies.add(object.name);
    contextual_dependencies.add(property2.name);
    contextual_dependencies.delete(name49);
    if (store) {
      set_store = b`${store}.set(${`$${store}`});`;
    }
  } else {
    const object = get_object(lhs);
    if (object.name[0] === "$") {
      const store = object.name.slice(1);
      set_store = b`${store}.set(${object.name});`;
    }
  }
  const value = get_value_from_dom(renderer, binding.parent, binding, contextual_dependencies);
  const mutation = b`
		${lhs} = ${value};
		${set_store}
	`;
  return {
    uses_context: binding.node.is_contextual || binding.node.expression.uses_context,
    mutation,
    contextual_dependencies,
    lhs
  };
}
function get_value_from_dom(_renderer, element, binding, contextual_dependencies) {
  const { node } = element;
  const { name: name49 } = binding.node;
  if (name49 === "this") {
    return x`$$value`;
  }
  if (regex_box_size.test(name49)) {
    return x`@ResizeObserverSingleton.entries.get(this)?.${name49}`;
  }
  if (node.name === "select") {
    return node.get_static_attribute_value("multiple") === true ? x`@select_multiple_value(this)` : x`@select_value(this)`;
  }
  const type = node.get_static_attribute_value("type");
  if (name49 === "group") {
    if (type === "checkbox") {
      const { binding_group, contexts } = binding.binding_group;
      add_to_set(contextual_dependencies, contexts);
      return x`@get_binding_group_value(${binding_group()}, this.__value, this.checked)`;
    }
    return x`this.__value`;
  }
  if (type === "range" || type === "number") {
    return x`@to_number(this.${name49})`;
  }
  if (name49 === "buffered" || name49 === "seekable" || name49 === "played") {
    return x`@time_ranges_to_array(this.${name49})`;
  }
  return x`this.${name49}`;
}

// node_modules/svelte/src/compiler/compile/utils/compare_node.js
function compare_node(a, b2) {
  if (a === b2)
    return true;
  if (!a || !b2)
    return false;
  if (a.type !== b2.type)
    return false;
  switch (a.type) {
    case "Identifier":
      return a.name === /** @type {import('estree').Identifier} */
      b2.name;
    case "MemberExpression":
      return compare_node(
        a.object,
        /** @type {import('estree').MemberExpression} */
        b2.object
      ) && compare_node(
        a.property,
        /** @type {import('estree').MemberExpression} */
        b2.property
      ) && a.computed === /** @type {import('estree').MemberExpression} */
      b2.computed;
    case "Literal":
      return a.value === /** @type {import('estree').Literal} */
      b2.value;
  }
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/bind_this.js
function bind_this(component, block, binding, variable) {
  const fn = component.get_unique_name(`${variable.name}_binding`);
  block.renderer.add_to_context(fn.name);
  const callee = block.renderer.reference(fn.name);
  const { contextual_dependencies, mutation } = binding.handler;
  const dependencies = binding.get_update_dependencies();
  const body = b`
		${mutation}
		${Array.from(dependencies).filter((dep) => dep[0] !== "$").filter((dep) => !contextual_dependencies.has(dep)).map((dep) => b`${block.renderer.invalidate(dep)};`)}
	`;
  if (contextual_dependencies.size) {
    const params = Array.from(contextual_dependencies).map((name49) => ({
      type: "Identifier",
      name: name49
    }));
    component.partly_hoisted.push(b`
			function ${fn}($$value, ${params}) {
				@binding_callbacks[$$value ? 'unshift' : 'push'](() => {
					${body}
				});
			}
		`);
    const alias_map = /* @__PURE__ */ new Map();
    const args = [];
    for (let id2 of params) {
      const value = block.renderer.reference(id2.name);
      let found = false;
      if (block.variables.has(id2.name)) {
        let alias = id2.name;
        for (let i = 1; block.variables.has(alias) && !compare_node(block.variables.get(alias).init, value); alias = `${id2.name}_${i++}`)
          ;
        alias_map.set(alias, id2.name);
        id2 = { type: "Identifier", name: alias };
        found = block.variables.has(alias);
      }
      args.push(id2);
      if (!found) {
        block.add_variable(id2, value);
      }
    }
    const assign = block.get_unique_name(`assign_${variable.name}`);
    const unassign = block.get_unique_name(`unassign_${variable.name}`);
    block.chunks.init.push(b`
			const ${assign} = () => ${callee}(${variable}, ${args});
			const ${unassign} = () => ${callee}(null, ${args});
		`);
    const condition = Array.from(args).map(
      (name49) => x`${name49} !== ${block.renderer.reference(alias_map.get(name49.name) || name49.name)}`
    ).reduce((lhs, rhs) => x`${lhs} || ${rhs}`);
    block.chunks.update.push(b`
			if (${condition}) {
				${unassign}();
				${args.map((a) => b`${a} = ${block.renderer.reference(alias_map.get(a.name) || a.name)}`)};
				${assign}();
			}`);
    block.chunks.destroy.push(b`${unassign}();`);
    return b`${assign}();`;
  }
  component.partly_hoisted.push(b`
		function ${fn}($$value) {
			@binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				${body}
			});
		}
	`);
  block.chunks.destroy.push(b`${callee}(null);`);
  return b`${callee}(${variable});`;
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/Tag.js
var Tag2 = class extends Wrapper {
  /**
   * @param {import('../../Renderer.js').default} renderer
   * @param {import('../../Block.js').default} block
   * @param {import('./Wrapper.js').default} parent
   * @param {NodeType} node
   */
  constructor(renderer, block, parent, node) {
    super(renderer, block, parent, node);
    block.add_dependencies(node.expression.dependencies);
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {(value: import('estree').Node) => import('estree').Node | import('estree').Node[]} update
   */
  rename_this_method(block, update) {
    const dependencies = this.node.expression.dynamic_dependencies();
    let snippet = this.node.expression.manipulate(block);
    const value = this.node.should_cache && block.get_unique_name(`${this.var.name}_value`);
    const content = this.node.should_cache ? value : snippet;
    snippet = x`${snippet} + ""`;
    if (this.node.should_cache)
      block.add_variable(value, snippet);
    if (dependencies.length > 0) {
      let condition = block.renderer.dirty(dependencies);
      if (block.has_outros) {
        condition = x`!#current || ${condition}`;
      }
      const update_cached_value = x`${value} !== (${value} = ${snippet})`;
      if (this.node.should_cache) {
        condition = x`${condition} && ${update_cached_value}`;
      }
      block.chunks.update.push(
        b`if (${condition}) ${update(
          /** @type {import('estree').Node} */
          content
        )}`
      );
    }
    return { init: content };
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/MustacheTag.js
var MustacheTagWrapper = class extends Tag2 {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/MustacheTag.js').default | import('../../nodes/RawMustacheTag.js').default} node
   */
  constructor(renderer, block, parent, node) {
    super(renderer, block, parent, node);
    /** @type {import('estree').Identifier} */
    __publicField(this, "var", { type: "Identifier", name: "t" });
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   * @param {Record<string, unknown> | undefined} data
   */
  render(block, parent_node, parent_nodes, data2) {
    const contenteditable_attributes = this.parent instanceof ElementWrapper && this.parent.attributes.filter((a) => a.node.name === "contenteditable");
    const spread_attributes = this.parent instanceof ElementWrapper && this.parent.attributes.filter((a) => a.node.is_spread);
    let contenteditable_attr_value = void 0;
    if (contenteditable_attributes.length > 0) {
      const attribute = (
        /** @type {import('./Element/Attribute.js').default} */
        contenteditable_attributes[0]
      );
      if ([true, "true", ""].includes(attribute.node.get_static_value())) {
        contenteditable_attr_value = true;
      } else {
        contenteditable_attr_value = x`${attribute.get_value(block)}`;
      }
    } else if (spread_attributes.length > 0 && data2.element_data_name) {
      contenteditable_attr_value = x`${data2.element_data_name}['contenteditable']`;
    }
    const { init } = this.rename_this_method(block, (value) => {
      if (contenteditable_attr_value) {
        if (contenteditable_attr_value === true) {
          return x`@set_data_contenteditable(${this.var}, ${value})`;
        } else {
          return x`@set_data_maybe_contenteditable(${this.var}, ${value}, ${contenteditable_attr_value})`;
        }
      } else {
        return x`@set_data(${this.var}, ${value})`;
      }
    });
    block.add_element(
      this.var,
      x`@text(${init})`,
      parent_nodes && x`@claim_text(${parent_nodes}, ${init})`,
      parent_node
    );
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/RawMustacheTag.js
var RawMustacheTagWrapper = class extends Tag2 {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/MustacheTag.js').default | import('../../nodes/RawMustacheTag.js').default} node
   */
  constructor(renderer, block, parent, node) {
    super(renderer, block, parent, node);
    /** @type {import('estree').Identifier} */
    __publicField(this, "var", { type: "Identifier", name: "raw" });
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} _parent_nodes
   */
  render(block, parent_node, _parent_nodes) {
    const in_head = is_head(parent_node);
    const can_use_innerhtml = !in_head && parent_node && !this.prev && !this.next;
    if (can_use_innerhtml && !this.renderer.options.hydratable) {
      const insert = (content) => b`${parent_node}.innerHTML = ${content};`[0];
      const { init } = this.rename_this_method(block, (content) => insert(content));
      block.chunks.mount.push(insert(init));
    } else {
      const needs_anchor = in_head || (this.next ? !this.next.is_dom_node() : !this.parent || !this.parent.is_dom_node());
      const html_tag = block.get_unique_name("html_tag");
      const html_anchor = needs_anchor && block.get_unique_name("html_anchor");
      block.add_variable(html_tag);
      const { init } = this.rename_this_method(block, (content) => x`${html_tag}.p(${content})`);
      const update_anchor = needs_anchor ? html_anchor : this.next ? this.next.var : "null";
      const parent_element = (
        /** @type {import('../../nodes/Element.js').default} */
        this.node.find_nearest(/^Element/)
      );
      const is_svg2 = parent_element && parent_element.namespace === namespaces.svg;
      block.chunks.create.push(b`${html_tag} = new @HtmlTag(${is_svg2 ? "true" : "false"});`);
      if (this.renderer.options.hydratable) {
        block.chunks.claim.push(
          b`${html_tag} = @claim_html_tag(${_parent_nodes}, ${is_svg2 ? "true" : "false"});`
        );
      }
      block.chunks.hydrate.push(b`${html_tag}.a = ${update_anchor};`);
      block.chunks.mount.push(
        b`${html_tag}.m(${init}, ${parent_node || "#target"}, ${parent_node ? null : "#anchor"});`
      );
      if (needs_anchor) {
        block.add_element(html_anchor, x`@empty()`, x`@empty()`, parent_node);
      }
      if (!parent_node || in_head) {
        block.chunks.destroy.push(b`if (detaching) ${html_tag}.d();`);
      }
    }
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Comment.js
var CommentWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/Comment.js').default} node
   */
  constructor(renderer, block, parent, node) {
    super(renderer, block, parent, node);
    this.var = /** @type {import('estree').Identifier} */
    x`c`;
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    if (!this.renderer.options.preserveComments)
      return;
    const string_literal2 = {
      type: "Literal",
      value: this.node.data,
      loc: {
        start: this.renderer.locate(this.node.start),
        end: this.renderer.locate(this.node.end)
      }
    };
    block.add_element(
      this.var,
      x`@comment(${string_literal2})`,
      parent_nodes && x`@claim_comment(${parent_nodes}, ${string_literal2})`,
      parent_node
    );
  }
  text() {
    if (!this.renderer.options.preserveComments)
      return "";
    return `<!--${this.node.data}-->`;
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Element/index.js
var regex_contains_radio_or_checkbox_or_file = /radio|checkbox|file/;
var regex_contains_radio_or_checkbox_or_range_or_file = /radio|checkbox|range|file/;
var events = [
  {
    event_names: ["input"],
    filter: (node, _name) => node.name === "textarea" || node.name === "input" && !regex_contains_radio_or_checkbox_or_range_or_file.test(
      /** @type {string} */
      node.get_static_attribute_value("type")
    )
  },
  {
    event_names: ["input"],
    filter: (node, name49) => is_name_contenteditable(name49) && has_contenteditable_attr(node)
  },
  {
    event_names: ["change"],
    filter: (node, _name) => node.name === "select" || node.name === "input" && regex_contains_radio_or_checkbox_or_file.test(
      /** @type {string} */
      node.get_static_attribute_value("type")
    )
  },
  {
    event_names: ["change", "input"],
    filter: (node, _name) => node.name === "input" && node.get_static_attribute_value("type") === "range"
  },
  // resize events
  {
    event_names: ["elementresize"],
    filter: (_node, name49) => regex_dimensions.test(name49)
  },
  {
    event_names: ["elementresizecontentbox"],
    filter: (_node, name49) => regex_content_rect.test(name49) ?? regex_content_box_size.test(name49)
  },
  {
    event_names: ["elementresizeborderbox"],
    filter: (_node, name49) => regex_border_box_size.test(name49)
  },
  {
    event_names: ["elementresizedevicepixelcontentbox"],
    filter: (_node, name49) => regex_device_pixel_content_box_size.test(name49)
  },
  // media events
  {
    event_names: ["timeupdate"],
    filter: (node, name49) => node.is_media_node() && (name49 === "currentTime" || name49 === "played" || name49 === "ended")
  },
  {
    event_names: ["durationchange"],
    filter: (node, name49) => node.is_media_node() && name49 === "duration"
  },
  {
    event_names: ["play", "pause"],
    filter: (node, name49) => node.is_media_node() && name49 === "paused"
  },
  {
    event_names: ["progress"],
    filter: (node, name49) => node.is_media_node() && name49 === "buffered"
  },
  {
    event_names: ["loadedmetadata"],
    filter: (node, name49) => node.is_media_node() && (name49 === "buffered" || name49 === "seekable")
  },
  {
    event_names: ["volumechange"],
    filter: (node, name49) => node.is_media_node() && (name49 === "volume" || name49 === "muted")
  },
  {
    event_names: ["ratechange"],
    filter: (node, name49) => node.is_media_node() && name49 === "playbackRate"
  },
  {
    event_names: ["seeking", "seeked"],
    filter: (node, name49) => node.is_media_node() && name49 === "seeking"
  },
  {
    event_names: ["ended"],
    filter: (node, name49) => node.is_media_node() && name49 === "ended"
  },
  {
    event_names: ["resize"],
    filter: (node, name49) => node.is_media_node() && (name49 === "videoHeight" || name49 === "videoWidth")
  },
  {
    // from https://html.spec.whatwg.org/multipage/media.html#ready-states
    // and https://html.spec.whatwg.org/multipage/media.html#loading-the-media-resource
    event_names: [
      "loadedmetadata",
      "loadeddata",
      "canplay",
      "canplaythrough",
      "playing",
      "waiting",
      "emptied"
    ],
    filter: (node, name49) => node.is_media_node() && name49 === "readyState"
  },
  // details event
  {
    event_names: ["toggle"],
    filter: (node, _name) => node.name === "details"
  },
  {
    event_names: ["load"],
    filter: (_, name49) => name49 === "naturalHeight" || name49 === "naturalWidth"
  }
];
var CHILD_DYNAMIC_ELEMENT_BLOCK = "child_dynamic_element";
var regex_invalid_variable_identifier_characters3 = /[^a-zA-Z0-9_$]/g;
var regex_minus_signs = /-/g;
var ElementWrapper = class _ElementWrapper extends Wrapper {
  /**
   * @param {import('../../Renderer.js').default} renderer
   * @param {import('../../Block.js').default} block
   * @param {import('../shared/Wrapper.js').default} parent
   * @param {import('../../../nodes/Element.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('../shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @type {import('../Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {Array<AttributeWrapper | import('./StyleAttribute.js').default | import('./SpreadAttribute.js').default>} */
    __publicField(this, "attributes");
    /** @type {import('./Binding.js').default[]} */
    __publicField(this, "bindings");
    /** @type {import('./EventHandler.js').default[]} */
    __publicField(this, "event_handlers");
    /** @type {string[]} */
    __publicField(this, "class_dependencies");
    /** @type {Set<string>} */
    __publicField(this, "dynamic_style_dependencies");
    /** @type {boolean} */
    __publicField(this, "has_dynamic_attribute");
    /** @type {Set<string>} */
    __publicField(this, "select_binding_dependencies");
    /** @type {boolean} */
    __publicField(this, "has_dynamic_value");
    /** @type {any} */
    __publicField(this, "dynamic_value_condition");
    /** @type {any} */
    __publicField(this, "var");
    /** @type {boolean} */
    __publicField(this, "void");
    /** @type {import('../../Block.js').default} */
    __publicField(this, "child_dynamic_element_block", null);
    /** @type {ElementWrapper} */
    __publicField(this, "child_dynamic_element", null);
    /** */
    __publicField(this, "element_data_name", null);
    this.var = {
      type: "Identifier",
      name: node.name.replace(regex_invalid_variable_identifier_characters3, "_")
    };
    this.void = is_void(node.name);
    this.class_dependencies = [];
    if (node.is_dynamic_element && block.type !== CHILD_DYNAMIC_ELEMENT_BLOCK) {
      this.child_dynamic_element_block = block.child({
        comment: create_debugging_comment(node, renderer.component),
        name: renderer.component.get_unique_name("create_dynamic_element"),
        type: CHILD_DYNAMIC_ELEMENT_BLOCK
      });
      renderer.blocks.push(this.child_dynamic_element_block);
      this.child_dynamic_element = new _ElementWrapper(
        renderer,
        this.child_dynamic_element_block,
        parent,
        node,
        strip_whitespace,
        next_sibling
      );
      if (node.intro)
        block.add_intro(node.intro.is_local);
      if (node.outro)
        block.add_outro(node.outro.is_local);
      return;
    }
    this.dynamic_style_dependencies = /* @__PURE__ */ new Set();
    if (this.node.children.length) {
      this.node.lets.forEach((l) => {
        extract_names(l.value || l.name).forEach((name49) => {
          renderer.add_to_context(name49, true);
        });
      });
    }
    this.attributes = this.node.attributes.map((attribute) => {
      if (attribute.name === "style") {
        return new StyleAttributeWrapper(this, block, attribute);
      }
      if (attribute.type === "Spread") {
        return new SpreadAttributeWrapper(this, block, attribute);
      }
      return new AttributeWrapper(this, block, attribute);
    });
    this.has_dynamic_attribute = !!this.attributes.find(
      (attr) => attr.node.get_dependencies().length > 0
    );
    this.bindings = this.node.bindings.map((binding) => new BindingWrapper(block, binding, this));
    this.event_handlers = this.node.handlers.map(
      (event_handler) => new EventHandlerWrapper(event_handler, this)
    );
    if (node.intro)
      block.add_intro(node.intro.is_local);
    if (node.outro)
      block.add_outro(node.outro.is_local);
    if (node.animation) {
      block.add_animation();
    }
    block.add_dependencies(node.tag_expr.dependencies);
    [node.animation, node.outro, ...node.actions, ...node.classes, ...node.styles].forEach(
      (directive) => {
        if (directive && directive.expression) {
          block.add_dependencies(directive.expression.dependencies);
        }
      }
    );
    node.handlers.forEach((handler) => {
      if (handler.expression) {
        block.add_dependencies(handler.expression.dependencies);
      }
    });
    this.fragment = new FragmentWrapper(
      renderer,
      block,
      node.children,
      this,
      strip_whitespace,
      next_sibling
    );
    this.element_data_name = block.get_unique_name(`${this.var.name}_data`);
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    if (this.child_dynamic_element) {
      this.render_dynamic_element(block, parent_node, parent_nodes);
    } else {
      this.render_element(block, parent_node, parent_nodes);
    }
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render_dynamic_element(block, parent_node, parent_nodes) {
    this.child_dynamic_element.render(
      this.child_dynamic_element_block,
      null,
      /** @type {unknown} */
      /** @type {import('estree').Identifier} */
      x`#nodes`
    );
    const is_tag_dynamic = this.node.tag_expr.dynamic_dependencies().length > 0;
    const tag2 = this.node.tag_expr.manipulate(block);
    block.chunks.init.push(b`
			${this.renderer.options.dev && b`@validate_dynamic_element(${tag2});`}
			${this.renderer.options.dev && this.node.children.length > 0 && b`@validate_void_dynamic_element(${tag2});`}
			let ${this.var} = ${tag2} && ${this.child_dynamic_element_block.name}(#ctx);
		`);
    block.chunks.create.push(b`
			if (${this.var}) ${this.var}.c();
		`);
    if (this.renderer.options.hydratable) {
      block.chunks.claim.push(b`
				if (${this.var}) ${this.var}.l(${parent_nodes});
			`);
    }
    block.chunks.mount.push(b`
			if (${this.var}) ${this.var}.m(${parent_node || "#target"}, ${parent_node ? "null" : "#anchor"});
		`);
    if (is_tag_dynamic) {
      const previous_tag = block.get_unique_name("previous_tag");
      block.add_variable(previous_tag, tag2);
      const anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
      const has_transitions = !!(this.node.intro || this.node.outro);
      const not_equal = this.renderer.component.component_options.immutable ? x`@not_equal` : x`@safe_not_equal`;
      const tag_will_be_removed = block.get_unique_name("tag_will_be_removed");
      if (has_transitions) {
        block.add_variable(tag_will_be_removed, x`false`);
      }
      block.chunks.update.push(b`
				if (${tag2}) {
					if (!${previous_tag}) {
						${this.var} = ${this.child_dynamic_element_block.name}(#ctx);
						${previous_tag} = ${tag2};
						${this.var}.c();
						${has_transitions && b`@transition_in(${this.var})`}
						${this.var}.m(${this.get_update_mount_node(anchor)}, ${anchor});
					} else if (${not_equal}(${previous_tag}, ${tag2})) {
						${this.var}.d(1);
						${this.renderer.options.dev && b`@validate_dynamic_element(${tag2});`}
						${this.renderer.options.dev && this.node.children.length > 0 && b`@validate_void_dynamic_element(${tag2});`}
						${this.var} = ${this.child_dynamic_element_block.name}(#ctx);
						${previous_tag} = ${tag2};
						${this.var}.c();
						${has_transitions && b`if (${tag_will_be_removed}) {
							${tag_will_be_removed} = false;
							@transition_in(${this.var})
						}`}
						${this.var}.m(${this.get_update_mount_node(anchor)}, ${anchor});
					} else {
						${has_transitions && b`if (${tag_will_be_removed}) {
							${tag_will_be_removed} = false;
							@transition_in(${this.var})
						}`}
						${this.var}.p(#ctx, #dirty);
					}
				} else if (${previous_tag}) {
					${has_transitions ? b`
								${tag_will_be_removed} = true;
								@group_outros();
								@transition_out(${this.var}, 1, 1, () => {
									${this.var} = null;
									${previous_tag} = ${tag2};
									${tag_will_be_removed} = false;
								});
								@check_outros();
							` : b`
								${this.var}.d(1);
								${this.var} = null;
								${previous_tag} = ${tag2};
							`}
				}
			`);
    } else {
      block.chunks.update.push(b`
				if (${tag2}) {
					${this.var}.p(#ctx, #dirty);
				}
			`);
    }
    if (this.child_dynamic_element_block.has_intros) {
      block.chunks.intro.push(b`@transition_in(${this.var}, #local);`);
    }
    if (this.child_dynamic_element_block.has_outros) {
      block.chunks.outro.push(b`@transition_out(${this.var}, #local);`);
    }
    block.chunks.destroy.push(b`if (${this.var}) ${this.var}.d(detaching)`);
    if (this.node.animation) {
      const measurements = block.get_unique_name("measurements");
      block.add_variable(measurements);
      block.chunks.measure.push(b`${measurements} = ${this.var}.r()`);
      block.chunks.fix.push(b`${this.var}.f();`);
      block.chunks.animate.push(b`
				${this.var}.s(${measurements});
				${this.var}.a()
			`);
    }
  }
  is_dom_node() {
    return super.is_dom_node() && !this.child_dynamic_element;
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render_element(block, parent_node, parent_nodes) {
    const { renderer } = this;
    const hydratable = renderer.options.hydratable;
    if (this.node.name === "noscript")
      return;
    const node = this.var;
    const nodes = parent_nodes && block.get_unique_name(`${this.var.name}_nodes`);
    const children = x`@children(${this.node.name === "template" ? x`${node}.content` : node})`;
    block.add_variable(node);
    const render_statement = this.get_render_statement(block);
    block.chunks.create.push(b`${node} = ${render_statement};`);
    const { can_use_textcontent, can_optimise_to_html_string, can_optimise_hydration } = this.node;
    if (hydratable) {
      if (parent_nodes) {
        block.chunks.claim.push(b`
					${node} = ${this.get_claim_statement(block, parent_nodes, can_optimise_hydration)};
				`);
        if (!can_optimise_hydration && !this.void && this.node.children.length > 0) {
          block.chunks.claim.push(b`
						var ${nodes} = ${children};
					`);
        }
      } else {
        block.chunks.claim.push(b`${node} = ${render_statement};`);
      }
    }
    if (parent_node) {
      const append = b`@append(${parent_node}, ${node});`;
      /** @type {import('estree').ExpressionStatement} */
      append[0].expression.callee.loc = {
        start: this.renderer.locate(this.node.start),
        end: this.renderer.locate(this.node.end)
      };
      block.chunks.mount.push(append);
      if (is_head(parent_node)) {
        block.chunks.destroy.push(b`@detach(${node});`);
      }
    } else {
      const insert = b`@insert(#target, ${node}, #anchor);`;
      /** @type {import('estree').ExpressionStatement} */
      insert[0].expression.callee.loc = {
        start: this.renderer.locate(this.node.start),
        end: this.renderer.locate(this.node.end)
      };
      block.chunks.mount.push(insert);
      block.chunks.destroy.push(b`if (detaching) @detach(${node});`);
    }
    if (can_optimise_to_html_string && (!hydratable || can_optimise_hydration)) {
      if (this.fragment.nodes.length === 1 && this.fragment.nodes[0].node.type === "Text") {
        let text2 = string_literal(
          /** @type {import('../Text.js').default} */
          this.fragment.nodes[0].data
        );
        if (hydratable) {
          const variable = block.get_unique_name("textContent");
          block.add_variable(variable, text2);
          text2 = variable;
        }
        block.chunks.create.push(b`${node}.textContent = ${text2};`);
        if (hydratable) {
          block.chunks.claim.push(
            b`if (@get_svelte_dataset(${node}) !== "${this.node.hash()}") ${node}.textContent = ${text2};`
          );
        }
      } else {
        const state = {
          quasi: {
            type: "TemplateElement",
            value: { raw: "" }
          }
        };
        let literal2 = {
          type: "TemplateLiteral",
          expressions: [],
          quasis: []
        };
        const can_use_raw_text = !this.node.can_use_innerhtml && can_use_textcontent;
        to_html(
          /** @type {unknown} */
          /** @type {Array<ElementWrapper | import('../Comment.js').default | import('../Text.js').default>} */
          this.fragment.nodes,
          block,
          literal2,
          state,
          can_use_raw_text
        );
        literal2.quasis.push(
          /** @type {any} */
          state.quasi
        );
        if (hydratable) {
          const variable = block.get_unique_name("textContent");
          block.add_variable(variable, literal2);
          literal2 = variable;
        }
        const property2 = this.node.can_use_innerhtml ? "innerHTML" : "textContent";
        block.chunks.create.push(b`${node}.${property2} = ${literal2};`);
        if (hydratable) {
          block.chunks.claim.push(
            b`if (@get_svelte_dataset(${node}) !== "${this.node.hash()}") ${node}.${property2} = ${literal2};`
          );
        }
      }
    } else {
      this.fragment.nodes.forEach((child) => {
        child.render(block, this.node.name === "template" ? x`${node}.content` : node, nodes, {
          element_data_name: this.element_data_name
        });
      });
    }
    const event_handler_or_binding_uses_context = this.bindings.some((binding) => binding.handler.uses_context) || this.node.handlers.some((handler) => handler.uses_context) || this.node.actions.some((action) => action.uses_context);
    if (event_handler_or_binding_uses_context) {
      block.maintain_context = true;
    }
    if (this.node.is_dynamic_element) {
      this.add_dynamic_element_attributes(block);
    } else {
      this.add_attributes(block);
    }
    this.add_directives_in_order(block);
    this.add_transitions(block);
    this.add_animation(block);
    this.add_classes(block);
    this.add_styles(block);
    this.add_manual_style_scoping(block);
    if (nodes && hydratable && !this.void && !can_optimise_hydration) {
      block.chunks.claim.push(
        b`${this.node.children.length > 0 ? nodes : children}.forEach(@detach);`
      );
    }
    if (renderer.options.dev) {
      const loc = renderer.meta_locate(this.node.start);
      block.chunks.hydrate.push(
        b`@add_location(${this.var}, ${renderer.file_var}, ${loc.line - 1}, ${loc.column}, ${// TODO this.node.start isn't correct if there's a source map. But since we don't know how the
        // original source file looked, there's not much we can do.
        this.node.start});`
      );
    }
    block.renderer.dirty(this.node.tag_expr.dynamic_dependencies());
  }
  /** @param {import('../../Block.js').default} block */
  get_render_statement(block) {
    const { name: name49, namespace, tag_expr } = this.node;
    const reference = tag_expr.manipulate(block);
    if (namespace === namespaces.svg) {
      return x`@svg_element(${reference})`;
    }
    if (namespace) {
      return x`@_document.createElementNS("${namespace}", "${name49}")`;
    }
    const is = (
      /** @type {any} */
      this.attributes.find((attr) => attr.node.name === "is")
    );
    if (is) {
      return x`@element_is("${name49}", ${is.render_chunks(block).reduce((lhs, rhs) => x`${lhs} + ${rhs}`)})`;
    }
    return x`@element(${reference})`;
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Identifier} nodes
   * @param {boolean} to_optimise_hydration
   */
  get_claim_statement(block, nodes, to_optimise_hydration) {
    const attributes = this.attributes.filter((attr) => !(attr instanceof SpreadAttributeWrapper) && !attr.property_name).map(
      (attr) => p`${/** @type {import('./StyleAttribute.js').default | import('./Attribute.js').default} */
      attr.name}: true`
    );
    let reference;
    if (this.node.tag_expr.node.type === "Literal") {
      if (this.node.namespace) {
        reference = `"${this.node.tag_expr.node.value}"`;
      } else {
        reference = `"${/** @type {String} */
        (this.node.tag_expr.node.value || "").toUpperCase()}"`;
      }
    } else if (this.node.namespace) {
      reference = x`${this.node.tag_expr.manipulate(block)}`;
    } else {
      reference = x`(${this.node.tag_expr.manipulate(block)} || 'null').toUpperCase()`;
    }
    if (to_optimise_hydration) {
      attributes.push(p`["data-svelte-h"]: true`);
    }
    if (this.node.namespace === namespaces.svg) {
      return x`@claim_svg_element(${nodes}, ${reference}, { ${attributes} })`;
    } else {
      return x`@claim_element(${nodes}, ${reference}, { ${attributes} })`;
    }
  }
  /** @param {import('../../Block.js').default} block */
  add_directives_in_order(block) {
    const binding_groups = events.map((event) => ({
      events: event.event_names,
      bindings: this.bindings.filter((binding) => binding.node.name !== "this").filter((binding) => event.filter(this.node, binding.node.name))
    })).filter((group) => group.bindings.length);
    const this_binding = this.bindings.find((b2) => b2.node.name === "this");
    function getOrder(item) {
      if (item instanceof EventHandlerWrapper) {
        return item.node.start;
      } else if (item instanceof BindingWrapper) {
        return item.node.start;
      } else if (item instanceof Action) {
        return item.start;
      } else {
        return item.bindings[0].node.start;
      }
    }
    [
      ...binding_groups,
      ...this.event_handlers,
      this_binding,
      ...this.node.actions
    ].filter(Boolean).sort((a, b2) => getOrder(a) - getOrder(b2)).forEach((item) => {
      if (item instanceof EventHandlerWrapper) {
        add_event_handler(block, this.var, item);
      } else if (item instanceof BindingWrapper) {
        this.add_this_binding(block, item);
      } else if (item instanceof Action) {
        add_action(block, this.var, item);
      } else {
        this.add_bindings(block, item);
      }
    });
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {BindingGroup} binding_group
   */
  add_bindings(block, binding_group) {
    const { renderer } = this;
    if (binding_group.bindings.length === 0)
      return;
    renderer.component.has_reactive_assignments = true;
    const lock = binding_group.bindings.some((binding) => binding.needs_lock) ? block.get_unique_name(`${this.var.name}_updating`) : null;
    if (lock)
      block.add_variable(lock, x`false`);
    const handler = renderer.component.get_unique_name(
      `${this.var.name}_${binding_group.events.join("_")}_handler`
    );
    renderer.add_to_context(handler.name);
    const needs_lock = binding_group.bindings.some((binding) => binding.needs_lock);
    const dependencies = /* @__PURE__ */ new Set();
    const contextual_dependencies = /* @__PURE__ */ new Set();
    binding_group.bindings.forEach((binding) => {
      add_to_set(dependencies, binding.get_update_dependencies());
      add_to_set(contextual_dependencies, binding.handler.contextual_dependencies);
      binding.render(block, lock);
    });
    let animation_frame;
    if (binding_group.events[0] === "timeupdate") {
      animation_frame = block.get_unique_name(`${this.var.name}_animationframe`);
      block.add_variable(animation_frame);
    }
    const has_local_function = contextual_dependencies.size > 0 || needs_lock || animation_frame;
    let callee = renderer.reference(handler);
    if (has_local_function) {
      const args = Array.from(contextual_dependencies).map((name49) => renderer.reference(name49));
      if (animation_frame) {
        block.chunks.init.push(b`
					function ${handler}() {
						@_cancelAnimationFrame(${animation_frame});
						if (!${this.var}.paused) {
							${animation_frame} = @raf(${handler});
							${needs_lock && b`${lock} = true;`}
						}
						${callee}.call(${this.var}, ${args});
					}
				`);
      } else {
        block.chunks.init.push(b`
					function ${handler}() {
						${needs_lock && b`${lock} = true;`}
						${callee}.call(${this.var}, ${args});
					}
				`);
      }
      callee = handler;
    }
    const params = Array.from(contextual_dependencies).map((name49) => ({
      type: "Identifier",
      name: name49
    }));
    this.renderer.component.partly_hoisted.push(b`
			function ${handler}(${params}) {
				${binding_group.bindings.map((b2) => b2.handler.mutation)}
				${Array.from(dependencies).filter((dep) => dep[0] !== "$").filter((dep) => !contextual_dependencies.has(dep)).map((dep) => b`${this.renderer.invalidate(dep)};`)}
			}
		`);
    binding_group.events.forEach((name49) => {
      if ([
        "elementresize",
        "elementresizecontentbox",
        "elementresizeborderbox",
        "elementresizedevicepixelcontentbox"
      ].indexOf(name49) !== -1) {
        const resize_listener = block.get_unique_name(`${this.var.name}_resize_listener`);
        block.add_variable(resize_listener);
        switch (name49) {
          case "elementresize":
            block.chunks.mount.push(
              b`${resize_listener} = @add_iframe_resize_listener(${this.var}, ${callee}.bind(${this.var}));`
            );
            break;
          case "elementresizecontentbox":
            block.chunks.mount.push(
              b`${resize_listener} = @resize_observer_content_box.observe(${this.var}, ${callee}.bind(${this.var}));`
            );
            break;
          case "elementresizeborderbox":
            block.chunks.mount.push(
              b`${resize_listener} = @resize_observer_border_box.observe(${this.var}, ${callee}.bind(${this.var}));`
            );
            break;
          case "elementresizedevicepixelcontentbox":
            block.chunks.mount.push(
              b`${resize_listener} = @resize_observer_device_pixel_content_box.observe(${this.var}, ${callee}.bind(${this.var}));`
            );
            break;
        }
        block.chunks.destroy.push(b`${resize_listener}();`);
      } else {
        block.event_listeners.push(x`@listen(${this.var}, "${name49}", ${callee})`);
      }
    });
    const some_initial_state_is_undefined = binding_group.bindings.map((binding) => x`${binding.snippet} === void 0`).reduce((lhs, rhs) => x`${lhs} || ${rhs}`);
    const should_initialise = this.node.name === "select" || binding_group.bindings.find(
      (binding) => binding.node.name === "indeterminate" || is_name_contenteditable(binding.node.name) || binding.is_readonly_media_attribute()
    );
    if (should_initialise) {
      const callback = has_local_function ? handler : x`() => ${callee}.call(${this.var})`;
      block.chunks.hydrate.push(
        b`if (${some_initial_state_is_undefined}) @add_render_callback(${callback});`
      );
    }
    if (binding_group.events[0] === "elementresize") {
      block.chunks.hydrate.push(b`@add_render_callback(() => ${callee}.call(${this.var}));`);
    }
    if (lock) {
      block.chunks.update.push(b`${lock} = false;`);
    }
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {import('./Binding.js').default} this_binding
   */
  add_this_binding(block, this_binding) {
    const { renderer } = this;
    renderer.component.has_reactive_assignments = true;
    const binding_callback = bind_this(renderer.component, block, this_binding, this.var);
    block.chunks.mount.push(binding_callback);
  }
  /** @param {import('../../Block.js').default} block */
  add_attributes(block) {
    this.attributes.forEach((attribute) => {
      if (attribute.node.name === "class") {
        const dependencies = attribute.node.get_dependencies();
        push_array2(this.class_dependencies, dependencies);
      } else if (attribute.node.name === "style") {
        add_to_set(this.dynamic_style_dependencies, attribute.node.get_dependencies());
      }
    });
    if (this.node.attributes.some((attr) => attr.is_spread)) {
      this.add_spread_attributes(block);
      return;
    }
    this.attributes.forEach((attribute) => {
      attribute.render(block);
    });
  }
  /** @param {import('../../Block.js').default} block */
  add_spread_attributes(block) {
    const levels = block.get_unique_name(`${this.var.name}_levels`);
    const initial_props = [];
    const updates = [];
    this.attributes.forEach((attr) => {
      const dependencies = attr.node.get_dependencies();
      const condition = dependencies.length > 0 ? block.renderer.dirty(dependencies) : null;
      if (attr instanceof SpreadAttributeWrapper) {
        const snippet = attr.node.expression.manipulate(block);
        initial_props.push(snippet);
        updates.push(condition ? x`${condition} && ${snippet}` : snippet);
      } else {
        const name49 = attr.property_name || attr.name;
        initial_props.push(x`{ ${name49}: ${attr.get_init(block, attr.get_value(block))} }`);
        const snippet = x`{ ${name49}: ${attr.should_cache ? attr.last : attr.get_value(block)} }`;
        updates.push(
          condition ? x`${attr.get_dom_update_conditions(block, condition)} && ${snippet}` : snippet
        );
      }
    });
    block.chunks.init.push(b`
			let ${levels} = [${initial_props}];

			let ${this.element_data_name} = {};
			for (let #i = 0; #i < ${levels}.length; #i += 1) {
				${this.element_data_name} = @assign(${this.element_data_name}, ${levels}[#i]);
			}
		`);
    const fn = this.node.namespace === namespaces.svg ? x`@set_svg_attributes` : this.node.is_dynamic_element ? x`@set_dynamic_element_data(${this.node.tag_expr.manipulate(block)})` : x`@set_attributes`;
    block.chunks.hydrate.push(b`${fn}(${this.var}, ${this.element_data_name});`);
    if (this.has_dynamic_attribute) {
      block.chunks.update.push(b`
				${fn}(${this.var}, ${this.element_data_name} = @get_spread_update(${levels}, [
					${updates}
				]));
			`);
    }
    if (this.node.name === "select") {
      const dependencies = /* @__PURE__ */ new Set();
      for (const attr of this.attributes) {
        for (const dep of attr.node.dependencies) {
          dependencies.add(dep);
        }
      }
      block.chunks.mount.push(b`
				'value' in ${this.element_data_name} && (${this.element_data_name}.multiple ? @select_options : @select_option)(${this.var}, ${this.element_data_name}.value);
			`);
      block.chunks.update.push(b`
				if (${block.renderer.dirty(Array.from(dependencies))} && 'value' in ${this.element_data_name}) (${this.element_data_name}.multiple ? @select_options : @select_option)(${this.var}, ${this.element_data_name}.value);
			`);
    } else if (this.node.name === "input" && this.attributes.find((attr) => attr.node.name === "value")) {
      const type = this.node.get_static_attribute_value("type");
      if (type === null || type === "" || type === "text" || type === "email" || type === "password") {
        block.chunks.mount.push(b`
					if ('value' in ${this.element_data_name}) {
						${this.var}.value = ${this.element_data_name}.value;
					}
				`);
        block.chunks.update.push(b`
					if ('value' in ${this.element_data_name}) {
						${this.var}.value = ${this.element_data_name}.value;
					}
				`);
      }
    }
    if (["button", "input", "keygen", "select", "textarea"].includes(this.node.name)) {
      block.chunks.mount.push(b`
				if (${this.var}.autofocus) ${this.var}.focus();
			`);
    }
  }
  /** @param {import('../../Block.js').default} block */
  add_dynamic_element_attributes(block) {
    if (this.attributes.length === 0)
      return;
    if (this.has_dynamic_attribute) {
      this.add_spread_attributes(block);
      return;
    }
    const static_attributes = [];
    this.attributes.forEach((attr) => {
      if (attr instanceof SpreadAttributeWrapper) {
        const snippet = { type: "SpreadElement", argument: attr.node.expression.manipulate(block) };
        static_attributes.push(snippet);
      } else {
        const name49 = attr.property_name || attr.name;
        static_attributes.push(p`${name49}: ${attr.get_value(block)}`);
      }
    });
    const fn = this.node.namespace === namespaces.svg ? x`@set_svg_attributes` : this.node.is_dynamic_element ? x`@set_dynamic_element_data(${this.node.tag_expr.manipulate(block)})` : x`@set_attributes`;
    block.chunks.hydrate.push(b`${fn}(${this.var}, {${static_attributes}});`);
  }
  /** @param {import('../../Block.js').default} block */
  add_transitions(block) {
    const { intro, outro } = this.node;
    if (!intro && !outro)
      return;
    if (intro === outro) {
      const name49 = block.get_unique_name(`${this.var.name}_transition`);
      const snippet = intro.expression ? intro.expression.manipulate(block) : x`{}`;
      block.add_variable(name49);
      const fn = this.renderer.reference(intro.name);
      const intro_block = b`
				@add_render_callback(() => {
					if (!#current) return;
					if (!${name49}) ${name49} = @create_bidirectional_transition(${this.var}, ${fn}, ${snippet}, true);
					${name49}.run(1);
				});
			`;
      const outro_block = b`
				if (!${name49}) ${name49} = @create_bidirectional_transition(${this.var}, ${fn}, ${snippet}, false);
				${name49}.run(0);
			`;
      if (intro.is_local) {
        block.chunks.intro.push(b`
					if (#local) {
						${intro_block}
					}
				`);
        block.chunks.outro.push(b`
					if (#local) {
						${outro_block}
					}
				`);
      } else {
        block.chunks.intro.push(intro_block);
        block.chunks.outro.push(outro_block);
      }
      block.chunks.destroy.push(b`if (detaching && ${name49}) ${name49}.end();`);
    } else {
      const intro_name = intro && block.get_unique_name(`${this.var.name}_intro`);
      const outro_name = outro && block.get_unique_name(`${this.var.name}_outro`);
      if (intro) {
        block.add_variable(intro_name);
        const snippet = intro.expression ? intro.expression.manipulate(block) : x`{}`;
        const fn = this.renderer.reference(intro.name);
        let intro_block;
        if (outro) {
          intro_block = b`
						@add_render_callback(() => {
							if (!#current) return;
							if (${outro_name}) ${outro_name}.end(1);
							${intro_name} = @create_in_transition(${this.var}, ${fn}, ${snippet});
							${intro_name}.start();
						});
					`;
          block.chunks.outro.push(b`if (${intro_name}) ${intro_name}.invalidate();`);
        } else {
          intro_block = b`
						if (!${intro_name}) {
							@add_render_callback(() => {
								${intro_name} = @create_in_transition(${this.var}, ${fn}, ${snippet});
								${intro_name}.start();
							});
						}
					`;
        }
        if (intro.is_local) {
          intro_block = b`
						if (#local) {
							${intro_block}
						}
					`;
        }
        block.chunks.intro.push(intro_block);
      }
      if (outro) {
        block.add_variable(outro_name);
        const snippet = outro.expression ? outro.expression.manipulate(block) : x`{}`;
        const fn = this.renderer.reference(outro.name);
        if (!intro) {
          block.chunks.intro.push(b`
						if (${outro_name}) ${outro_name}.end(1);
					`);
        }
        let outro_block = b`
					${outro_name} = @create_out_transition(${this.var}, ${fn}, ${snippet});
				`;
        if (outro.is_local) {
          outro_block = b`
						if (#local) {
							${outro_block}
						}
					`;
        }
        block.chunks.outro.push(outro_block);
        block.chunks.destroy.push(b`if (detaching && ${outro_name}) ${outro_name}.end();`);
      }
    }
    if (intro && intro.expression && intro.expression.dependencies.size || outro && outro.expression && outro.expression.dependencies.size) {
      block.maintain_context = true;
    }
  }
  /** @param {import('../../Block.js').default} block */
  add_animation(block) {
    if (!this.node.animation)
      return;
    const { outro } = this.node;
    const rect = block.get_unique_name("rect");
    const stop_animation = block.get_unique_name("stop_animation");
    block.add_variable(rect);
    block.add_variable(stop_animation, x`@noop`);
    block.chunks.measure.push(b`
			${rect} = ${this.var}.getBoundingClientRect();
		`);
    if (block.type === CHILD_DYNAMIC_ELEMENT_BLOCK) {
      block.chunks.measure.push(b`return ${rect}`);
      block.chunks.restore_measurements.push(b`${rect} = #measurement;`);
    }
    block.chunks.fix.push(b`
			@fix_position(${this.var});
			${stop_animation}();
			${outro && b`@add_transform(${this.var}, ${rect});`}
		`);
    let params;
    if (this.node.animation.expression) {
      params = this.node.animation.expression.manipulate(block);
      if (this.node.animation.expression.dynamic_dependencies().length) {
        const params_var = block.get_unique_name("params");
        block.add_variable(params_var);
        block.chunks.measure.push(b`${params_var} = ${params};`);
        params = params_var;
      }
    } else {
      params = x`{}`;
    }
    const name49 = this.renderer.reference(this.node.animation.name);
    block.chunks.animate.push(b`
			${stop_animation}();
			${stop_animation} = @create_animation(${this.var}, ${rect}, ${name49}, ${params});
		`);
  }
  /** @param {import('../../Block.js').default} block */
  add_classes(block) {
    const has_spread = this.node.attributes.some((attr) => attr.is_spread);
    this.node.classes.forEach((class_directive) => {
      const { expression, name: name49 } = class_directive;
      let snippet;
      let dependencies;
      if (expression) {
        snippet = expression.manipulate(block);
        dependencies = expression.dependencies;
      } else {
        snippet = name49;
        dependencies = /* @__PURE__ */ new Set([name49]);
      }
      const updater = b`@toggle_class(${this.var}, "${name49}", ${snippet});`;
      block.chunks.hydrate.push(updater);
      if ((this.node.is_dynamic_element || has_spread) && this.has_dynamic_attribute) {
        block.chunks.update.push(updater);
      } else if (dependencies && dependencies.size > 0 || this.class_dependencies.length) {
        const all_dependencies = this.class_dependencies.concat(...dependencies);
        let condition = block.renderer.dirty(all_dependencies);
        if (block.has_outros) {
          condition = x`!#current || ${condition}`;
        }
        const any_dynamic_dependencies = all_dependencies.some((dep) => {
          const variable = this.renderer.component.var_lookup.get(dep);
          return !variable || is_dynamic(variable);
        });
        if (any_dynamic_dependencies) {
          block.chunks.update.push(b`
						if (${condition}) {
							${updater}
						}
					`);
        }
      }
    });
  }
  /** @param {import('../../Block.js').default} block */
  add_styles(block) {
    const has_spread = this.node.attributes.some((attr) => attr.is_spread);
    let style_changed_var;
    const maybe_create_style_changed_var = () => {
      if (!style_changed_var && this.dynamic_style_dependencies.size) {
        style_changed_var = block.get_unique_name("style_changed");
        const style_attr_dirty = block.renderer.dirty([...this.dynamic_style_dependencies]);
        block.chunks.update.push(b`const ${style_changed_var} = ${style_attr_dirty};`);
      }
    };
    this.node.styles.forEach((style_directive) => {
      const { name: name49, expression, important, should_cache: should_cache2 } = style_directive;
      const snippet = expression.manipulate(block);
      let cached_snippet;
      if (should_cache2) {
        cached_snippet = block.get_unique_name(`style_${name49.replace(regex_minus_signs, "_")}`);
        block.add_variable(cached_snippet, snippet);
      }
      const updater = b`@set_style(${this.var}, "${name49}", ${should_cache2 ? cached_snippet : snippet}, ${important ? 1 : null})`;
      block.chunks.hydrate.push(updater);
      const self_deps = expression.dynamic_dependencies();
      const all_deps = /* @__PURE__ */ new Set([...self_deps, ...this.dynamic_style_dependencies]);
      let condition = block.renderer.dirty([...all_deps]);
      if (has_spread) {
        if (should_cache2 && all_deps.size) {
          block.chunks.update.push(b`
						if (${condition}) {
							${cached_snippet} = ${snippet};
						}`);
        }
        block.chunks.update.push(updater);
      } else {
        if (all_deps.size === 0)
          return;
        if (should_cache2) {
          condition = x`${condition} && ${cached_snippet} !== (${cached_snippet} = ${snippet})`;
        }
        if (this.dynamic_style_dependencies.size > 0) {
          maybe_create_style_changed_var();
          condition = x`${condition} || ${style_changed_var}`;
        }
        block.chunks.update.push(b`
					if (${condition}) {
						${updater}
					}
				`);
      }
    });
  }
  /** @param {import('../../Block.js').default} block */
  add_manual_style_scoping(block) {
    if (this.node.needs_manual_style_scoping) {
      const updater = b`@toggle_class(${this.var}, "${this.node.component.stylesheet.id}", true);`;
      block.chunks.hydrate.push(updater);
      block.chunks.update.push(updater);
    }
  }
};
var regex_backticks = /`/g;
var regex_dollar_signs = /\$/g;
function to_html(wrappers2, block, literal2, state, can_use_raw_text) {
  wrappers2.forEach((wrapper) => {
    if (wrapper instanceof CommentWrapper) {
      state.quasi.value.raw += wrapper.text();
    } else if (wrapper instanceof TextWrapper) {
      if (wrapper.use_space()) {
        state.quasi.value.raw += " ";
        return;
      }
      const parent = (
        /** @type {import('../../../nodes/Element.js').default} */
        wrapper.node.parent
      );
      const raw = parent && (parent.name === "script" || parent.name === "style" || can_use_raw_text);
      state.quasi.value.raw += (raw ? wrapper.data : escape_html(wrapper.data)).replace(regex_backslashes, "\\\\").replace(regex_backticks, "\\`").replace(regex_dollar_signs, "\\$");
    } else if (wrapper instanceof MustacheTagWrapper || wrapper instanceof RawMustacheTagWrapper) {
      literal2.quasis.push(state.quasi);
      literal2.expressions.push(wrapper.node.expression.manipulate(block));
      state.quasi = {
        type: "TemplateElement",
        value: { raw: "" }
      };
    } else if (wrapper.node.name === "noscript") {
    } else {
      const nodeName = wrapper.node.name;
      state.quasi.value.raw += `<${nodeName}`;
      const is_empty_textarea = nodeName === "textarea" && wrapper.fragment.nodes.length === 0;
      wrapper.attributes.forEach((attr) => {
        if (is_empty_textarea && attr.node.name === "value") {
          return;
        }
        if (attr instanceof SpreadAttributeWrapper) {
          literal2.quasis.push(state.quasi);
          literal2.expressions.push(x`@stringify_spread(${attr.node.expression.manipulate(block)})`);
          state.quasi = {
            type: "TemplateElement",
            value: { raw: "" }
          };
        } else {
          state.quasi.value.raw += ` ${fix_attribute_casing(attr.node.name)}="`;
          to_html_for_attr_value(attr, block, literal2, state);
          state.quasi.value.raw += '"';
        }
      });
      if (!wrapper.void) {
        state.quasi.value.raw += ">";
        if (nodeName === "pre") {
          const first = wrapper.fragment.nodes[0];
          if (first && first.node.type === "Text" && regex_starts_with_newline.test(first.node.data)) {
            state.quasi.value.raw += "\n";
          }
        }
        if (is_empty_textarea) {
          const value_attribute = wrapper.attributes.find((attr) => attr.node.name === "value");
          if (value_attribute) {
            const first = value_attribute.node.chunks[0];
            if (first && first.type === "Text" && regex_starts_with_newline.test(first.data)) {
              state.quasi.value.raw += "\n";
            }
            to_html_for_attr_value(value_attribute, block, literal2, state);
          }
        }
        to_html(
          /** @type {Array<ElementWrapper | import('../Text.js').default>} */
          wrapper.fragment.nodes,
          block,
          literal2,
          state
        );
        state.quasi.value.raw += `</${nodeName}>`;
      } else {
        state.quasi.value.raw += "/>";
      }
    }
  });
}
function to_html_for_attr_value(attr, block, literal2, state) {
  attr.node.chunks.forEach((chunk) => {
    if (chunk.type === "Text") {
      state.quasi.value.raw += escape_html(chunk.data);
    } else {
      literal2.quasis.push(state.quasi);
      literal2.expressions.push(chunk.manipulate(block));
      state.quasi = {
        type: "TemplateElement",
        value: { raw: "" }
      };
    }
  });
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Head.js
var HeadWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/Head.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @type {import('./Fragment.js').default} */
    __publicField(this, "fragment");
    this.fragment = new FragmentWrapper(
      renderer,
      block,
      node.children,
      this,
      strip_whitespace,
      next_sibling
    );
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} _parent_node
   * @param {import('estree').Identifier} _parent_nodes
   */
  render(block, _parent_node, _parent_nodes) {
    let nodes;
    if (this.renderer.options.hydratable && this.fragment.nodes.length) {
      nodes = block.get_unique_name("head_nodes");
      block.chunks.claim.push(
        b`const ${nodes} = @head_selector('${this.node.id}', @_document.head);`
      );
    }
    this.fragment.render(
      block,
      /** @type {unknown} */
      /** @type {import('estree').Identifier} */
      x`@_document.head`,
      nodes
    );
    if (nodes && this.renderer.options.hydratable) {
      block.chunks.claim.push(b`${nodes}.forEach(@detach);`);
    }
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/IfBlock.js
function is_else_if(node) {
  return node && node.children.length === 1 && node.children[0].type === "IfBlock";
}
var IfBlockBranch = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {IfBlockWrapper} parent
   * @param {import('../../nodes/IfBlock.js').default | import('../../nodes/ElseBlock.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @type {import('../Block.js').default} */
    __publicField(this, "block");
    /** @type {import('./Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {string[]} */
    __publicField(this, "dependencies");
    /** @type {any} */
    __publicField(this, "condition");
    /** @type {import('estree').Node} */
    __publicField(this, "snippet");
    /** @type {boolean} */
    __publicField(this, "is_dynamic");
    /** */
    __publicField(this, "var", null);
    /** @type {import('estree').Node | undefined} */
    __publicField(this, "get_ctx_name");
    const { expression } = (
      /** @type {import('../../nodes/IfBlock.js').default} */
      node
    );
    const is_else = !expression;
    if (expression) {
      this.dependencies = expression.dynamic_dependencies();
      let should_cache2 = false;
      walk(expression.node, {
        enter(node2) {
          if (node2.type === "CallExpression" || node2.type === "NewExpression") {
            should_cache2 = true;
          }
        }
      });
      if (should_cache2) {
        this.condition = block.get_unique_name("show_if");
        this.snippet = /** @type {import('estree').Node} */
        expression.manipulate(block);
      } else {
        this.condition = expression.manipulate(block);
      }
    }
    add_const_tags_context(renderer, this.node.const_tags);
    this.block = block.child({
      comment: create_debugging_comment(node, parent.renderer.component),
      name: parent.renderer.component.get_unique_name(
        is_else ? "create_else_block" : "create_if_block"
      ),
      type: (
        /** @type {import('../../nodes/IfBlock.js').default} */
        node.expression ? "if" : "else"
      )
    });
    this.fragment = new FragmentWrapper(
      renderer,
      this.block,
      node.children,
      parent,
      strip_whitespace,
      next_sibling
    );
    this.is_dynamic = this.block.dependencies.size > 0;
    if (node.const_tags.length > 0) {
      this.get_ctx_name = parent.renderer.component.get_unique_name(
        is_else ? "get_else_ctx" : "get_if_ctx"
      );
    }
  }
};
var IfBlockWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/IfBlock.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @typedef {'detaching' | null} DetachingOrNull */
    /** @type {IfBlockBranch[]} */
    __publicField(this, "branches");
    /** */
    __publicField(this, "needs_update", false);
    /** @type {import('estree').Identifier} */
    __publicField(this, "var", { type: "Identifier", name: "if_block" });
    this.branches = [];
    const blocks = [];
    let is_dynamic3 = false;
    let has_intros = false;
    let has_outros = false;
    const create_branches = (node2) => {
      const branch = new IfBlockBranch(renderer, block, this, node2, strip_whitespace, next_sibling);
      this.branches.push(branch);
      blocks.push(branch.block);
      block.add_dependencies(node2.expression.dependencies);
      if (branch.block.dependencies.size > 0) {
        is_dynamic3 = true;
        block.add_dependencies(branch.block.dependencies);
      }
      if (branch.dependencies && branch.dependencies.length > 0) {
        this.needs_update = true;
      }
      if (branch.block.has_intros)
        has_intros = true;
      if (branch.block.has_outros)
        has_outros = true;
      if (is_else_if(node2.else)) {
        create_branches(
          /** @type {import('../../nodes/IfBlock.js').default} */
          node2.else.children[0]
        );
      } else if (node2.else) {
        const branch2 = new IfBlockBranch(
          renderer,
          block,
          this,
          node2.else,
          strip_whitespace,
          next_sibling
        );
        this.branches.push(branch2);
        blocks.push(branch2.block);
        if (branch2.block.dependencies.size > 0) {
          is_dynamic3 = true;
          block.add_dependencies(branch2.block.dependencies);
        }
        if (branch2.block.has_intros)
          has_intros = true;
        if (branch2.block.has_outros)
          has_outros = true;
      }
    };
    create_branches(this.node);
    blocks.forEach((block2) => {
      block2.has_update_method = is_dynamic3;
      block2.has_intro_method = has_intros;
      block2.has_outro_method = has_outros;
    });
    push_array2(renderer.blocks, blocks);
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    const name49 = this.var;
    const needs_anchor = this.next ? !this.next.is_dom_node() : !parent_node || !this.parent.is_dom_node();
    const anchor = needs_anchor ? block.get_unique_name(`${this.var.name}_anchor`) : this.next && this.next.var || "null";
    const has_else = !this.branches[this.branches.length - 1].condition;
    const if_exists_condition = has_else ? null : name49;
    const dynamic = this.branches[0].block.has_update_method;
    const has_intros = this.branches[0].block.has_intro_method;
    const has_outros = this.branches[0].block.has_outro_method;
    const has_transitions = has_intros || has_outros;
    this.branches.forEach((branch) => {
      if (branch.get_ctx_name) {
        this.renderer.blocks.push(b`
				function ${branch.get_ctx_name}(#ctx) {
					const child_ctx = #ctx.slice();
					${add_const_tags(block, branch.node.const_tags, "child_ctx")}
					return child_ctx;
				}
				`);
      }
    });
    const vars = { name: name49, anchor, if_exists_condition, has_else, has_transitions };
    const detaching = parent_node && !is_head(parent_node) ? null : "detaching";
    if (this.node.else) {
      this.branches.forEach((branch) => {
        if (branch.snippet)
          block.add_variable(branch.condition);
      });
      if (has_outros) {
        this.render_compound_with_outros(
          block,
          parent_node,
          parent_nodes,
          dynamic,
          vars,
          detaching
        );
        block.chunks.outro.push(b`@transition_out(${name49});`);
      } else {
        this.render_compound(block, parent_node, parent_nodes, dynamic, vars, detaching);
      }
    } else {
      this.render_simple(block, parent_node, parent_nodes, dynamic, vars, detaching);
      if (has_outros) {
        block.chunks.outro.push(b`@transition_out(${name49});`);
      }
    }
    if (if_exists_condition) {
      block.chunks.create.push(b`if (${if_exists_condition}) ${name49}.c();`);
    } else {
      block.chunks.create.push(b`${name49}.c();`);
    }
    if (parent_nodes && this.renderer.options.hydratable) {
      if (if_exists_condition) {
        block.chunks.claim.push(b`if (${if_exists_condition}) ${name49}.l(${parent_nodes});`);
      } else {
        block.chunks.claim.push(b`${name49}.l(${parent_nodes});`);
      }
    }
    if (has_intros || has_outros) {
      block.chunks.intro.push(b`@transition_in(${name49});`);
    }
    if (needs_anchor) {
      block.add_element(
        /** @type {import('estree').Identifier} */
        anchor,
        x`@empty()`,
        parent_nodes && x`@empty()`,
        parent_node
      );
    }
    this.branches.forEach((branch) => {
      branch.fragment.render(
        branch.block,
        null,
        /** @type {unknown} */
        /** @type {import('estree').Identifier} */
        x`#nodes`
      );
    });
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} _parent_nodes
   * @param {boolean} dynamic
   * @param {any} opts
   * @param {DetachingOrNull} detaching
   */
  render_compound(block, parent_node, _parent_nodes, dynamic, { name: name49, anchor, has_else, if_exists_condition, has_transitions }, detaching) {
    const select_block_type = this.renderer.component.get_unique_name("select_block_type");
    const current_block_type = block.get_unique_name("current_block_type");
    const need_select_block_ctx = this.branches.some((branch) => branch.get_ctx_name);
    const select_block_ctx = need_select_block_ctx ? block.get_unique_name("select_block_ctx") : null;
    const if_ctx = select_block_ctx ? x`${select_block_ctx}(#ctx, ${current_block_type})` : x`#ctx`;
    const get_block = has_else ? x`${current_block_type}(${if_ctx})` : x`${current_block_type} && ${current_block_type}(${if_ctx})`;
    if (this.needs_update) {
      block.chunks.init.push(b`
				function ${select_block_type}(#ctx, #dirty) {
					${this.branches.map(({ dependencies, condition, snippet }) => {
        return b`${snippet && dependencies.length > 0 ? b`if (${block.renderer.dirty(dependencies)}) ${condition} = null;` : null}`;
      })}
					${this.branches.map(
        ({ condition, snippet, block: block2 }) => condition ? b`
								${snippet && b`if (${condition} == null) ${condition} = !!${snippet}`}
								if (${condition}) return ${block2.name};` : b`return ${block2.name};`
      )}
				}
			`);
    } else {
      block.chunks.init.push(b`
				function ${select_block_type}(#ctx, #dirty) {
					${this.branches.map(
        ({ condition, snippet, block: block2 }) => condition ? b`if (${snippet || condition}) return ${block2.name};` : b`return ${block2.name};`
      )}
				}
			`);
    }
    if (need_select_block_ctx) {
      if (this.branches.every((branch) => branch.get_ctx_name)) {
        block.chunks.init.push(b`
					function ${select_block_ctx}(#ctx, #type) {
						${this.branches.map(({ condition, get_ctx_name, block: block2 }) => {
          return condition ? b`if (#type === ${block2.name}) return ${get_ctx_name}(#ctx);` : b`return ${get_ctx_name}(#ctx);`;
        }).filter(Boolean)}
					}
				`);
      } else {
        block.chunks.init.push(b`
					function ${select_block_ctx}(#ctx, #type) {
						${this.branches.map(({ get_ctx_name, block: block2 }) => {
          return get_ctx_name ? b`if (#type === ${block2.name}) return ${get_ctx_name}(#ctx);` : null;
        }).filter(Boolean)}
						return #ctx;
					}
				`);
      }
    }
    block.chunks.init.push(b`
			let ${current_block_type} = ${select_block_type}(#ctx, ${this.renderer.get_initial_dirty()});
			let ${name49} = ${get_block};
		`);
    const initial_mount_node = parent_node || "#target";
    const anchor_node = parent_node ? "null" : "#anchor";
    if (if_exists_condition) {
      block.chunks.mount.push(
        b`if (${if_exists_condition}) ${name49}.m(${initial_mount_node}, ${anchor_node});`
      );
    } else {
      block.chunks.mount.push(b`${name49}.m(${initial_mount_node}, ${anchor_node});`);
    }
    if (this.needs_update) {
      const update_mount_node = this.get_update_mount_node(anchor);
      const change_block = b`
				${if_exists_condition ? b`if (${if_exists_condition}) ${name49}.d(1)` : b`${name49}.d(1)`};
				${name49} = ${get_block};
				if (${name49}) {
					${name49}.c();
					${has_transitions && b`@transition_in(${name49}, 1);`}
					${name49}.m(${update_mount_node}, ${anchor});
				}
			`;
      if (dynamic) {
        block.chunks.update.push(b`
					if (${current_block_type} === (${current_block_type} = ${select_block_type}(#ctx, #dirty)) && ${name49}) {
						${name49}.p(${if_ctx}, #dirty);
					} else {
						${change_block}
					}
				`);
      } else {
        block.chunks.update.push(b`
					if (${current_block_type} !== (${current_block_type} = ${select_block_type}(#ctx, #dirty))) {
						${change_block}
					}
				`);
      }
    } else if (dynamic) {
      if (if_exists_condition) {
        block.chunks.update.push(b`if (${if_exists_condition}) ${name49}.p(${if_ctx}, #dirty);`);
      } else {
        block.chunks.update.push(b`${name49}.p(${if_ctx}, #dirty);`);
      }
    }
    if (if_exists_condition) {
      block.chunks.destroy.push(b`
				if (${if_exists_condition}) {
					${name49}.d(${detaching});
				}
			`);
    } else {
      block.chunks.destroy.push(b`
				${name49}.d(${detaching});
			`);
    }
  }
  // if any of the siblings have outros, we need to keep references to the blocks
  // (TODO does this only apply to bidi transitions?)
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} _parent_nodes
   * @param {boolean} dynamic
   * @param {any} opts
   * @param {DetachingOrNull} detaching
   */
  render_compound_with_outros(block, parent_node, _parent_nodes, dynamic, { name: name49, anchor, has_else, has_transitions, if_exists_condition }, detaching) {
    const select_block_type = this.renderer.component.get_unique_name("select_block_type");
    const current_block_type_index = block.get_unique_name("current_block_type_index");
    const previous_block_index = block.get_unique_name("previous_block_index");
    const if_block_creators = block.get_unique_name("if_block_creators");
    const if_blocks = block.get_unique_name("if_blocks");
    const need_select_block_ctx = this.branches.some((branch) => branch.get_ctx_name);
    const select_block_ctx = need_select_block_ctx ? block.get_unique_name("select_block_ctx") : null;
    const if_ctx = select_block_ctx ? x`${select_block_ctx}(#ctx, ${current_block_type_index})` : x`#ctx`;
    const if_current_block_type_index = has_else ? (nodes) => nodes : (nodes) => b`if (~${current_block_type_index}) { ${nodes} }`;
    block.add_variable(current_block_type_index);
    block.add_variable(name49);
    block.chunks.init.push(b`
			const ${if_block_creators} = [
				${this.branches.map((branch) => branch.block.name)}
			];

			const ${if_blocks} = [];

			${this.needs_update ? b`
					function ${select_block_type}(#ctx, #dirty) {
						${this.branches.map(({ dependencies, condition, snippet }) => {
      return b`${snippet && dependencies.length > 0 ? b`if (${block.renderer.dirty(dependencies)}) ${condition} = null;` : null}`;
    })}
						${this.branches.map(
      ({ condition, snippet }, i) => condition ? b`
								${snippet && b`if (${condition} == null) ${condition} = !!${snippet}`}
								if (${condition}) return ${i};` : b`return ${i};`
    )}
								${!has_else && b`return -1;`}
							}
						` : b`
					function ${select_block_type}(#ctx, #dirty) {
						${this.branches.map(
      ({ condition, snippet }, i) => condition ? b`if (${snippet || condition}) return ${i};` : b`return ${i};`
    )}
						${!has_else && b`return -1;`}
					}
				`}
		`);
    if (need_select_block_ctx) {
      if (this.branches.every((branch) => branch.get_ctx_name)) {
        block.chunks.init.push(b`
					function ${select_block_ctx}(#ctx, #index) {
						${this.branches.map(({ condition, get_ctx_name }, i) => {
          return condition ? b`if (#index === ${i}) return ${get_ctx_name}(#ctx);` : b`return ${get_ctx_name}(#ctx);`;
        }).filter(Boolean)}
					}
				`);
      } else {
        block.chunks.init.push(b`
					function ${select_block_ctx}(#ctx, #index) {
						${this.branches.map(({ get_ctx_name }, i) => {
          return get_ctx_name ? b`if (#index === ${i}) return ${get_ctx_name}(#ctx);` : null;
        }).filter(Boolean)}
						return #ctx;
					}
				`);
      }
    }
    if (has_else) {
      block.chunks.init.push(b`
				${current_block_type_index} = ${select_block_type}(#ctx, ${this.renderer.get_initial_dirty()});
				${name49} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](${if_ctx});
			`);
    } else {
      block.chunks.init.push(b`
				if (~(${current_block_type_index} = ${select_block_type}(#ctx, ${this.renderer.get_initial_dirty()}))) {
					${name49} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](${if_ctx});
				}
			`);
    }
    const initial_mount_node = parent_node || "#target";
    const anchor_node = parent_node ? "null" : "#anchor";
    block.chunks.mount.push(
      if_current_block_type_index(
        b`${if_blocks}[${current_block_type_index}].m(${initial_mount_node}, ${anchor_node});`
      )
    );
    if (this.needs_update) {
      const update_mount_node = this.get_update_mount_node(anchor);
      const destroy_old_block = b`
				@group_outros();
				@transition_out(${if_blocks}[${previous_block_index}], 1, 1, () => {
					${if_blocks}[${previous_block_index}] = null;
				});
				@check_outros();
			`;
      const create_new_block = b`
				${name49} = ${if_blocks}[${current_block_type_index}];
				if (!${name49}) {
					${name49} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](${if_ctx});
					${name49}.c();
				} else {
					${dynamic && b`${name49}.p(${if_ctx}, #dirty);`}
				}
				${has_transitions && b`@transition_in(${name49}, 1);`}
				${name49}.m(${update_mount_node}, ${anchor});
			`;
      const change_block = has_else ? b`
					${destroy_old_block}

					${create_new_block}
				` : b`
					if (${name49}) {
						${destroy_old_block}
					}

					if (~${current_block_type_index}) {
						${create_new_block}
					} else {
						${name49} = null;
					}
				`;
      block.chunks.update.push(b`
				let ${previous_block_index} = ${current_block_type_index};
				${current_block_type_index} = ${select_block_type}(#ctx, #dirty);
			`);
      if (dynamic) {
        block.chunks.update.push(b`
					if (${current_block_type_index} === ${previous_block_index}) {
						${if_current_block_type_index(b`${if_blocks}[${current_block_type_index}].p(${if_ctx}, #dirty);`)}
					} else {
						${change_block}
					}
				`);
      } else {
        block.chunks.update.push(b`
					if (${current_block_type_index} !== ${previous_block_index}) {
						${change_block}
					}
				`);
      }
    } else if (dynamic) {
      if (if_exists_condition) {
        block.chunks.update.push(b`if (${if_exists_condition}) ${name49}.p(${if_ctx}, #dirty);`);
      } else {
        block.chunks.update.push(b`${name49}.p(${if_ctx}, #dirty);`);
      }
    }
    block.chunks.destroy.push(
      if_current_block_type_index(b`${if_blocks}[${current_block_type_index}].d(${detaching});`)
    );
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} _parent_nodes
   * @param {boolean} dynamic
   * @param {any} opts
   * @param {DetachingOrNull} detaching
   */
  render_simple(block, parent_node, _parent_nodes, dynamic, { name: name49, anchor, if_exists_condition, has_transitions }, detaching) {
    const branch = this.branches[0];
    const if_ctx = branch.get_ctx_name ? x`${branch.get_ctx_name}(#ctx)` : x`#ctx`;
    if (branch.snippet)
      block.add_variable(branch.condition, branch.snippet);
    block.chunks.init.push(b`
			let ${name49} = ${branch.condition} && ${branch.block.name}(${if_ctx});
		`);
    const initial_mount_node = parent_node || "#target";
    const anchor_node = parent_node ? "null" : "#anchor";
    block.chunks.mount.push(b`if (${name49}) ${name49}.m(${initial_mount_node}, ${anchor_node});`);
    if (branch.dependencies.length > 0) {
      const update_mount_node = this.get_update_mount_node(anchor);
      const enter = b`
				if (${name49}) {
					${dynamic && b`${name49}.p(${if_ctx}, #dirty);`}
					${has_transitions && b`if (${block.renderer.dirty(branch.dependencies)}) {
									@transition_in(${name49}, 1);
								}`}
				} else {
					${name49} = ${branch.block.name}(${if_ctx});
					${name49}.c();
					${has_transitions && b`@transition_in(${name49}, 1);`}
					${name49}.m(${update_mount_node}, ${anchor});
				}
			`;
      if (branch.snippet) {
        block.chunks.update.push(
          b`if (${block.renderer.dirty(branch.dependencies)}) ${branch.condition} = ${branch.snippet}`
        );
      }
      if (branch.block.has_outro_method) {
        block.chunks.update.push(b`
					if (${branch.condition}) {
						${enter}
					} else if (${name49}) {
						@group_outros();
						@transition_out(${name49}, 1, 1, () => {
							${name49} = null;
						});
						@check_outros();
					}
				`);
      } else {
        block.chunks.update.push(b`
					if (${branch.condition}) {
						${enter}
					} else if (${name49}) {
						${name49}.d(1);
						${name49} = null;
					}
				`);
      }
    } else if (dynamic) {
      block.chunks.update.push(b`
				if (${branch.condition}) ${name49}.p(${if_ctx}, #dirty);
			`);
    }
    if (if_exists_condition) {
      block.chunks.destroy.push(b`
				if (${if_exists_condition}) ${name49}.d(${detaching});
			`);
    } else {
      block.chunks.destroy.push(b`
				${name49}.d(${detaching});
			`);
    }
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/KeyBlock.js
var KeyBlockWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/KeyBlock.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @type {import('./Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {import('../Block.js').default} */
    __publicField(this, "block");
    /** @type {string[]} */
    __publicField(this, "dependencies");
    /** @type {import('estree').Identifier} */
    __publicField(this, "var", { type: "Identifier", name: "key_block" });
    this.dependencies = node.expression.dynamic_dependencies();
    if (this.dependencies.length) {
      block = block.child({
        comment: create_debugging_comment(node, renderer.component),
        name: renderer.component.get_unique_name("create_key_block"),
        type: "key"
      });
      block.add_dependencies(node.expression.dependencies);
      renderer.blocks.push(block);
    }
    this.block = block;
    this.fragment = new FragmentWrapper(
      renderer,
      this.block,
      node.children,
      this,
      strip_whitespace,
      next_sibling
    );
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    if (this.dependencies.length === 0) {
      this.render_static_key(block, parent_node, parent_nodes);
    } else {
      this.render_dynamic_key(block, parent_node, parent_nodes);
    }
  }
  /**
   * @param {import('../Block.js').default} _block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render_static_key(_block, parent_node, parent_nodes) {
    this.fragment.render(this.block, parent_node, parent_nodes);
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render_dynamic_key(block, parent_node, parent_nodes) {
    this.fragment.render(
      this.block,
      null,
      /** @type {unknown} */
      /** @type {import('estree').Identifier} */
      x`#nodes`
    );
    const has_transitions = !!(this.block.has_intro_method || this.block.has_outro_method);
    const dynamic = this.block.has_update_method;
    const previous_key = block.get_unique_name("previous_key");
    const snippet = this.node.expression.manipulate(block);
    block.add_variable(previous_key, snippet);
    const not_equal = this.renderer.component.component_options.immutable ? x`@not_equal` : x`@safe_not_equal`;
    const condition = x`${this.renderer.dirty(
      this.dependencies
    )} && ${not_equal}(${previous_key}, ${previous_key} = ${snippet})`;
    block.chunks.init.push(b`
			let ${this.var} = ${this.block.name}(#ctx);
		`);
    block.chunks.create.push(b`${this.var}.c();`);
    if (this.renderer.options.hydratable) {
      block.chunks.claim.push(b`${this.var}.l(${parent_nodes});`);
    }
    block.chunks.mount.push(
      b`${this.var}.m(${parent_node || "#target"}, ${parent_node ? "null" : "#anchor"});`
    );
    const anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
    const body = b`
			${has_transitions ? b`
						@group_outros();
						@transition_out(${this.var}, 1, 1, @noop);
						@check_outros();
					` : b`${this.var}.d(1);`}
			${this.var} = ${this.block.name}(#ctx);
			${this.var}.c();
			${has_transitions && b`@transition_in(${this.var}, 1)`}
			${this.var}.m(${this.get_update_mount_node(anchor)}, ${anchor});
		`;
    if (dynamic) {
      block.chunks.update.push(b`
				if (${condition}) {
					${body}
				} else {
					${this.var}.p(#ctx, #dirty);
				}
			`);
    } else {
      block.chunks.update.push(b`
				if (${condition}) {
					${body}
				}
			`);
    }
    if (has_transitions) {
      block.chunks.intro.push(b`@transition_in(${this.var})`);
      block.chunks.outro.push(b`@transition_out(${this.var})`);
    }
    block.chunks.destroy.push(b`${this.var}.d(detaching)`);
  }
};

// node_modules/svelte/src/compiler/compile/utils/string_to_member_expression.js
function string_to_member_expression(name49) {
  const parts = name49.split(".");
  let node = {
    type: "Identifier",
    name: parts[0]
  };
  for (let i = 1; i < parts.length; i++) {
    node = /** @type {import('estree').MemberExpression} */
    {
      type: "MemberExpression",
      object: node,
      property: { type: "Identifier", name: parts[i] }
    };
  }
  return node;
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/shared/get_slot_definition.js
function get_slot_definition(block, scope, lets) {
  if (lets.length === 0)
    return { block, scope };
  const context_input = {
    type: "ObjectPattern",
    properties: lets.map((l) => ({
      type: "Property",
      kind: "init",
      key: l.name,
      value: l.value || l.name
    }))
  };
  const properties3 = [];
  const value_map = /* @__PURE__ */ new Map();
  lets.forEach((l) => {
    let value;
    if (l.names.length > 1) {
      const unique_name = block.get_unique_name(l.names.join("_")).name;
      value_map.set(l.value, unique_name);
      value = { type: "Identifier", name: unique_name };
    } else {
      value = l.value || l.name;
    }
    properties3.push({
      type: "Property",
      kind: "init",
      key: l.name,
      value
    });
  });
  const changes_input = {
    type: "ObjectPattern",
    properties: properties3
  };
  const names = /* @__PURE__ */ new Set();
  const names_lookup = /* @__PURE__ */ new Map();
  lets.forEach((l) => {
    l.names.forEach((name49) => {
      names.add(name49);
      if (value_map.has(l.value)) {
        names_lookup.set(name49, value_map.get(l.value));
      }
    });
  });
  const context = {
    type: "ObjectExpression",
    properties: Array.from(names).map(
      (name49) => p`${block.renderer.context_lookup.get(name49).index}: ${name49}`
    )
  };
  const { context_lookup } = block.renderer;
  const changes = {
    type: "ParenthesizedExpression",
    get expression() {
      if (block.renderer.context_overflow) {
        const grouped = [];
        Array.from(names).forEach((name49) => {
          const i = (
            /** @type {number} */
            context_lookup.get(name49).index.value
          );
          const g = Math.floor(i / 31);
          const lookup_name = names_lookup.has(name49) ? names_lookup.get(name49) : name49;
          if (!grouped[g])
            grouped[g] = [];
          grouped[g].push({ name: lookup_name, n: i % 31 });
        });
        const elements = [];
        for (let g = 0; g < grouped.length; g += 1) {
          elements[g] = grouped[g] ? grouped[g].map(({ name: name49, n: n2 }) => x`${name49} ? ${1 << n2} : 0`).reduce((lhs, rhs) => x`${lhs} | ${rhs}`) : x`0`;
        }
        return {
          type: "ArrayExpression",
          elements
        };
      }
      return (
        /** @type {import('estree').BinaryExpression} */
        Array.from(names).map((name49) => {
          const lookup_name = names_lookup.has(name49) ? names_lookup.get(name49) : name49;
          const i = (
            /** @type {number} */
            context_lookup.get(name49).index.value
          );
          return x`${lookup_name} ? ${1 << i} : 0`;
        }).reduce((lhs, rhs) => x`${lhs} | ${rhs}`)
      );
    }
  };
  return {
    block,
    scope,
    get_context: x`${context_input} => ${context}`,
    get_changes: x`${changes_input} => ${changes}`
  };
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/SlotTemplate.js
var SlotTemplateWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/SlotTemplate.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @type {import('./Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {import('../Block.js').default} */
    __publicField(this, "block");
    const { scope, lets, const_tags, slot_template_name } = this.node;
    lets.forEach((l) => {
      extract_names(l.value || l.name).forEach((name49) => {
        renderer.add_to_context(name49, true);
      });
    });
    add_const_tags_context(renderer, const_tags);
    this.block = block.child({
      comment: create_debugging_comment(this.node, this.renderer.component),
      name: this.renderer.component.get_unique_name(`create_${sanitize(slot_template_name)}_slot`),
      type: "slot"
    });
    this.renderer.blocks.push(this.block);
    this.parent.set_slot(
      slot_template_name,
      get_slot_definition(this.block, scope, lets)
    );
    this.fragment = new FragmentWrapper(
      renderer,
      this.block,
      node.type === "SlotTemplate" ? node.children : [node],
      this,
      strip_whitespace,
      next_sibling
    );
    this.block.parent.add_dependencies(this.block.dependencies);
  }
  render() {
    this.fragment.render(
      this.block,
      null,
      /** @type {import('estree').Identifier} */
      x`#nodes`
    );
    if (this.node.const_tags.length > 0) {
      this.render_get_context();
    }
  }
  render_get_context() {
    const get_context2 = this.block.renderer.component.get_unique_name("get_context");
    this.block.renderer.blocks.push(b`
			function ${get_context2}(#ctx) {
				${add_const_tags(this.block, this.node.const_tags, "#ctx")}
			}
		`);
    this.block.chunks.declarations.push(b`${get_context2}(#ctx)`);
    if (this.block.has_update_method) {
      this.block.chunks.update.unshift(b`${get_context2}(#ctx)`);
    }
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/InlineComponent/index.js
var regex_invalid_variable_identifier_characters4 = /[^a-zA-Z_$]/g;
var InlineComponentWrapper = class extends Wrapper {
  /**
   * @param {import('../../Renderer.js').default} renderer
   * @param {import('../../Block.js').default} block
   * @param {import('../shared/Wrapper.js').default} parent
   * @param {import('../../../nodes/InlineComponent.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('../shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /**
     * @typedef {{
     * 	block: import('../../Block.js').default;
     * 	scope: import('../../../nodes/shared/TemplateScope.js').default;
     * 	get_context?: import('estree').Node;
     * 	get_changes?: import('estree').Node;
     * }} SlotDefinition
     */
    /** @type {Map<string, SlotDefinition>} */
    __publicField(this, "slots", /* @__PURE__ */ new Map());
    /** @type {import('../Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {Array<Wrapper | import('../Fragment.js').default>} */
    __publicField(this, "children", []);
    if (this.node.expression) {
      block.add_dependencies(this.node.expression.dependencies);
    }
    this.node.attributes.forEach((attr) => {
      block.add_dependencies(attr.dependencies);
    });
    this.node.bindings.forEach((binding) => {
      if (binding.is_contextual) {
        mark_each_block_bindings(this, binding);
      }
      block.add_dependencies(binding.expression.dependencies);
    });
    this.node.handlers.forEach((handler) => {
      if (handler.expression) {
        block.add_dependencies(handler.expression.dependencies);
      }
    });
    this.node.css_custom_properties.forEach((attr) => {
      block.add_dependencies(attr.dependencies);
    });
    this.var = {
      type: (
        /** @type {const} */
        "Identifier"
      ),
      name: (this.node.name === "svelte:self" ? renderer.component.name.name : this.node.name === "svelte:component" ? "switch_instance" : sanitize(this.node.name)).toLowerCase()
    };
    if (this.node.children.length) {
      this.children = this.node.children.map(
        (child) => new SlotTemplateWrapper(
          renderer,
          block,
          this,
          /** @type {import('../../../nodes/SlotTemplate.js').default} */
          child,
          strip_whitespace,
          next_sibling
        )
      );
    }
    block.add_outro();
  }
  /**
   * @param {string} name
   * @param {SlotDefinition} slot_definition
   */
  set_slot(name49, slot_definition) {
    if (this.slots.has(name49)) {
      if (name49 === "default") {
        throw new Error('Found elements without slot attribute when using slot="default"');
      }
      throw new Error(`Duplicate slot name "${name49}" in <${this.node.name}>`);
    }
    this.slots.set(name49, slot_definition);
  }
  warn_if_reactive() {
    let { name: name49 } = this.node;
    const top = name49.split(".")[0];
    const variable = this.renderer.component.var_lookup.get(top);
    if (!variable) {
      return;
    }
    const ignores = extract_ignores_above_node(this.node);
    this.renderer.component.push_ignores(ignores);
    if (variable.reassigned || variable.export_name || // or a prop
    variable.mutated) {
      this.renderer.component.warn(this.node, compiler_warnings_default.reactive_component(name49));
    }
    this.renderer.component.pop_ignores();
  }
  /**
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    this.warn_if_reactive();
    const { renderer } = this;
    const { component } = renderer;
    const name49 = this.var;
    block.add_variable(name49);
    const component_opts = (
      /** @type {import('estree').ObjectExpression} */
      x`{}`
    );
    const statements = [];
    const updates = [];
    this.children.forEach((child) => {
      this.renderer.add_to_context("$$scope", true);
      child.render(
        block,
        null,
        /** @type {import('estree').Identifier} */
        x`#nodes`
      );
    });
    let props;
    const name_changes = block.get_unique_name(`${name49.name}_changes`);
    const uses_spread = !!this.node.attributes.find((a) => a.is_spread);
    for (const slot of this.slots.keys()) {
      if (!this.slots.get(slot).block.has_content()) {
        this.renderer.remove_block(this.slots.get(slot).block);
        this.slots.delete(slot);
      }
    }
    const has_css_custom_properties = this.node.css_custom_properties.length > 0;
    const is_svg_namespace = this.node.namespace === namespaces.svg;
    const css_custom_properties_wrapper_element = is_svg_namespace ? "g" : "div";
    const css_custom_properties_wrapper = has_css_custom_properties ? block.get_unique_name(css_custom_properties_wrapper_element) : null;
    if (has_css_custom_properties) {
      block.add_variable(css_custom_properties_wrapper);
    }
    const initial_props = this.slots.size > 0 ? [
      p`$$slots: {
					${Array.from(this.slots).map(([name50, slot]) => {
        return p`${name50}: [${slot.block.name}, ${slot.get_context || null}, ${slot.get_changes || null}]`;
      })}
				}`,
      p`$$scope: {
					ctx: #ctx
				}`
    ] : [];
    const attribute_object = uses_spread ? x`{ ${initial_props} }` : x`{
				${this.node.attributes.map((attr) => p`${attr.name}: ${attr.get_value(block)}`)},
				${initial_props}
			}`;
    if (this.node.attributes.length || this.node.bindings.length || initial_props.length) {
      if (!uses_spread && this.node.bindings.length === 0) {
        component_opts.properties.push(p`props: ${attribute_object}`);
      } else {
        props = block.get_unique_name(`${name49.name}_props`);
        component_opts.properties.push(p`props: ${props}`);
      }
    }
    if (component.compile_options.dev) {
      component_opts.properties.push(p`$$inline: true`);
    }
    const fragment_dependencies = new Set(this.slots.size ? ["$$scope"] : []);
    this.slots.forEach((slot) => {
      slot.block.dependencies.forEach((name50) => {
        const is_let = slot.scope.is_let(name50);
        const variable = renderer.component.var_lookup.get(name50);
        if (is_let || is_dynamic(variable))
          fragment_dependencies.add(name50);
      });
    });
    const dynamic_attributes = this.node.attributes.filter((a) => a.get_dependencies().length > 0);
    if (!uses_spread && (dynamic_attributes.length > 0 || this.node.bindings.length > 0 || fragment_dependencies.size > 0)) {
      updates.push(b`const ${name_changes} = {};`);
    }
    if (this.node.attributes.length) {
      if (uses_spread) {
        const levels = block.get_unique_name(`${this.var.name}_spread_levels`);
        const initial_props2 = [];
        const changes = [];
        const all_dependencies = /* @__PURE__ */ new Set();
        this.node.attributes.forEach((attr) => {
          add_to_set(all_dependencies, attr.dependencies);
        });
        this.node.attributes.forEach((attr, i) => {
          const { name: name50, dependencies } = attr;
          const condition = dependencies.size > 0 && dependencies.size !== all_dependencies.size ? renderer.dirty(Array.from(dependencies)) : null;
          const unchanged = dependencies.size === 0;
          let change_object;
          if (attr.is_spread) {
            const value = attr.expression.manipulate(block);
            initial_props2.push(value);
            let value_object = value;
            if (attr.expression.node.type !== "ObjectExpression") {
              value_object = x`@get_spread_object(${value})`;
            }
            change_object = value_object;
          } else {
            const obj = x`{ ${name50}: ${attr.get_value(block)} }`;
            initial_props2.push(obj);
            change_object = obj;
          }
          changes.push(
            unchanged ? x`${levels}[${i}]` : condition ? x`${condition} && ${change_object}` : change_object
          );
        });
        block.chunks.init.push(b`
					const ${levels} = [
						${initial_props2}
					];
				`);
        statements.push(b`
					for (let #i = 0; #i < ${levels}.length; #i += 1) {
						${props} = @assign(${props}, ${levels}[#i]);
					}
				`);
        if (all_dependencies.size) {
          const condition = renderer.dirty(Array.from(all_dependencies));
          if (this.node.name === "svelte:component") {
            statements[statements.length - 1] = b`
							for (let #i = 0; #i < ${levels}.length; #i += 1) {
								${props} = @assign(${props}, ${levels}[#i]);
							}
							if (#dirty !== undefined && ${condition}) {
								${props} = @assign(${props}, @get_spread_update(${levels}, [
									${changes}
								]));
							}
						`;
          }
          updates.push(b`
						const ${name_changes} = ${condition} ? @get_spread_update(${levels}, [
							${changes}
						]) : {}
					`);
        } else {
          updates.push(b`
						const ${name_changes} = {};
					`);
        }
      } else {
        dynamic_attributes.forEach((attribute) => {
          const dependencies = attribute.get_dependencies();
          if (dependencies.length > 0) {
            const condition = renderer.dirty(dependencies);
            updates.push(b`
							if (${condition}) ${name_changes}.${attribute.name} = ${attribute.get_value(block)};
						`);
          }
        });
      }
    }
    if (fragment_dependencies.size > 0) {
      updates.push(b`
				if (${renderer.dirty(Array.from(fragment_dependencies))}) {
					${name_changes}.$$scope = { dirty: #dirty, ctx: #ctx };
				}`);
    }
    const munged_bindings = this.node.bindings.map((binding) => {
      component.has_reactive_assignments = true;
      if (binding.name === "this") {
        return bind_this(component, block, new BindingWrapper(block, binding, this), this.var);
      }
      const id2 = component.get_unique_name(`${this.var.name}_${binding.name}_binding`);
      renderer.add_to_context(id2.name);
      const callee = renderer.reference(id2);
      const updating = block.get_unique_name(`updating_${binding.name}`);
      block.add_variable(updating);
      const snippet = binding.expression.manipulate(block);
      statements.push(b`
				if (${snippet} !== void 0) {
					${props}.${binding.name} = ${snippet};
				}`);
      updates.push(b`
				if (!${updating} && ${renderer.dirty(Array.from(binding.expression.dependencies))}) {
					${updating} = true;
					${name_changes}.${binding.name} = ${snippet};
					@add_flush_callback(() => ${updating} = false);
				}
			`);
      const contextual_dependencies = Array.from(binding.expression.contextual_dependencies);
      const dependencies = Array.from(binding.expression.dependencies);
      let lhs = binding.raw_expression;
      if (binding.is_contextual && binding.expression.node.type === "Identifier") {
        const { name: name50 } = binding.expression.node;
        const { object, property: property2, snippet: snippet2 } = block.bindings.get(name50);
        lhs = snippet2;
        contextual_dependencies.push(object.name, property2.name);
      }
      const params = [
        /** @type {import('estree').Identifier} */
        x`#value`
      ];
      const args = [x`#value`];
      if (contextual_dependencies.length > 0) {
        contextual_dependencies.forEach((name50) => {
          params.push({
            type: "Identifier",
            name: name50
          });
          renderer.add_to_context(name50, true);
          args.push(renderer.reference(name50));
        });
        block.maintain_context = true;
      }
      block.chunks.init.push(b`
				function ${id2}(#value) {
					${callee}(${args});
				}
			`);
      let invalidate_binding = b`
				${lhs} = #value;
				${renderer.invalidate(dependencies[0])};
			`;
      if (binding.expression.node.type === "MemberExpression") {
        invalidate_binding = b`
					if ($$self.$$.not_equal(${lhs}, #value)) {
						${invalidate_binding}
					}
				`;
      }
      const body = b`
				function ${id2}(${params}) {
					${invalidate_binding}
				}
			`;
      component.partly_hoisted.push(body);
      return b`@binding_callbacks.push(() => @bind(${this.var}, '${binding.name}', ${id2}));`;
    });
    const munged_handlers = this.node.handlers.map((handler) => {
      const event_handler = new EventHandlerWrapper(handler, this);
      let snippet = event_handler.get_snippet(block);
      if (handler.modifiers.has("once"))
        snippet = x`@once(${snippet})`;
      return b`${name49}.$on("${handler.name}", ${snippet});`;
    });
    const mount_target = has_css_custom_properties ? css_custom_properties_wrapper : parent_node || "#target";
    const mount_anchor = has_css_custom_properties ? "null" : parent_node ? "null" : "#anchor";
    const to_claim = parent_nodes && this.renderer.options.hydratable;
    let claim_nodes = parent_nodes;
    if (this.node.name === "svelte:component") {
      const switch_value = block.get_unique_name("switch_value");
      const switch_props = block.get_unique_name("switch_props");
      const snippet = this.node.expression.manipulate(block);
      const dependencies = this.node.expression.dynamic_dependencies();
      if (has_css_custom_properties) {
        this.set_css_custom_properties(
          block,
          css_custom_properties_wrapper,
          css_custom_properties_wrapper_element,
          is_svg_namespace
        );
      }
      block.chunks.init.push(b`
				var ${switch_value} = ${snippet};

				function ${switch_props}(#ctx, #dirty) {
					${(this.node.attributes.length > 0 || this.node.bindings.length > 0) && b`
					${props && b`let ${props} = ${attribute_object};`}`}
					${statements}
					return ${component_opts};
				}

				if (${switch_value}) {
					${name49} = @construct_svelte_component(${switch_value}, ${switch_props}(#ctx));

					${munged_bindings}
					${munged_handlers}
				}
			`);
      block.chunks.create.push(b`if (${name49}) @create_component(${name49}.$$.fragment);`);
      if (css_custom_properties_wrapper)
        this.create_css_custom_properties_wrapper_mount_chunk(
          block,
          parent_node,
          css_custom_properties_wrapper
        );
      block.chunks.mount.push(
        b`if (${name49}) @mount_component(${name49}, ${mount_target}, ${mount_anchor});`
      );
      if (to_claim) {
        if (css_custom_properties_wrapper)
          claim_nodes = this.create_css_custom_properties_wrapper_claim_chunk(
            block,
            claim_nodes,
            css_custom_properties_wrapper,
            css_custom_properties_wrapper_element,
            is_svg_namespace
          );
        block.chunks.claim.push(
          b`if (${name49}) @claim_component(${name49}.$$.fragment, ${claim_nodes});`
        );
      }
      const tmp_anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
      const anchor = has_css_custom_properties ? "null" : tmp_anchor;
      const update_mount_node = has_css_custom_properties ? css_custom_properties_wrapper : this.get_update_mount_node(tmp_anchor);
      const update_insert = css_custom_properties_wrapper && (tmp_anchor.name !== "null" ? b`@insert(${tmp_anchor}.parentNode, ${css_custom_properties_wrapper}, ${tmp_anchor});` : b`@insert(${parent_node}, ${css_custom_properties_wrapper}, ${tmp_anchor});`);
      let update_condition = x`${switch_value} !== (${switch_value} = ${snippet})`;
      if (dependencies.length > 0) {
        update_condition = x`${block.renderer.dirty(dependencies)} && ${update_condition}`;
      }
      block.chunks.update.push(b`
				if (${update_condition}) {
					if (${name49}) {
						@group_outros();
						const old_component = ${name49};
						@transition_out(old_component.$$.fragment, 1, 0, () => {
							@destroy_component(old_component, 1);
							${has_css_custom_properties ? b`@detach(${update_mount_node})` : null}
						});
						@check_outros();
					}

					if (${switch_value}) {
						${update_insert}
						${name49} = @construct_svelte_component(${switch_value}, ${switch_props}(#ctx, #dirty));

						${munged_bindings}
						${munged_handlers}

						@create_component(${name49}.$$.fragment);
						@transition_in(${name49}.$$.fragment, 1);
						@mount_component(${name49}, ${update_mount_node}, ${anchor});
					} else {
						${name49} = null;
					}
				} else if (${switch_value}) {
					${updates}
					${updates.length > 0 && b`${name49}.$set(${name_changes});`}
				}
			`);
      block.chunks.intro.push(b`
				if (${name49}) @transition_in(${name49}.$$.fragment, #local);
			`);
      block.chunks.outro.push(b`if (${name49}) @transition_out(${name49}.$$.fragment, #local);`);
      block.chunks.destroy.push(
        b`if (${name49}) @destroy_component(${name49}, ${parent_node ? null : "detaching"});`
      );
    } else {
      const expression = this.node.name === "svelte:self" ? component.name : this.renderer.reference(string_to_member_expression(this.node.name));
      block.chunks.init.push(b`
				${(this.node.attributes.length > 0 || this.node.bindings.length > 0) && b`
				${props && b`let ${props} = ${attribute_object};`}`}
				${statements}
				${name49} = new ${expression}(${component_opts});

				${munged_bindings}
				${munged_handlers}
			`);
      if (has_css_custom_properties) {
        this.set_css_custom_properties(
          block,
          css_custom_properties_wrapper,
          css_custom_properties_wrapper_element,
          is_svg_namespace
        );
      }
      block.chunks.create.push(b`@create_component(${name49}.$$.fragment);`);
      if (css_custom_properties_wrapper)
        this.create_css_custom_properties_wrapper_mount_chunk(
          block,
          parent_node,
          css_custom_properties_wrapper
        );
      block.chunks.mount.push(b`@mount_component(${name49}, ${mount_target}, ${mount_anchor});`);
      if (to_claim) {
        if (css_custom_properties_wrapper)
          claim_nodes = this.create_css_custom_properties_wrapper_claim_chunk(
            block,
            claim_nodes,
            css_custom_properties_wrapper,
            css_custom_properties_wrapper_element,
            is_svg_namespace
          );
        block.chunks.claim.push(b`@claim_component(${name49}.$$.fragment, ${claim_nodes});`);
      }
      block.chunks.intro.push(b`
				@transition_in(${name49}.$$.fragment, #local);
			`);
      if (updates.length) {
        block.chunks.update.push(b`
					${updates}
					${name49}.$set(${name_changes});
				`);
      }
      block.chunks.destroy.push(b`
				@destroy_component(${name49}, ${parent_node ? null : "detaching"});
			`);
      block.chunks.outro.push(b`@transition_out(${name49}.$$.fragment, #local);`);
    }
  }
  /**
   * @private
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier | null} css_custom_properties_wrapper
   */
  create_css_custom_properties_wrapper_mount_chunk(block, parent_node, css_custom_properties_wrapper) {
    if (parent_node) {
      block.chunks.mount.push(b`@append(${parent_node}, ${css_custom_properties_wrapper})`);
      if (is_head(parent_node)) {
        block.chunks.destroy.push(b`@detach(${css_custom_properties_wrapper});`);
      }
    } else {
      block.chunks.mount.push(b`@insert(#target, ${css_custom_properties_wrapper}, #anchor);`);
      block.chunks.destroy.push(
        b`if (detaching && ${this.var}) @detach(${css_custom_properties_wrapper});`
      );
    }
  }
  /**
   * @private
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Identifier} parent_nodes
   * @param {import('estree').Identifier | null} css_custom_properties_wrapper
   * @param {string} css_custom_properties_wrapper_element
   * @param {boolean} is_svg_namespace
   */
  create_css_custom_properties_wrapper_claim_chunk(block, parent_nodes, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace) {
    const nodes = block.get_unique_name(`${css_custom_properties_wrapper.name}_nodes`);
    const claim_element = is_svg_namespace ? x`@claim_svg_element` : x`@claim_element`;
    block.chunks.claim.push(b`
			${css_custom_properties_wrapper} = ${claim_element}(${parent_nodes}, "${css_custom_properties_wrapper_element.toUpperCase()}", { style: true })
			var ${nodes} = @children(${css_custom_properties_wrapper});
		`);
    return nodes;
  }
  /**
   * @private
   * @param {import('../../Block.js').default} block
   * @param {import('estree').Identifier} css_custom_properties_wrapper
   * @param {string} css_custom_properties_wrapper_element
   * @param {boolean} is_svg_namespace
   */
  set_css_custom_properties(block, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace) {
    const element = is_svg_namespace ? x`@svg_element` : x`@element`;
    block.chunks.create.push(
      b`${css_custom_properties_wrapper} = ${element}("${css_custom_properties_wrapper_element}");`
    );
    if (!is_svg_namespace)
      block.chunks.hydrate.push(
        b`@set_style(${css_custom_properties_wrapper}, "display", "contents");`
      );
    this.node.css_custom_properties.forEach((attr) => {
      const dependencies = attr.get_dependencies();
      const should_cache2 = attr.should_cache();
      const last = should_cache2 && block.get_unique_name(
        `${attr.name.replace(regex_invalid_variable_identifier_characters4, "_")}_last`
      );
      if (should_cache2)
        block.add_variable(last);
      const value = attr.get_value(block);
      const init = should_cache2 ? x`${last} = ${value}` : value;
      block.chunks.hydrate.push(
        b`@set_style(${css_custom_properties_wrapper}, "${attr.name}", ${init});`
      );
      if (dependencies.length > 0) {
        let condition = block.renderer.dirty(dependencies);
        if (should_cache2)
          condition = x`${condition} && (${last} !== (${last} = ${value}))`;
        block.chunks.update.push(b`
					if (${condition}) {
						@set_style(${css_custom_properties_wrapper}, "${attr.name}", ${should_cache2 ? last : value});
					}
				`);
      }
    });
  }
};

// node_modules/svelte/src/compiler/compile/utils/get_slot_data.js
function get_slot_data(values, block = null) {
  return {
    type: "ObjectExpression",
    properties: Array.from(values.values()).filter((attribute) => attribute.name !== "name").map((attribute) => {
      if (attribute.is_spread) {
        const argument = get_spread_value(block, attribute);
        return {
          type: "SpreadElement",
          argument
        };
      }
      const value = get_value(block, attribute);
      return p`${attribute.name}: ${value}`;
    })
  };
}
function get_value(block, attribute) {
  if (attribute.is_true)
    return x`true`;
  if (attribute.chunks.length === 0)
    return x`""`;
  let value = attribute.chunks.map(
    (chunk) => chunk.type === "Text" ? string_literal(chunk.data) : block ? chunk.manipulate(block) : chunk.node
  ).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
  if (attribute.chunks.length > 1 && attribute.chunks[0].type !== "Text") {
    value = x`"" + ${value}`;
  }
  return value;
}
function get_spread_value(block, attribute) {
  return block ? attribute.expression.manipulate(block) : attribute.expression.node;
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Slot.js
var SlotWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/Slot.js').default} node
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, parent, node, strip_whitespace, next_sibling) {
    super(renderer, block, parent, node);
    /** @type {import('./Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {import('../Block.js').default | null} */
    __publicField(this, "fallback", null);
    /** @type {import('../Block.js').default} */
    __publicField(this, "slot_block");
    /** @type {import('estree').Identifier} */
    __publicField(this, "var", { type: "Identifier", name: "slot" });
    /** @type {Set<string>} */
    __publicField(this, "dependencies", /* @__PURE__ */ new Set(["$$scope"]));
    if (this.node.children.length) {
      this.fallback = block.child({
        comment: create_debugging_comment(this.node.children[0], this.renderer.component),
        name: this.renderer.component.get_unique_name("fallback_block"),
        type: "fallback"
      });
      renderer.blocks.push(this.fallback);
    }
    this.fragment = new FragmentWrapper(
      renderer,
      this.fallback,
      node.children,
      this,
      strip_whitespace,
      next_sibling
    );
    this.node.values.forEach((attribute) => {
      add_to_set(this.dependencies, attribute.dependencies);
    });
    block.add_dependencies(this.dependencies);
    block.add_intro();
    block.add_outro();
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    const { renderer } = this;
    const { slot_name } = this.node;
    if (this.slot_block) {
      block = this.slot_block;
    }
    let get_slot_changes_fn;
    let get_slot_spread_changes_fn;
    let get_slot_context_fn;
    if (this.node.values.size > 0) {
      get_slot_changes_fn = renderer.component.get_unique_name(
        `get_${sanitize(slot_name)}_slot_changes`
      );
      get_slot_context_fn = renderer.component.get_unique_name(
        `get_${sanitize(slot_name)}_slot_context`
      );
      const changes = (
        /** @type {import('estree').ObjectExpression} */
        x`{}`
      );
      const spread_dynamic_dependencies = /* @__PURE__ */ new Set();
      this.node.values.forEach((attribute) => {
        if (attribute.type === "Spread") {
          add_to_set(
            spread_dynamic_dependencies,
            Array.from(attribute.dependencies).filter((name49) => this.is_dependency_dynamic(name49))
          );
        } else {
          const dynamic_dependencies2 = Array.from(attribute.dependencies).filter(
            (name49) => this.is_dependency_dynamic(name49)
          );
          if (dynamic_dependencies2.length > 0) {
            changes.properties.push(p`${attribute.name}: ${renderer.dirty(dynamic_dependencies2)}`);
          }
        }
      });
      renderer.blocks.push(b`
				const ${get_slot_changes_fn} = #dirty => ${changes};
				const ${get_slot_context_fn} = #ctx => ${get_slot_data(this.node.values, block)};
			`);
      if (spread_dynamic_dependencies.size) {
        get_slot_spread_changes_fn = renderer.component.get_unique_name(
          `get_${sanitize(slot_name)}_slot_spread_changes`
        );
        renderer.blocks.push(b`
					const ${get_slot_spread_changes_fn} = #dirty => ${renderer.dirty(
          Array.from(spread_dynamic_dependencies)
        )};
				`);
      }
    } else {
      get_slot_changes_fn = "null";
      get_slot_context_fn = "null";
    }
    let has_fallback = !!this.fallback;
    if (this.fallback) {
      this.fragment.render(
        this.fallback,
        null,
        /** @type {import('estree').Identifier} */
        x`#nodes`
      );
      has_fallback = this.fallback.has_content();
      if (!has_fallback) {
        renderer.remove_block(this.fallback);
      }
    }
    const slot = block.get_unique_name(`${sanitize(slot_name)}_slot`);
    const slot_definition = block.get_unique_name(`${sanitize(slot_name)}_slot_template`);
    const slot_or_fallback = has_fallback ? block.get_unique_name(`${sanitize(slot_name)}_slot_or_fallback`) : slot;
    block.chunks.init.push(b`
			const ${slot_definition} = ${renderer.reference("#slots")}.${slot_name};
			const ${slot} = @create_slot(${slot_definition}, #ctx, ${renderer.reference(
      "$$scope"
    )}, ${get_slot_context_fn});
			${has_fallback ? b`const ${slot_or_fallback} = ${slot} || ${this.fallback.name}(#ctx);` : null}
		`);
    block.chunks.create.push(b`if (${slot_or_fallback}) ${slot_or_fallback}.c();`);
    if (renderer.options.hydratable) {
      block.chunks.claim.push(b`if (${slot_or_fallback}) ${slot_or_fallback}.l(${parent_nodes});`);
    }
    block.chunks.mount.push(b`
			if (${slot_or_fallback}) {
				${slot_or_fallback}.m(${parent_node || "#target"}, ${parent_node ? "null" : "#anchor"});
			}
		`);
    block.chunks.intro.push(b`@transition_in(${slot_or_fallback}, #local);`);
    block.chunks.outro.push(b`@transition_out(${slot_or_fallback}, #local);`);
    const dynamic_dependencies = Array.from(this.dependencies).filter(
      (name49) => this.is_dependency_dynamic(name49)
    );
    const fallback_dynamic_dependencies = has_fallback ? Array.from(this.fallback.dependencies).filter((name49) => this.is_dependency_dynamic(name49)) : [];
    let condition = renderer.dirty(dynamic_dependencies);
    if (block.has_outros) {
      condition = x`!#current || ${condition}`;
    }
    const all_dirty_conditions = [
      get_slot_spread_changes_fn ? x`${get_slot_spread_changes_fn}(#dirty)` : null,
      block.has_outros ? x`!#current` : null
    ].filter(Boolean);
    const all_dirty_condition = all_dirty_conditions.length ? all_dirty_conditions.reduce((condition1, condition2) => x`${condition1} || ${condition2}`) : null;
    let slot_update;
    if (all_dirty_condition) {
      const dirty = x`${all_dirty_condition} ? @get_all_dirty_from_scope(${renderer.reference(
        "$$scope"
      )}) : @get_slot_changes(${slot_definition}, ${renderer.reference(
        "$$scope"
      )}, #dirty, ${get_slot_changes_fn})`;
      slot_update = b`
				if (${slot}.p && ${condition}) {
					@update_slot_base(${slot}, ${slot_definition}, #ctx, ${renderer.reference(
        "$$scope"
      )}, ${dirty}, ${get_slot_context_fn});
				}
			`;
    } else {
      slot_update = b`
				if (${slot}.p && ${condition}) {
					@update_slot(${slot}, ${slot_definition}, #ctx, ${renderer.reference(
        "$$scope"
      )}, #dirty, ${get_slot_changes_fn}, ${get_slot_context_fn});
				}
			`;
    }
    let fallback_condition = renderer.dirty(fallback_dynamic_dependencies);
    let fallback_dirty = x`#dirty`;
    if (block.has_outros) {
      fallback_condition = x`!#current || ${fallback_condition}`;
      fallback_dirty = x`!#current ? ${renderer.get_initial_dirty()} : ${fallback_dirty}`;
    }
    const fallback_update = has_fallback && fallback_dynamic_dependencies.length > 0 && b`
			if (${slot_or_fallback} && ${slot_or_fallback}.p && ${fallback_condition}) {
				${slot_or_fallback}.p(#ctx, ${fallback_dirty});
			}
		`;
    if (fallback_update) {
      block.chunks.update.push(b`
				if (${slot}) {
					${slot_update}
				} else {
					${fallback_update}
				}
			`);
    } else {
      block.chunks.update.push(b`
				if (${slot}) {
					${slot_update}
				}
			`);
    }
    block.chunks.destroy.push(b`if (${slot_or_fallback}) ${slot_or_fallback}.d(detaching);`);
  }
  /** @param {string} name */
  is_dependency_dynamic(name49) {
    if (name49 === "$$scope")
      return true;
    if (this.node.scope.is_let(name49))
      return true;
    if (is_reserved_keyword(name49))
      return true;
    const variable = this.renderer.component.var_lookup.get(name49);
    return is_dynamic(variable);
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Title.js
var TitleWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/Title.js').default} node
   * @param {boolean} _strip_whitespace
   * @param {import('./shared/Wrapper.js').default} _next_sibling
   */
  constructor(renderer, block, parent, node, _strip_whitespace, _next_sibling) {
    super(renderer, block, parent, node);
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} _parent_node
   * @param {import('estree').Identifier} _parent_nodes
   */
  render(block, _parent_node, _parent_nodes) {
    const is_dynamic3 = !!this.node.children.find((node) => node.type !== "Text");
    if (is_dynamic3) {
      let value;
      const all_dependencies = /* @__PURE__ */ new Set();
      if (this.node.children.length === 1) {
        const { expression } = this.node.children[0];
        value = expression.manipulate(block);
        add_to_set(all_dependencies, expression.dependencies);
      } else {
        value = this.node.children.map((chunk) => {
          if (chunk.type === "Text")
            return string_literal(chunk.data);
          chunk.expression.dependencies.forEach((d) => {
            all_dependencies.add(d);
          });
          return (
            /** @type {import('../../nodes/MustacheTag.js').default} */
            chunk.expression.manipulate(block)
          );
        }).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
        if (this.node.children[0].type !== "Text") {
          value = x`"" + ${value}`;
        }
      }
      const last = this.node.should_cache && block.get_unique_name("title_value");
      if (this.node.should_cache)
        block.add_variable(last);
      const init = this.node.should_cache ? x`${last} = ${value}` : value;
      block.chunks.init.push(b`@_document.title = ${init};`);
      const updater = b`@_document.title = ${this.node.should_cache ? last : value};`;
      if (all_dependencies.size) {
        const dependencies = Array.from(all_dependencies);
        let condition = block.renderer.dirty(dependencies);
        if (block.has_outros) {
          condition = x`!#current || ${condition}`;
        }
        if (this.node.should_cache) {
          condition = x`${condition} && (${last} !== (${last} = ${value}))`;
        }
        block.chunks.update.push(b`
					if (${condition}) {
						${updater}
					}`);
      }
    } else {
      const value = this.node.children.length > 0 ? string_literal(
        /** @type {import('../../nodes/Text.js').default} */
        this.node.children[0].data
      ) : x`""`;
      block.chunks.hydrate.push(b`@_document.title = ${value};`);
    }
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Window.js
var associated_events2 = {
  innerWidth: "resize",
  innerHeight: "resize",
  outerWidth: "resize",
  outerHeight: "resize",
  devicePixelRatio: "resize",
  scrollX: "scroll",
  scrollY: "scroll"
};
var properties2 = {
  scrollX: "pageXOffset",
  scrollY: "pageYOffset"
};
var readonly2 = /* @__PURE__ */ new Set([
  "innerWidth",
  "innerHeight",
  "outerWidth",
  "outerHeight",
  "devicePixelRatio",
  "online"
]);
var WindowWrapper = class extends Wrapper {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {import('../../nodes/Window.js').default} node
   */
  constructor(renderer, block, parent, node) {
    super(renderer, block, parent, node);
    /** @type {import('./Element/EventHandler.js').default[]} */
    __publicField(this, "handlers");
    this.handlers = this.node.handlers.map((handler) => new EventHandlerWrapper(handler, this));
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} _parent_node
   * @param {import('estree').Identifier} _parent_nodes
   */
  render(block, _parent_node, _parent_nodes) {
    const { renderer } = this;
    const { component } = renderer;
    const events2 = {};
    const bindings = {};
    add_actions(block, "@_window", this.node.actions);
    add_event_handlers(block, "@_window", this.handlers);
    this.node.bindings.forEach((binding) => {
      const binding_name = (
        /** @type {import('estree').Identifier} */
        binding.expression.node.name
      );
      if (readonly2.has(binding.name)) {
        renderer.readonly.add(binding_name);
      }
      bindings[binding.name] = binding_name;
      if (binding.name === "online")
        return;
      const associated_event = associated_events2[binding.name];
      const property2 = properties2[binding.name] || binding.name;
      if (!events2[associated_event])
        events2[associated_event] = [];
      events2[associated_event].push({
        name: binding_name,
        value: property2
      });
    });
    const scrolling = block.get_unique_name("scrolling");
    const clear_scrolling = block.get_unique_name("clear_scrolling");
    const scrolling_timeout = block.get_unique_name("scrolling_timeout");
    Object.keys(events2).forEach((event) => {
      const id2 = block.get_unique_name(`onwindow${event}`);
      const props = events2[event];
      renderer.add_to_context(id2.name);
      const fn = renderer.reference(id2.name);
      if (event === "scroll") {
        block.add_variable(scrolling, x`false`);
        block.add_variable(clear_scrolling, x`() => { ${scrolling} = false }`);
        block.add_variable(scrolling_timeout);
        const condition = bindings.scrollX && bindings.scrollY ? x`"${bindings.scrollX}" in this._state || "${bindings.scrollY}" in this._state` : x`"${bindings.scrollX || bindings.scrollY}" in this._state`;
        const scroll_x = bindings.scrollX && x`this._state.${bindings.scrollX}`;
        const scroll_y = bindings.scrollY && x`this._state.${bindings.scrollY}`;
        renderer.meta_bindings.push(b`
					if (${condition}) {
						@_scrollTo(${scroll_x || "@_window.pageXOffset"}, ${scroll_y || "@_window.pageYOffset"});
					}
					${scroll_x && `${scroll_x} = @_window.pageXOffset;`}
					${scroll_y && `${scroll_y} = @_window.pageYOffset;`}
				`);
        block.event_listeners.push(x`
					@listen(@_window, "${event}", () => {
						${scrolling} = true;
						@_clearTimeout(${scrolling_timeout});
						${scrolling_timeout} = @_setTimeout(${clear_scrolling}, 100);
						${fn}();
					})
				`);
      } else {
        props.forEach((prop) => {
          renderer.meta_bindings.push(b`this._state.${prop.name} = @_window.${prop.value};`);
        });
        block.event_listeners.push(x`
					@listen(@_window, "${event}", ${fn})
				`);
      }
      component.partly_hoisted.push(b`
				function ${id2}() {
					${props.map((prop) => renderer.invalidate(prop.name, x`${prop.name} = @_window.${prop.value}`))}
				}
			`);
      block.chunks.init.push(b`
				@add_render_callback(${fn});
			`);
      component.has_reactive_assignments = true;
    });
    if (bindings.scrollX || bindings.scrollY) {
      const condition = renderer.dirty([bindings.scrollX, bindings.scrollY].filter(Boolean));
      const scroll_x = bindings.scrollX ? renderer.reference(bindings.scrollX) : x`@_window.pageXOffset`;
      const scroll_y = bindings.scrollY ? renderer.reference(bindings.scrollY) : x`@_window.pageYOffset`;
      block.chunks.update.push(b`
				if (${condition} && !${scrolling}) {
					${scrolling} = true;
					@_clearTimeout(${scrolling_timeout});
					@_scrollTo(${scroll_x}, ${scroll_y});
					${scrolling_timeout} = @_setTimeout(${clear_scrolling}, 100);
				}
			`);
    }
    if (bindings.online) {
      const id2 = block.get_unique_name("onlinestatuschanged");
      const name49 = bindings.online;
      renderer.add_to_context(id2.name);
      const reference = renderer.reference(id2.name);
      component.partly_hoisted.push(b`
				function ${id2}() {
					${renderer.invalidate(name49, x`${name49} = @_navigator.onLine`)}
				}
			`);
      block.chunks.init.push(b`
				@add_render_callback(${reference});
			`);
      block.event_listeners.push(
        x`@listen(@_window, "online", ${reference})`,
        x`@listen(@_window, "offline", ${reference})`
      );
      component.has_reactive_assignments = true;
    }
  }
};

// node_modules/svelte/src/compiler/utils/link.js
function link(next, prev) {
  prev.next = next;
  if (next)
    next.prev = prev;
}

// node_modules/svelte/src/compiler/compile/render_dom/wrappers/Fragment.js
var wrappers = {
  AwaitBlock: AwaitBlockWrapper,
  Body: BodyWrapper,
  Comment: CommentWrapper,
  DebugTag: DebugTagWrapper,
  Document: DocumentWrapper,
  EachBlock: EachBlockWrapper,
  Element: ElementWrapper,
  Head: HeadWrapper,
  IfBlock: IfBlockWrapper,
  InlineComponent: InlineComponentWrapper,
  KeyBlock: KeyBlockWrapper,
  MustacheTag: MustacheTagWrapper,
  Options: null,
  RawMustacheTag: RawMustacheTagWrapper,
  Slot: SlotWrapper,
  SlotTemplate: SlotTemplateWrapper,
  Text: TextWrapper,
  Title: TitleWrapper,
  Window: WindowWrapper
};
function trimmable_at(child, next_sibling) {
  return next_sibling.node.find_nearest(/EachBlock/) === child.find_nearest(/EachBlock/) || next_sibling.node.prev.type === "EachBlock";
}
var FragmentWrapper = class {
  /**
   * @param {import('../Renderer.js').default} renderer
   * @param {import('../Block.js').default} block
   * @param {import('../../nodes/interfaces.js').INode[]} nodes
   * @param {import('./shared/Wrapper.js').default} parent
   * @param {boolean} strip_whitespace
   * @param {import('./shared/Wrapper.js').default} next_sibling
   */
  constructor(renderer, block, nodes, parent, strip_whitespace, next_sibling) {
    /** @type {import('./shared/Wrapper.js').default[]} */
    __publicField(this, "nodes");
    this.nodes = [];
    let last_child;
    let window_wrapper;
    let i = nodes.length;
    while (i--) {
      const child = nodes[i];
      if (!child.type) {
        throw new Error("missing type");
      }
      if (!(child.type in wrappers)) {
        throw new Error(`TODO implement ${child.type}`);
      }
      if (child.type === "Window") {
        window_wrapper = new WindowWrapper(renderer, block, parent, child);
        continue;
      }
      if (child.type === "Text") {
        let { data: data2 } = child;
        if (this.nodes.length === 0) {
          const should_trim = next_sibling ? next_sibling.node.type === "Text" && regex_starts_with_whitespace.test(next_sibling.node.data) && trimmable_at(child, next_sibling) : !child.has_ancestor("EachBlock");
          if (should_trim && !child.keep_space()) {
            data2 = trim_end(data2);
            if (!data2)
              continue;
          }
        }
        if (last_child && last_child.node.type === "Text") {
          last_child.data = data2 + /** @type {import('./Text.js').default} */
          last_child.data;
          continue;
        }
        const wrapper = new TextWrapper(renderer, block, parent, child, data2);
        if (wrapper.skip)
          continue;
        this.nodes.unshift(wrapper);
        link(last_child, last_child = wrapper);
      } else {
        const Wrapper2 = wrappers[child.type];
        if (!Wrapper2 || child.type === "Comment" && !renderer.options.preserveComments)
          continue;
        const wrapper = new Wrapper2(
          renderer,
          block,
          parent,
          child,
          strip_whitespace,
          last_child || next_sibling
        );
        this.nodes.unshift(wrapper);
        link(last_child, last_child = wrapper);
      }
    }
    if (strip_whitespace) {
      const first = (
        /** @type {import('./Text.js').default} */
        this.nodes[0]
      );
      if (first && first.node.type === "Text" && !first.node.keep_space()) {
        first.data = trim_start(first.data);
        if (!first.data) {
          first.var = null;
          this.nodes.shift();
          if (this.nodes[0]) {
            this.nodes[0].prev = null;
          }
        }
      }
    }
    if (window_wrapper) {
      this.nodes.unshift(window_wrapper);
      link(last_child, window_wrapper);
    }
  }
  /**
   * @param {import('../Block.js').default} block
   * @param {import('estree').Identifier} parent_node
   * @param {import('estree').Identifier} parent_nodes
   */
  render(block, parent_node, parent_nodes) {
    for (let i = 0; i < this.nodes.length; i += 1) {
      this.nodes[i].render(block, parent_node, parent_nodes);
    }
  }
};

// node_modules/svelte/src/compiler/compile/render_dom/Renderer.js
var Renderer = class {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('../../interfaces.js').CompileOptions} options
   */
  constructor(component, options) {
    /**
     * @typedef {Object} ContextMember
     * @property {string} name
     * @property {import('estree').Literal} index
     * @property {boolean} is_contextual
     * @property {boolean} is_non_contextual
     * @property {import('../../interfaces.js').Var} variable
     * @property {number} priority
     */
    /**
     * @typedef {Array<{
     * 	n: number;
     * 	names: string[];
     * }>} BitMasks
     */
    /** @type {import('../Component.js').default} */
    __publicField(this, "component");
    // TODO Maybe Renderer shouldn't know about Component?
    /** @type {import('../../interfaces.js').CompileOptions} */
    __publicField(this, "options");
    /** @type {ContextMember[]} */
    __publicField(this, "context", []);
    /** @type {ContextMember[]} */
    __publicField(this, "initial_context", []);
    /** @type {Map<string, ContextMember>} */
    __publicField(this, "context_lookup", /* @__PURE__ */ new Map());
    /** @type {boolean} */
    __publicField(this, "context_overflow");
    /** @type {Array<import('./Block.js').default | import('estree').Node | import('estree').Node[]>} */
    __publicField(this, "blocks", []);
    /** @type {Set<string>} */
    __publicField(this, "readonly", /* @__PURE__ */ new Set());
    /** @type {Array<import('estree').Node | import('estree').Node[]>} */
    __publicField(this, "meta_bindings", []);
    // initial values for e.g. window.innerWidth, if there's a <svelte:window> meta tag
    /** @type {Map<string, BindingGroup>} */
    __publicField(this, "binding_groups", /* @__PURE__ */ new Map());
    /** @type {import('./Block.js').default} */
    __publicField(this, "block");
    /** @type {import('./wrappers/Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {import('estree').Identifier} */
    __publicField(this, "file_var");
    /**
     * Use this for stack traces. It is 1-based and acts on pre-processed sources.
     * Use `meta_locate` for metadata on DOM elements.
     * @type {(c: number) => { line: number; column: number }}
     */
    __publicField(this, "locate");
    /**
     * Use this for metadata on DOM elements. It is 1-based and acts on sources that have not been pre-processed.
     * Use `locate` for source mappings.
     * @type {(c: number) => { line: number; column: number }}
     */
    __publicField(this, "meta_locate");
    this.component = component;
    this.options = options;
    this.locate = component.locate;
    this.meta_locate = component.meta_locate;
    this.file_var = options.dev && this.component.get_unique_name("file");
    component.vars.filter((v) => !v.hoistable || v.export_name && !v.module).forEach((v) => this.add_to_context(v.name));
    component.vars.filter((v) => v.subscribable).forEach((v) => this.add_to_context(`$${v.name}`));
    reserved_keywords.forEach((keyword2) => {
      if (component.var_lookup.has(keyword2)) {
        this.add_to_context(keyword2);
      }
    });
    if (component.slots.size > 0) {
      this.add_to_context("$$scope");
      this.add_to_context("#slots");
    }
    this.block = new Block({
      renderer: this,
      name: null,
      type: "component",
      key: null,
      bindings: /* @__PURE__ */ new Map(),
      dependencies: /* @__PURE__ */ new Set()
    });
    this.block.has_update_method = true;
    this.fragment = new FragmentWrapper(
      this,
      this.block,
      component.fragment.children,
      null,
      true,
      null
    );
    this.blocks.forEach((block) => {
      if (block instanceof Block) {
        block.assign_variable_names();
      }
    });
    this.block.assign_variable_names();
    this.fragment.render(
      this.block,
      null,
      /** @type {import('estree').Identifier} */
      x`#nodes`
    );
    this.context_overflow = this.context.length > 31;
    this.context.forEach((member) => {
      const { variable } = member;
      if (variable) {
        member.priority += 2;
        if (variable.mutated || variable.reassigned)
          member.priority += 4;
        if (variable.is_reactive_dependency && (variable.mutated || variable.reassigned))
          member.priority += 16;
        if (variable.export_name)
          member.priority += 32;
        if (variable.referenced)
          member.priority += 64;
      } else if (member.is_non_contextual) {
        member.priority += 8;
      }
      if (!member.is_contextual) {
        member.priority += 1;
      }
    });
    this.context.sort(
      (a, b2) => b2.priority - a.priority || /** @type {number} */
      a.index.value - /** @type {number} */
      b2.index.value
    );
    this.context.forEach((member, i2) => member.index.value = i2);
    let i = this.context.length;
    while (i--) {
      const member = this.context[i];
      if (member.variable) {
        if (member.variable.referenced || member.variable.export_name || member.variable.is_reactive_dependency && (member.variable.mutated || member.variable.reassigned))
          break;
      } else if (member.is_non_contextual) {
        break;
      }
    }
    this.initial_context = this.context.slice(0, i + 1);
  }
  /**
   * @param {string} name
   * @param {any} contextual
   */
  add_to_context(name49, contextual = false) {
    if (!this.context_lookup.has(name49)) {
      const member2 = {
        name: name49,
        index: { type: "Literal", value: this.context.length },
        is_contextual: false,
        is_non_contextual: false,
        variable: null,
        priority: 0
      };
      this.context_lookup.set(name49, member2);
      this.context.push(member2);
    }
    const member = this.context_lookup.get(name49);
    if (contextual) {
      member.is_contextual = true;
    } else {
      member.is_non_contextual = true;
      member.variable = this.component.var_lookup.get(name49);
    }
    return member;
  }
  /**
   * @param {string} name
   * @param {unknown} [value]
   * @param {boolean} main_execution_context
   */
  invalidate(name49, value, main_execution_context = false) {
    return renderer_invalidate(this, name49, value, main_execution_context);
  }
  /**
   * @param {string[]} names
   * @param {any} is_reactive_declaration
   * @returns {import('estree').Expression}
   */
  dirty(names, is_reactive_declaration = false) {
    const renderer = this;
    const dirty = (
      /** @type {| import('estree').Identifier
          | import('estree').MemberExpression} */
      is_reactive_declaration ? x`$$self.$$.dirty` : x`#dirty`
    );
    const get_bitmask = () => {
      const bitmask = [];
      names.forEach((name49) => {
        const member = renderer.context_lookup.get(name49);
        if (!member)
          return;
        if (member.index.value === -1) {
          throw new Error("unset index");
        }
        const value = (
          /** @type {number} */
          member.index.value
        );
        const i = value / 31 | 0;
        const n2 = 1 << value % 31;
        if (!bitmask[i])
          bitmask[i] = { n: 0, names: [] };
        bitmask[i].n |= n2;
        bitmask[i].names.push(name49);
      });
      return bitmask;
    };
    return (
      /** @type {any} */
      {
        // Using a ParenthesizedExpression allows us to create
        // the expression lazily. TODO would be better if
        // context was determined before rendering, so that
        // this indirection was unnecessary
        type: "ParenthesizedExpression",
        get expression() {
          const bitmask = get_bitmask();
          if (!bitmask.length) {
            return (
              /** @type {import('estree').BinaryExpression} */
              x`${dirty} & /*${names.join(", ")}*/ 0`
            );
          }
          if (renderer.context_overflow) {
            return bitmask.map((b2, i) => ({ b: b2, i })).filter(({ b: b2 }) => b2).map(({ b: b2, i }) => x`${dirty}[${i}] & /*${b2.names.join(", ")}*/ ${b2.n}`).reduce((lhs, rhs) => x`${lhs} | ${rhs}`);
          }
          return (
            /** @type {import('estree').BinaryExpression} */
            x`${dirty} & /*${names.join(", ")}*/ ${bitmask[0].n}`
          );
        }
      }
    );
  }
  // NOTE: this method may be called before this.context_overflow / this.context is fully defined
  // therefore, they can only be evaluated later in a getter function
  /** @returns {import('estree').UnaryExpression | import('estree').ArrayExpression} */
  get_initial_dirty() {
    const _this = this;
    const val = (
      /** @type {import('estree').UnaryExpression} */
      x`-1`
    );
    return {
      get type() {
        return _this.context_overflow ? "ArrayExpression" : "UnaryExpression";
      },
      // as [-1]
      get elements() {
        const elements = [];
        for (let i = 0; i < _this.context.length; i += 31) {
          elements.push(val);
        }
        return elements;
      },
      // as -1
      operator: val.operator,
      prefix: val.prefix,
      argument: val.argument
    };
  }
  /**
   * @param {string | import('estree').Identifier | import('estree').MemberExpression} node
   * @param {string | void} ctx
   */
  reference(node, ctx = "#ctx") {
    if (typeof node === "string") {
      node = { type: "Identifier", name: node };
    }
    const { name: name49, nodes } = flatten_reference(node);
    const member = this.context_lookup.get(name49);
    if (this.component.var_lookup.get(name49)) {
      this.component.add_reference(node, name49);
    }
    if (member !== void 0) {
      const replacement = (
        /** @type {import('estree').MemberExpression} */
        x`/*${member.name}*/ ${ctx}[${member.index}]`
      );
      if (nodes[0].loc)
        replacement.object.loc = nodes[0].loc;
      nodes[0] = replacement;
      return nodes.reduce((lhs, rhs) => x`${lhs}.${rhs}`);
    }
    return node;
  }
  /** @param {import('./Block.js').default | import('estree').Node | import('estree').Node[]} block */
  remove_block(block) {
    this.blocks.splice(this.blocks.indexOf(block), 1);
  }
};

// node_modules/svelte/src/compiler/utils/mapped_code.js
var import_remapping = __toESM(require_remapping_umd(), 1);
function last_line_length(s) {
  return s.length - s.lastIndexOf("\n") - 1;
}
function sourcemap_add_offset(map, offset2, source_index) {
  if (map.mappings.length == 0)
    return;
  for (let line = 0; line < map.mappings.length; line++) {
    const segment_list = map.mappings[line];
    for (let segment = 0; segment < segment_list.length; segment++) {
      const seg = segment_list[segment];
      if (seg[1] === source_index) {
        if (seg[2] === 0) {
          seg[3] += offset2.column;
        }
        seg[2] += offset2.line;
      }
    }
  }
}
function merge_tables(this_table, other_table) {
  const new_table = this_table.slice();
  const idx_map = [];
  other_table = other_table || [];
  let val_changed = false;
  for (const [other_idx, other_val] of other_table.entries()) {
    const this_idx = this_table.indexOf(other_val);
    if (this_idx >= 0) {
      idx_map[other_idx] = this_idx;
    } else {
      const new_idx = new_table.length;
      new_table[new_idx] = other_val;
      idx_map[other_idx] = new_idx;
      val_changed = true;
    }
  }
  let idx_changed = val_changed;
  if (val_changed) {
    if (idx_map.find((val, idx) => val != idx) === void 0) {
      idx_changed = false;
    }
  }
  return [new_table, idx_map, val_changed, idx_changed];
}
var regex_line_token = /([^\d\w\s]|\s+)/g;
var MappedCode = class _MappedCode {
  constructor(string = "", map = null) {
    /**
     * @type {string}
     */
    __publicField(this, "string");
    /**
     * @type {import('@ampproject/remapping').DecodedSourceMap}
     */
    __publicField(this, "map");
    this.string = string;
    if (map) {
      this.map = map;
    } else {
      this.map = {
        version: 3,
        mappings: [],
        sources: [],
        names: []
      };
    }
  }
  /**
   * concat in-place (mutable), return this (chainable)
   * will also mutate the `other` object
   * @param {MappedCode} other
   * @returns {MappedCode}
   */
  concat(other) {
    if (other.string == "")
      return this;
    if (this.string == "") {
      this.string = other.string;
      this.map = other.map;
      return this;
    }
    const column_offset = last_line_length(this.string);
    this.string += other.string;
    const m1 = this.map;
    const m2 = other.map;
    if (m2.mappings.length == 0)
      return this;
    const [sources, new_source_idx, sources_changed, sources_idx_changed] = merge_tables(
      m1.sources,
      m2.sources
    );
    const [names, new_name_idx, names_changed, names_idx_changed] = merge_tables(
      m1.names,
      m2.names
    );
    if (sources_changed)
      m1.sources = sources;
    if (names_changed)
      m1.names = names;
    if (sources_idx_changed && names_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[1] >= 0)
            seg[1] = new_source_idx[seg[1]];
          if (seg[4] >= 0)
            seg[4] = new_name_idx[seg[4]];
        }
      }
    } else if (sources_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[1] >= 0)
            seg[1] = new_source_idx[seg[1]];
        }
      }
    } else if (names_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[4] >= 0)
            seg[4] = new_name_idx[seg[4]];
        }
      }
    }
    if (m2.mappings.length > 0 && column_offset > 0) {
      const first_line = m2.mappings[0];
      for (let i = 0; i < first_line.length; i++) {
        first_line[i][0] += column_offset;
      }
    }
    push_array2(m1.mappings[m1.mappings.length - 1], m2.mappings.shift());
    push_array2(m1.mappings, m2.mappings);
    return this;
  }
  /**
   * @static
   * @param {string} string
   * @param {import('@ampproject/remapping').DecodedSourceMap} [map]
   * @returns {MappedCode}
   */
  static from_processed(string, map) {
    const line_count = string.split("\n").length;
    if (map) {
      const missing_lines = line_count - map.mappings.length;
      for (let i = 0; i < missing_lines; i++) {
        map.mappings.push([]);
      }
      return new _MappedCode(string, map);
    }
    if (string == "")
      return new _MappedCode();
    map = { version: 3, names: [], sources: [], mappings: [] };
    for (let i = 0; i < line_count; i++)
      map.mappings.push([]);
    return new _MappedCode(string, map);
  }
  /**
   * @static
   * @param {import('../preprocess/private.js').Source} opts
   * @returns {MappedCode}
   */
  static from_source({ source, file_basename, get_location }) {
    let offset2 = get_location(0);
    if (!offset2)
      offset2 = { line: 0, column: 0 };
    const map = { version: 3, names: [], sources: [file_basename], mappings: [] };
    if (source == "")
      return new _MappedCode(source, map);
    const line_list = source.split("\n");
    for (let line = 0; line < line_list.length; line++) {
      map.mappings.push([]);
      const token_list = line_list[line].split(regex_line_token);
      for (let token = 0, column = 0; token < token_list.length; token++) {
        if (token_list[token] == "")
          continue;
        map.mappings[line].push([column, 0, offset2.line + line, column]);
        column += token_list[token].length;
      }
    }
    const segment_list = map.mappings[0];
    for (let segment = 0; segment < segment_list.length; segment++) {
      segment_list[segment][3] += offset2.column;
    }
    return new _MappedCode(source, map);
  }
};
function combine_sourcemaps(filename, sourcemap_list) {
  if (sourcemap_list.length == 0)
    return null;
  let map_idx = 1;
  const map = sourcemap_list.slice(0, -1).find((m) => m.sources.length !== 1) === void 0 ? (0, import_remapping.default)(
    // use array interface
    // only the oldest sourcemap can have multiple sources
    sourcemap_list,
    () => null,
    true
    // skip optional field `sourcesContent`
  ) : (0, import_remapping.default)(
    // use loader interface
    sourcemap_list[0],
    // last map
    (sourcefile) => {
      if (sourcefile === filename && sourcemap_list[map_idx]) {
        return sourcemap_list[map_idx++];
      } else {
        return null;
      }
    },
    true
  );
  if (!map.file)
    delete map.file;
  if (!map.sources.length)
    map.sources = [filename];
  return map;
}
function apply_preprocessor_sourcemap(filename, svelte_map, preprocessor_map_input) {
  if (!svelte_map || !preprocessor_map_input)
    return svelte_map;
  const preprocessor_map = typeof preprocessor_map_input === "string" ? JSON.parse(preprocessor_map_input) : preprocessor_map_input;
  const result_map = combine_sourcemaps(filename, [svelte_map, preprocessor_map]);
  Object.defineProperties(result_map, {
    toString: {
      enumerable: false,
      value: function toString3() {
        return JSON.stringify(this);
      }
    },
    toUrl: {
      enumerable: false,
      value: function toUrl() {
        let b64 = "";
        if (typeof window !== "undefined" && window.btoa) {
          b64 = window.btoa(unescape(encodeURIComponent(this.toString())));
        } else if (typeof Buffer !== "undefined") {
          b64 = Buffer.from(this.toString(), "utf8").toString("base64");
        } else {
          throw new Error(
            "Unsupported environment: `window.btoa` or `Buffer` should be present to use toUrl."
          );
        }
        return "data:application/json;charset=utf-8;base64," + b64;
      }
    }
  });
  return (
    /** @type {import('magic-string').SourceMap} */
    result_map
  );
}
var regex_data_uri = /data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(\S*)/;
function parse_attached_sourcemap(processed, tag_name) {
  const r_in = "[#@]\\s*sourceMappingURL\\s*=\\s*(\\S*)";
  const regex = tag_name == "script" ? new RegExp("(?://" + r_in + ")|(?:/\\*" + r_in + "\\s*\\*/)$") : new RegExp("/\\*" + r_in + "\\s*\\*/$");
  function log_warning(message) {
    const code_start = processed.code.length < 100 ? processed.code : processed.code.slice(0, 100) + " [...]";
    console.warn(`warning: ${message}. processed.code = ${JSON.stringify(code_start)}`);
  }
  processed.code = processed.code.replace(regex, (_, match1, match2) => {
    const map_url = tag_name == "script" ? match1 || match2 : match1;
    const map_data = (map_url.match(regex_data_uri) || [])[1];
    if (map_data) {
      if (processed.map) {
        log_warning(
          "Not implemented. Found sourcemap in both processed.code and processed.map. Please update your preprocessor to return only one sourcemap."
        );
        return "";
      }
      processed.map = atob(map_data);
      return "";
    }
    if (!processed.map) {
      log_warning(
        `Found sourcemap path ${JSON.stringify(
          map_url
        )} in processed.code, but no sourcemap data. Please update your preprocessor to return sourcemap data directly.`
      );
    }
    return "";
  });
}

// node_modules/svelte/src/compiler/compile/utils/check_enable_sourcemap.js
function check_enable_sourcemap(enable_sourcemap, namespace) {
  return typeof enable_sourcemap === "boolean" ? enable_sourcemap : enable_sourcemap[namespace];
}

// node_modules/svelte/src/compiler/compile/render_dom/index.js
function dom(component, options) {
  var _a, _b, _c;
  const { name: name49 } = component;
  const renderer = new Renderer(component, options);
  const { block } = renderer;
  block.has_outro_method = true;
  const body = [];
  if (renderer.file_var) {
    const file = component.file ? x`"${component.file}"` : x`undefined`;
    body.push(b`const ${renderer.file_var} = ${file};`);
  }
  const css = component.stylesheet.render(options.filename);
  const css_sourcemap_enabled = check_enable_sourcemap(options.enableSourcemap, "css");
  if (css_sourcemap_enabled) {
    css.map = apply_preprocessor_sourcemap(
      options.filename,
      css.map,
      /** @type {string | import('@ampproject/remapping').RawSourceMap | import('@ampproject/remapping').DecodedSourceMap} */
      options.sourcemap
    );
  } else {
    css.map = null;
  }
  const styles = css_sourcemap_enabled && component.stylesheet.has_styles && options.dev ? `${css.code}
/*# sourceMappingURL=${css.map.toUrl()} */` : css.code;
  const add_css = component.get_unique_name("add_css");
  const should_add_css = !!styles && (options.customElement || options.css === "injected");
  if (should_add_css) {
    body.push(b`
			function ${add_css}(target) {
				@append_styles(target, "${component.stylesheet.id}", "${styles}");
			}
		`);
  }
  const blocks = renderer.blocks.slice().reverse();
  push_array2(
    body,
    blocks.map((block2) => {
      if (
        /** @type {import('./Block.js').default} */
        block2.render
      )
        return (
          /** @type {import('./Block.js').default} */
          block2.render()
        );
      return block2;
    })
  );
  if (options.dev && !options.hydratable) {
    block.chunks.claim.push(
      b`throw new @_Error("options.hydrate only works if the component was compiled with the \`hydratable: true\` option");`
    );
  }
  const uses_slots = component.var_lookup.has("$$slots");
  let compute_slots;
  if (uses_slots) {
    compute_slots = b`
			const $$slots = @compute_slots(#slots);
		`;
  }
  const uses_props = component.var_lookup.has("$$props");
  const uses_rest = component.var_lookup.has("$$restProps");
  const $$props = uses_props || uses_rest ? "$$new_props" : "$$props";
  const props = component.vars.filter((variable) => !variable.module && variable.export_name);
  const writable_props = props.filter((variable) => variable.writable);
  const omit_props_names = component.get_unique_name("omit_props_names");
  const compute_rest = x`@compute_rest_props($$props, ${omit_props_names.name})`;
  const rest = uses_rest ? b`
		const ${omit_props_names.name} = [${props.map((prop) => `"${prop.export_name}"`).join(",")}];
		let $$restProps = ${compute_rest};
	` : null;
  const set = uses_props || uses_rest || writable_props.length > 0 || component.slots.size > 0 ? x`
			${$$props} => {
				${uses_props && renderer.invalidate(
    "$$props",
    x`$$props = @assign(@assign({}, $$props), @exclude_internal_props($$new_props))`
  )}
				${uses_rest && !uses_props && x`$$props = @assign(@assign({}, $$props), @exclude_internal_props($$new_props))`}
				${uses_rest && renderer.invalidate("$$restProps", x`$$restProps = ${compute_rest}`)}
				${writable_props.map(
    (prop) => b`if ('${prop.export_name}' in ${$$props}) ${renderer.invalidate(
      prop.name,
      x`${prop.name} = ${$$props}.${prop.export_name}`
    )};`
  )}
				${component.slots.size > 0 && b`if ('$$scope' in ${$$props}) ${renderer.invalidate(
    "$$scope",
    x`$$scope = ${$$props}.$$scope`
  )};`}
			}
		` : null;
  const accessors = [];
  const not_equal = component.component_options.immutable ? x`@not_equal` : x`@safe_not_equal`;
  let missing_props_check;
  let inject_state;
  let capture_state;
  let props_inject;
  props.forEach((prop) => {
    const variable = component.var_lookup.get(prop.name);
    if (!variable.writable || component.component_options.accessors) {
      accessors.push({
        type: "MethodDefinition",
        kind: "get",
        key: { type: "Identifier", name: prop.export_name },
        value: x`function() {
					return ${prop.hoistable ? prop.name : x`this.$$.ctx[${renderer.context_lookup.get(prop.name).index}]`}
				}`
      });
    } else if (component.compile_options.dev) {
      accessors.push({
        type: "MethodDefinition",
        kind: "get",
        key: { type: "Identifier", name: prop.export_name },
        value: x`function() {
					throw new @_Error("<${component.tag}>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
				}`
      });
    }
    if (component.component_options.accessors) {
      if (variable.writable && !renderer.readonly.has(prop.name)) {
        accessors.push({
          type: "MethodDefinition",
          kind: "set",
          key: { type: "Identifier", name: prop.export_name },
          value: x`function(${prop.name}) {
						this.$$set({ ${prop.export_name}: ${prop.name} });
						@flush();
					}`
        });
      } else if (component.compile_options.dev) {
        accessors.push({
          type: "MethodDefinition",
          kind: "set",
          key: { type: "Identifier", name: prop.export_name },
          value: x`function(value) {
						throw new @_Error("<${component.tag}>: Cannot set read-only property '${prop.export_name}'");
					}`
        });
      }
    } else if (component.compile_options.dev) {
      accessors.push({
        type: "MethodDefinition",
        kind: "set",
        key: { type: "Identifier", name: prop.export_name },
        value: x`function(value) {
					throw new @_Error("<${component.tag}>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
				}`
      });
    }
  });
  component.instance_exports_from.forEach((exports_from) => {
    const import_declaration = {
      ...exports_from,
      type: "ImportDeclaration",
      specifiers: [],
      source: exports_from.source
    };
    component.imports.push(
      /** @type {import('estree').ImportDeclaration} */
      import_declaration
    );
    exports_from.specifiers.forEach((specifier) => {
      if (component.component_options.accessors) {
        const name50 = component.get_unique_name(specifier.exported.name);
        import_declaration.specifiers.push({
          ...specifier,
          type: "ImportSpecifier",
          imported: specifier.local,
          local: name50
        });
        accessors.push({
          type: "MethodDefinition",
          kind: "get",
          key: { type: "Identifier", name: specifier.exported.name },
          value: x`function() {
						return ${name50}
					}`
        });
      } else if (component.compile_options.dev) {
        accessors.push({
          type: "MethodDefinition",
          kind: "get",
          key: { type: "Identifier", name: specifier.exported.name },
          value: x`function() {
						throw new @_Error("<${component.tag}>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
					}`
        });
      }
    });
  });
  if (component.compile_options.dev) {
    const expected = props.filter((prop) => prop.writable && !prop.initialised);
    if (expected.length) {
      missing_props_check = b`
				$$self.$$.on_mount.push(function () {
					${expected.map(
        (prop) => b`
					if (${prop.name} === undefined && !(('${prop.export_name}' in $$props) || $$self.$$.bound[$$self.$$.props['${prop.export_name}']])) {
						@_console.warn("<${component.tag}> was created without expected prop '${prop.export_name}'");
					}`
      )}
				});
			`;
    }
    const capturable_vars = component.vars.filter(
      (v) => !v.internal && !v.global && !v.name.startsWith("$$")
    );
    if (capturable_vars.length > 0) {
      capture_state = x`() => ({ ${capturable_vars.map((prop) => p`${prop.name}`)} })`;
    }
    const injectable_vars = capturable_vars.filter(
      (v) => !v.module && v.writable && v.name[0] !== "$"
    );
    if (uses_props || injectable_vars.length > 0) {
      inject_state = x`
				${$$props} => {
					${uses_props && renderer.invalidate("$$props", x`$$props = @assign(@assign({}, $$props), $$new_props)`)}
					${injectable_vars.map(
        (v) => b`if ('${v.name}' in $$props) ${renderer.invalidate(
          v.name,
          x`${v.name} = ${$$props}.${v.name}`
        )};`
      )}
				}
			`;
      props_inject = b`
				if ($$props && "$$inject" in $$props) {
					$$self.$inject_state($$props.$$inject);
				}
			`;
    }
  }
  if (component.ast.instance) {
    let scope = component.instance_scope;
    const map = component.instance_scope_map;
    let execution_context = null;
    walk(component.ast.instance.content, {
      enter(node) {
        if (map.has(node)) {
          scope = /** @type {import('periscopic').Scope} */
          map.get(node);
          if (!execution_context && !scope.block) {
            execution_context = node;
          }
        } else if (!execution_context && node.type === "LabeledStatement" && node.label.name === "$") {
          execution_context = node;
        }
      },
      leave(node) {
        if (map.has(node)) {
          scope = scope.parent;
        }
        if (execution_context === node) {
          execution_context = null;
        }
        if (node.type === "AssignmentExpression" || node.type === "UpdateExpression") {
          const assignee = node.type === "AssignmentExpression" ? node.left : node.argument;
          const names = new Set(extract_names(
            /** @type {import('estree').Node} */
            assignee
          ));
          this.replace(invalidate(renderer, scope, node, names, execution_context === null));
        }
      }
    });
    component.rewrite_props(({ name: name50, reassigned, export_name }) => {
      const value = `$${name50}`;
      const i = renderer.context_lookup.get(`$${name50}`).index;
      const insert = reassigned || export_name ? b`${`$$subscribe_${name50}`}()` : b`@component_subscribe($$self, ${name50}, #value => $$invalidate(${i}, ${value} = #value))`;
      if (component.compile_options.dev) {
        return b`@validate_store(${name50}, '${name50}'); ${insert}`;
      }
      return insert;
    });
  }
  const args = [x`$$self`];
  const has_invalidate = props.length > 0 || component.has_reactive_assignments || component.slots.size > 0 || capture_state || inject_state;
  if (has_invalidate) {
    args.push(x`$$props`, x`$$invalidate`);
  } else if (component.compile_options.dev) {
    args.push(x`$$props`);
  }
  const has_create_fragment = component.compile_options.dev || block.has_content();
  if (has_create_fragment) {
    body.push(b`
			function create_fragment(#ctx) {
				${block.get_contents()}
			}
		`);
  }
  body.push(b`
		${component.extract_javascript(component.ast.module)}

		${component.fully_hoisted}
	`);
  const filtered_props = props.filter((prop) => {
    const variable = component.var_lookup.get(prop.name);
    if (variable.hoistable)
      return false;
    return prop.name[0] !== "$";
  });
  const reactive_stores = component.vars.filter(
    (variable) => variable.name[0] === "$" && variable.name[1] !== "$"
  );
  const instance_javascript = component.extract_javascript(component.ast.instance);
  const has_definition = component.compile_options.dev || instance_javascript && instance_javascript.length > 0 || filtered_props.length > 0 || uses_props || component.partly_hoisted.length > 0 || renderer.initial_context.length > 0 || component.reactive_declarations.length > 0 || capture_state || inject_state;
  const definition = has_definition ? component.alias("instance") : { type: "Literal", value: null };
  const reactive_store_subscriptions = reactive_stores.filter((store) => {
    const variable = component.var_lookup.get(store.name.slice(1));
    return !variable || variable.hoistable;
  }).map(
    ({ name: name50 }) => b`
			${component.compile_options.dev && b`@validate_store(${name50.slice(1)}, '${name50.slice(1)}');`}
			@component_subscribe($$self, ${name50.slice(1)}, $$value => $$invalidate(${renderer.context_lookup.get(name50).index}, ${name50} = $$value));
		`
  );
  const resubscribable_reactive_store_unsubscribers = reactive_stores.filter((store) => {
    const variable = component.var_lookup.get(store.name.slice(1));
    return variable && (variable.reassigned || variable.export_name);
  }).map(({ name: name50 }) => b`$$self.$$.on_destroy.push(() => ${`$$unsubscribe_${name50.slice(1)}`}());`);
  if (has_definition) {
    const reactive_declarations = [];
    const fixed_reactive_declarations = [];
    component.reactive_declarations.forEach((d) => {
      const dependencies = Array.from(d.dependencies);
      const uses_rest_or_props = !!dependencies.find((n2) => n2 === "$$props" || n2 === "$$restProps");
      const writable = dependencies.filter((n2) => {
        const variable = component.var_lookup.get(n2);
        return variable && (variable.export_name || variable.mutated || variable.reassigned);
      });
      const condition = !uses_rest_or_props && writable.length > 0 && renderer.dirty(writable, true);
      let statement = d.node;
      if (condition)
        statement = /** @type {import('estree').Statement} */
        b`if (${condition}) { ${statement} }`[0];
      if (condition || uses_rest_or_props) {
        reactive_declarations.push(statement);
      } else {
        fixed_reactive_declarations.push(statement);
      }
    });
    const injected = Array.from(component.injected_reactive_declaration_vars).filter((name50) => {
      const variable = component.var_lookup.get(name50);
      return variable.injected && variable.name[0] !== "$";
    });
    const reactive_store_declarations = reactive_stores.map((variable) => {
      const $name = variable.name;
      const name50 = $name.slice(1);
      const store = component.var_lookup.get(name50);
      if (store && (store.reassigned || store.export_name)) {
        const unsubscribe = `$$unsubscribe_${name50}`;
        const subscribe = `$$subscribe_${name50}`;
        const i = renderer.context_lookup.get($name).index;
        return b`let ${$name}, ${unsubscribe} = @noop, ${subscribe} = () => (${unsubscribe}(), ${unsubscribe} = @subscribe(${name50}, $$value => $$invalidate(${i}, ${$name} = $$value)), ${name50})`;
      }
      return b`let ${$name};`;
    });
    let unknown_props_check;
    if (component.compile_options.dev && !(uses_props || uses_rest)) {
      unknown_props_check = b`
				const writable_props = [${writable_props.map((prop) => x`'${prop.export_name}'`)}];
				@_Object.keys($$props).forEach(key => {
					if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') @_console.warn(\`<${component.tag}> was created with unknown prop '\${key}'\`);
				});
			`;
    }
    const return_value = {
      type: "ArrayExpression",
      elements: renderer.initial_context.map(
        (member) => (
          /** @type {import('estree').Expression} */
          {
            type: "Identifier",
            name: member.name
          }
        )
      )
    };
    body.push(b`
			function ${definition}(${args}) {
				${injected.map((name50) => b`let ${name50};`)}

				${rest}

				${reactive_store_declarations}

				${reactive_store_subscriptions}

				${resubscribable_reactive_store_unsubscribers}

				${component.slots.size || component.compile_options.dev || uses_slots ? b`let { $$slots: #slots = {}, $$scope } = $$props;` : null}
				${component.compile_options.dev && b`@validate_slots('${component.tag}', #slots, [${[...component.slots.keys()].map((key) => `'${key}'`).join(",")}]);`}
				${compute_slots}

				${instance_javascript}

				${missing_props_check}
				${unknown_props_check}

				${renderer.binding_groups.size > 0 && b`const $$binding_groups = [${[...renderer.binding_groups.keys()].map((_) => x`[]`)}];`}

				${component.partly_hoisted}

				${set && b`$$self.$$set = ${set};`}

				${capture_state && b`$$self.$capture_state = ${capture_state};`}

				${inject_state && b`$$self.$inject_state = ${inject_state};`}

				${/* before reactive declarations */
    props_inject}

				${reactive_declarations.length > 0 && b`
				$$self.$$.update = () => {
					${reactive_declarations}
				};
				`}

				${fixed_reactive_declarations}

				${uses_props && b`$$props = @exclude_internal_props($$props);`}

				return ${return_value};
			}
		`);
  }
  const prop_indexes = (
    /** @type {import('estree').ObjectExpression} */
    x`{
		${props.filter((v) => v.export_name && !v.module).map((v) => p`${v.export_name}: ${renderer.context_lookup.get(v.name).index}`)}
	}`
  );
  let dirty;
  if (renderer.context_overflow) {
    dirty = x`[]`;
    for (let i = 0; i < renderer.context.length; i += 31) {
      dirty.elements.push(x`-1`);
    }
  }
  const superclass = {
    type: "Identifier",
    name: options.dev ? "@SvelteComponentDev" : "@SvelteComponent"
  };
  const optional_parameters = [];
  if (should_add_css) {
    optional_parameters.push(add_css);
  } else if (dirty) {
    optional_parameters.push(x`null`);
  }
  if (dirty) {
    optional_parameters.push(dirty);
  }
  const declaration = (
    /** @type {import('estree').ClassDeclaration} */
    b`
		class ${name49} extends ${superclass} {
			constructor(options) {
				super(${options.dev && "options"});
				@init(this, options, ${definition}, ${has_create_fragment ? "create_fragment" : "null"}, ${not_equal}, ${prop_indexes}, ${optional_parameters});
				${options.dev && b`@dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "${name49.name}", options, id: create_fragment.name });`}
			}
		}
	`[0]
  );
  push_array2(declaration.body.body, accessors);
  body.push(
    /** @type {any} */
    declaration
  );
  if (options.customElement) {
    const props_str = writable_props.reduce((def, prop) => {
      var _a2, _b2;
      def[prop.export_name] = ((_b2 = (_a2 = component.component_options.customElement) == null ? void 0 : _a2.props) == null ? void 0 : _b2[prop.export_name]) || {};
      if (prop.is_boolean && !def[prop.export_name].type) {
        def[prop.export_name].type = "Boolean";
      }
      return def;
    }, {});
    const slots_str = [...component.slots.keys()].map((key) => `"${key}"`).join(",");
    const accessors_str = accessors.filter(
      (accessor) => accessor.kind === "get" && !writable_props.some((prop) => prop.export_name === accessor.key.name)
    ).map((accessor) => `"${accessor.key.name}"`).join(",");
    const use_shadow_dom = ((_a = component.component_options.customElement) == null ? void 0 : _a.shadow) !== "none" ? "true" : "false";
    const create_ce = x`@create_custom_element(${name49}, ${JSON.stringify(
      props_str
    )}, [${slots_str}], [${accessors_str}], ${use_shadow_dom}, ${(_b = component.component_options.customElement) == null ? void 0 : _b.extend})`;
    if ((_c = component.component_options.customElement) == null ? void 0 : _c.tag) {
      body.push(
        b`@_customElements.define("${component.component_options.customElement.tag}", ${create_ce});`
      );
    } else {
      body.push(b`${create_ce}`);
    }
  }
  if (options.discloseVersion === true) {
    component.imports.unshift({
      type: "ImportDeclaration",
      specifiers: [],
      source: {
        type: "Literal",
        value: `${options.sveltePath ?? "svelte"}/internal/disclose-version`
      }
    });
  }
  return { js: flatten(body), css };
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/shared/get_const_tags.js
function get_const_tags2(const_tags) {
  if (const_tags.length === 0)
    return null;
  return {
    type: "VariableDeclaration",
    kind: "let",
    declarations: const_tags.map((const_tag) => {
      const assignment = const_tag.node.expression;
      return {
        type: "VariableDeclarator",
        id: assignment.left,
        init: assignment.right
      };
    })
  };
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/AwaitBlock.js
function AwaitBlock_default(node, renderer, options) {
  renderer.push();
  renderer.render(node.pending.children, options);
  const pending = renderer.pop();
  renderer.push();
  renderer.render(node.then.children, options);
  const then = renderer.pop();
  renderer.add_expression(x`
		function(__value) {
			if (@is_promise(__value)) {
				__value.then(null, @noop);
				return ${pending};
			}
			return (function(${node.then_node ? node.then_node : ""}) { ${get_const_tags2(
    node.then.const_tags
  )}; return ${then}; }(__value));
		}(${node.expression.node})
	`);
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/Comment.js
function Comment_default(node, renderer, options) {
  if (options.preserveComments) {
    renderer.add_string(`<!--${node.data}-->`);
  }
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/DebugTag.js
function DebugTag_default(node, renderer, options) {
  if (!options.dev)
    return;
  const filename = options.filename || null;
  const { line, column } = options.locate(node.start + 1);
  const obj = x`{
		${node.expressions.map((e) => p`${/** @type {import('estree').Identifier} */
  e.node.name}`)}
	}`;
  renderer.add_expression(
    x`@debug(${filename ? x`"${filename}"` : x`null`}, ${line - 1}, ${column}, ${obj})`
  );
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/EachBlock.js
function EachBlock_default(node, renderer, options) {
  const args = [node.context_node];
  if (node.index)
    args.push({ type: "Identifier", name: node.index });
  renderer.push();
  renderer.render(node.children, options);
  const result = renderer.pop();
  const consequent = x`@each(${node.expression.node}, (${args}) => { ${get_const_tags2(
    node.const_tags
  )}; return ${result} })`;
  if (node.else) {
    renderer.push();
    renderer.render(node.else.children, options);
    let alternate = renderer.pop();
    if (node.else.const_tags.length > 0)
      alternate = x`(() => { ${get_const_tags2(node.else.const_tags)}; return ${alternate} })()`;
    renderer.add_expression(x`${node.expression.node}.length ? ${consequent} : ${alternate}`);
  } else {
    renderer.add_expression(consequent);
  }
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/shared/get_attribute_value.js
function get_class_attribute_value(attribute) {
  if (attribute.chunks.length === 2 && /** @type {import('../../../nodes/Text.js').default} */
  attribute.chunks[1].synthetic) {
    const value = (
      /** @type {import('../../../nodes/shared/Expression.js').default} */
      attribute.chunks[0].node
    );
    return x`@escape(@null_to_empty(${value}), true) + "${/** @type {import('../../../nodes/Text.js').default} */
    attribute.chunks[1].data}"`;
  }
  return get_attribute_value(attribute);
}
function get_attribute_value(attribute) {
  if (attribute.chunks.length === 0)
    return x`""`;
  const is_textarea_value = attribute.parent.name.toLowerCase() === "textarea" && attribute.name.toLowerCase() === "value";
  return attribute.chunks.map((chunk) => {
    return chunk.type === "Text" ? (
      /** @type {import('estree').Expression} */
      string_literal(chunk.data.replace(regex_double_quotes, "&quot;"))
    ) : x`@escape(${chunk.node}, ${is_textarea_value ? "false" : "true"})`;
  }).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
}
function get_attribute_expression(attribute) {
  if (attribute.chunks.length === 1 && attribute.chunks[0].type === "Expression") {
    return (
      /** @type {import('estree').Expression} */
      /** @type {import('../../../nodes/shared/Expression.js').default} */
      attribute.chunks[0].node
    );
  }
  return get_attribute_value(attribute);
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/utils/remove_whitespace_children.js
function remove_whitespace_children(children, next) {
  const nodes = [];
  let last_child;
  let i = children.length;
  while (i--) {
    const child = children[i];
    if (child.type === "Text") {
      if (child.should_skip()) {
        continue;
      }
      let { data: data2 } = child;
      if (nodes.length === 0) {
        const should_trim = next ? next.type === "Text" && regex_starts_with_whitespace.test(next.data) && trimmable_at2(child, next) : !child.has_ancestor("EachBlock");
        if (should_trim && !child.keep_space()) {
          data2 = trim_end(data2);
          if (!data2)
            continue;
        }
      }
      if (last_child && last_child.type === "Text") {
        last_child.data = data2 + last_child.data;
        continue;
      }
      child.data = data2;
      nodes.unshift(child);
      link(last_child, last_child = child);
    } else {
      nodes.unshift(child);
      link(last_child, last_child = child);
    }
  }
  const first = nodes[0];
  if (first && first.type === "Text" && !first.keep_space()) {
    first.data = trim_start(first.data);
    if (!first.data) {
      first.var = null;
      nodes.shift();
      if (nodes[0]) {
        nodes[0].prev = null;
      }
    }
  }
  return nodes;
}
function trimmable_at2(child, next_sibling) {
  return next_sibling.find_nearest(/EachBlock/) === child.find_nearest(/EachBlock/) || next_sibling.prev.type === "EachBlock";
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/Element.js
function Element_default(node, renderer, options) {
  const children = remove_whitespace_children(node.children, node.next);
  let node_contents;
  const contenteditable = is_contenteditable(node);
  if (node.is_dynamic_element) {
    renderer.push();
  }
  renderer.add_string("<");
  add_tag_name();
  const class_expression_list = node.classes.map((class_directive) => {
    const { expression, name: name49 } = class_directive;
    const snippet = expression ? expression.node : x`#ctx.${name49}`;
    return x`${snippet} ? "${name49}" : ""`;
  });
  if (node.needs_manual_style_scoping) {
    class_expression_list.push(x`"${node.component.stylesheet.id}"`);
  }
  const class_expression = class_expression_list.length > 0 && class_expression_list.reduce((lhs, rhs) => x`${lhs} + ' ' + ${rhs}`);
  const style_expression_list = node.styles.map((style_directive) => {
    let {
      name: name49,
      important,
      expression: { node: expression }
    } = style_directive;
    if (important) {
      expression = x`${expression} + ' !important'`;
    }
    return p`"${name49}": ${expression}`;
  });
  const style_expression = style_expression_list.length > 0 && x`{ ${style_expression_list} }`;
  if (node.attributes.some((attr) => attr.is_spread)) {
    const args = [];
    node.attributes.forEach((attribute) => {
      if (attribute.is_spread) {
        args.push(x`@escape_object(${attribute.expression.node})`);
      } else {
        const attr_name = node.namespace === namespaces.foreign ? attribute.name : fix_attribute_casing(attribute.name);
        const name49 = attribute.name.toLowerCase();
        if (name49 === "value" && node.name.toLowerCase() === "textarea") {
          node_contents = get_attribute_value(attribute);
        } else if (attribute.is_true) {
          args.push(x`{ ${attr_name}: true }`);
        } else if (boolean_attributes.has(name49) && attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
          args.push(
            x`{ ${attr_name}: ${/** @type {import('../../nodes/shared/Expression.js').default} */
            attribute.chunks[0].node} || null }`
          );
        } else if (attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
          const snippet = (
            /** @type {import('../../nodes/shared/Expression.js').default} */
            attribute.chunks[0].node
          );
          args.push(x`{ ${attr_name}: @escape_attribute_value(${snippet}) }`);
        } else {
          args.push(x`{ ${attr_name}: ${get_attribute_value(attribute)} }`);
        }
      }
    });
    renderer.add_expression(
      x`@spread([${args}], { classes: ${class_expression}, styles: ${style_expression} })`
    );
  } else {
    let add_class_attribute = !!class_expression;
    let add_style_attribute = !!style_expression;
    node.attributes.forEach((attribute) => {
      const name49 = attribute.name.toLowerCase();
      const attr_name = node.namespace === namespaces.foreign ? attribute.name : fix_attribute_casing(attribute.name);
      if (name49 === "value" && node.name.toLowerCase() === "textarea") {
        node_contents = get_attribute_value(attribute);
      } else if (attribute.is_true) {
        renderer.add_string(` ${attr_name}`);
      } else if (boolean_attributes.has(name49) && attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
        renderer.add_string(" ");
        renderer.add_expression(
          x`${/** @type {import('../../nodes/shared/Expression.js').default} */
          attribute.chunks[0].node} ? "${attr_name}" : ""`
        );
      } else if (name49 === "class" && class_expression) {
        add_class_attribute = false;
        renderer.add_string(` ${attr_name}="`);
        renderer.add_expression(
          x`[${get_class_attribute_value(attribute)}, ${class_expression}].join(' ').trim()`
        );
        renderer.add_string('"');
      } else if (name49 === "style" && style_expression) {
        add_style_attribute = false;
        renderer.add_expression(
          x`@add_styles(@merge_ssr_styles(${get_attribute_value(attribute)}, ${style_expression}))`
        );
      } else if (attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
        const snippet = (
          /** @type {import('../../nodes/shared/Expression.js').default} */
          attribute.chunks[0].node
        );
        renderer.add_expression(
          x`@add_attribute("${attr_name}", ${snippet}, ${boolean_attributes.has(name49) ? 1 : 0})`
        );
      } else {
        renderer.add_string(` ${attr_name}="`);
        renderer.add_expression(
          (name49 === "class" ? get_class_attribute_value : get_attribute_value)(attribute)
        );
        renderer.add_string('"');
      }
    });
    if (add_class_attribute) {
      renderer.add_expression(x`@add_classes((${class_expression}).trim())`);
    }
    if (add_style_attribute) {
      renderer.add_expression(x`@add_styles(${style_expression})`);
    }
  }
  node.bindings.forEach((binding) => {
    const { name: name49, expression } = binding;
    if (binding.is_readonly) {
      return;
    }
    if (name49 === "group") {
      const value_attribute = node.attributes.find(({ name: name50 }) => name50 === "value");
      if (value_attribute) {
        const value = get_attribute_expression(value_attribute);
        const type = node.get_static_attribute_value("type");
        const bound = expression.node;
        const condition = type === "checkbox" ? x`~${bound}.indexOf(${value})` : x`${value} === ${bound}`;
        renderer.add_expression(x`${condition} ? @add_attribute("checked", true, 1) : ""`);
      }
    } else if (contenteditable && is_name_contenteditable(name49)) {
      node_contents = expression.node;
    } else if (binding.name === "value" && node.name === "textarea") {
      const snippet = expression.node;
      node_contents = x`@escape(${snippet} || "")`;
    } else if (binding.name === "value" && node.name === "select") {
    } else {
      const snippet = expression.node;
      renderer.add_expression(
        x`@add_attribute("${name49}", ${snippet}, ${boolean_attributes.has(name49) ? 1 : 0})`
      );
    }
  });
  if (options.hydratable) {
    if (node.can_optimise_hydration && !options.has_added_svelte_hash) {
      renderer.add_string(` data-svelte-h="${node.hash()}"`);
      options = { ...options, has_added_svelte_hash: true };
    }
  }
  renderer.add_string(">");
  if (node_contents !== void 0) {
    if (contenteditable) {
      renderer.push();
      renderer.render(children, options);
      const result = renderer.pop();
      renderer.add_expression(
        x`($$value => $$value === void 0 ? ${result} : $$value)(${node_contents})`
      );
    } else {
      if (node.name === "textarea") {
        const value_attribute = node.attributes.find(({ name: name49 }) => name49 === "value");
        if (value_attribute) {
          const first = value_attribute.chunks[0];
          if (first && first.type === "Text" && regex_starts_with_newline.test(first.data)) {
            renderer.add_string("\n");
          }
        }
      }
      renderer.add_expression(node_contents);
    }
    add_close_tag();
  } else {
    if (node.name === "pre") {
      const first = children[0];
      if (first && first.type === "Text" && regex_starts_with_newline.test(first.data)) {
        renderer.add_string("\n");
      }
    }
    if (node.is_dynamic_element)
      renderer.push();
    renderer.render(children, options);
    if (node.is_dynamic_element) {
      const children2 = renderer.pop();
      renderer.add_expression(x`@is_void(#tag) ? '' : ${children2}`);
    }
    add_close_tag();
  }
  if (node.is_dynamic_element) {
    let content = renderer.pop();
    if (options.dev && node.children.length > 0)
      content = x`(() => { @validate_void_dynamic_element(#tag); return ${content}; })()`;
    renderer.add_expression(x`((#tag) => {
			${options.dev && x`@validate_dynamic_element(#tag)`}
			return #tag ? ${content} : '';
		})(${node.tag_expr.node})`);
  }
  function add_close_tag() {
    if (node.tag_expr.node.type === "Literal") {
      if (!is_void(
        /** @type {string} */
        node.tag_expr.node.value
      )) {
        renderer.add_string("</");
        add_tag_name();
        renderer.add_string(">");
      }
      return;
    }
    renderer.add_expression(x`@is_void(#tag) ? '' : \`</\${#tag}>\``);
  }
  function add_tag_name() {
    if (node.tag_expr.node.type === "Literal") {
      renderer.add_string(
        /** @type {string} */
        node.tag_expr.node.value
      );
    } else {
      renderer.add_expression(
        /** @type {import('estree').Expression} */
        node.tag_expr.node
      );
    }
  }
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/Head.js
function Head_default(node, renderer, options) {
  const head_options = {
    ...options,
    head_id: node.id
  };
  renderer.push();
  renderer.render(node.children, head_options);
  const result = renderer.pop();
  let expression = result;
  if (options.hydratable) {
    const start_comment = `HEAD_${node.id}_START`;
    const end_comment = `HEAD_${node.id}_END`;
    expression = x`'<!-- ${start_comment} -->' + ${expression} + '<!-- ${end_comment} -->'`;
  }
  renderer.add_expression(x`$$result.head += ${expression}, ""`);
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/HtmlTag.js
function HtmlTag_default(node, renderer, options) {
  if (options.hydratable)
    renderer.add_string("<!-- HTML_TAG_START -->");
  renderer.add_expression(
    /** @type {import('estree').Expression} */
    node.expression.node
  );
  if (options.hydratable)
    renderer.add_string("<!-- HTML_TAG_END -->");
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/IfBlock.js
function IfBlock_default(node, renderer, options) {
  const condition = node.expression.node;
  renderer.push();
  renderer.render(node.children, options);
  let consequent = renderer.pop();
  if (node.const_tags.length > 0)
    consequent = x`(() => { ${get_const_tags2(node.const_tags)}; return ${consequent} })()`;
  renderer.push();
  if (node.else)
    renderer.render(node.else.children, options);
  let alternate = renderer.pop();
  if (node.else && node.else.const_tags.length > 0)
    alternate = x`(() => { ${get_const_tags2(node.else.const_tags)}; return ${alternate} })()`;
  renderer.add_expression(x`${condition} ? ${consequent} : ${alternate}`);
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/InlineComponent.js
function get_prop_value(attribute) {
  if (attribute.is_true)
    return x`true`;
  if (attribute.chunks.length === 0)
    return x`''`;
  return attribute.chunks.map((chunk) => {
    if (chunk.type === "Text")
      return string_literal(chunk.data);
    return chunk.node;
  }).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
}
function InlineComponent_default(node, renderer, options) {
  const binding_props = [];
  const binding_fns = [];
  node.bindings.forEach((binding) => {
    renderer.has_bindings = true;
    const snippet = binding.expression.node;
    binding_props.push(p`${binding.name}: ${snippet}`);
    binding_fns.push(p`${binding.name}: $$value => { ${snippet} = $$value; $$settled = false }`);
  });
  const uses_spread = node.attributes.find((attr) => attr.is_spread);
  let props;
  if (uses_spread) {
    props = x`@_Object.assign({}, ${node.attributes.map((attribute) => {
      if (attribute.is_spread) {
        return attribute.expression.node;
      } else {
        return x`{ ${attribute.name}: ${get_prop_value(attribute)} }`;
      }
    }).concat(binding_props.map((p2) => x`{ ${p2} }`))})`;
  } else {
    props = x`{
			${node.attributes.map((attribute) => p`${attribute.name}: ${get_prop_value(attribute)}`)},
			${binding_props}
		}`;
  }
  const bindings = x`{
		${binding_fns}
	}`;
  const expression = node.name === "svelte:self" ? renderer.name : node.name === "svelte:component" ? x`(${node.expression.node}) || @missing_component` : node.name.split(".").reduce(
    /** @type {any} */
    (lhs, rhs) => x`${lhs}.${rhs}`
  );
  const slot_fns = [];
  const children = node.children;
  if (children.length) {
    const slot_scopes = /* @__PURE__ */ new Map();
    renderer.render(
      children,
      Object.assign({}, options, {
        slot_scopes
      })
    );
    slot_scopes.forEach(({ input, output, statements }, name49) => {
      slot_fns.push(p`${name49}: (${input}) => { ${statements}; return ${output}; }`);
    });
  }
  const slots = x`{
		${slot_fns}
	}`;
  if (node.css_custom_properties.length > 0) {
    if (node.namespace === namespaces.svg) {
      renderer.add_string('<g style="');
    } else {
      renderer.add_string('<div style="display: contents; ');
    }
    node.css_custom_properties.forEach((attr, index) => {
      renderer.add_string(`${attr.name}:`);
      renderer.add_expression(get_attribute_value(attr));
      renderer.add_string(";");
      if (index < node.css_custom_properties.length - 1)
        renderer.add_string(" ");
    });
    renderer.add_string('">');
  }
  renderer.add_expression(
    x`@validate_component(${expression}, "${node.name}").$$render($$result, ${props}, ${bindings}, ${slots})`
  );
  if (node.css_custom_properties.length > 0) {
    if (node.namespace === namespaces.svg) {
      renderer.add_string("</g>");
    } else {
      renderer.add_string("</div>");
    }
  }
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/KeyBlock.js
function KeyBlock_default(node, renderer, options) {
  renderer.render(node.children, options);
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/shared/get_slot_scope.js
function get_slot_scope(lets) {
  if (lets.length === 0)
    return null;
  return {
    type: "ObjectPattern",
    properties: lets.map((l) => {
      return {
        type: "Property",
        kind: "init",
        method: false,
        shorthand: false,
        computed: false,
        key: l.name,
        value: l.value || l.name
      };
    })
  };
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/Slot.js
function Slot_default(node, renderer, options) {
  const slot_data = get_slot_data(node.values);
  const slot = node.get_static_attribute_value("slot");
  const nearest_inline_component = node.find_nearest(/InlineComponent/);
  if (slot && nearest_inline_component) {
    renderer.push();
  }
  renderer.push();
  renderer.render(node.children, options);
  const result = renderer.pop();
  renderer.add_expression(x`
		#slots.${node.slot_name}
			? #slots.${node.slot_name}(${slot_data})
			: ${result}
	`);
  if (slot && nearest_inline_component) {
    options.slot_scopes.set(slot, {
      input: get_slot_scope(node.lets),
      output: renderer.pop()
    });
  }
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/SlotTemplate.js
function SlotTemplate_default(node, renderer, options) {
  const parent_inline_component = (
    /** @type {import('../../nodes/InlineComponent.js').default} */
    node.parent
  );
  const children = remove_whitespace_children(
    node instanceof SlotTemplate ? node.children : [node],
    node.next
  );
  renderer.push();
  renderer.render(children, options);
  const slot_fragment_content = renderer.pop();
  if (!is_empty_template_literal(slot_fragment_content)) {
    if (options.slot_scopes.has(node.slot_template_name)) {
      if (node.slot_template_name === "default") {
        throw new Error('Found elements without slot attribute when using slot="default"');
      }
      throw new Error(
        `Duplicate slot name "${node.slot_template_name}" in <${parent_inline_component.name}>`
      );
    }
    options.slot_scopes.set(node.slot_template_name, {
      input: get_slot_scope(node.lets),
      output: slot_fragment_content,
      statements: get_const_tags2(node.const_tags)
    });
  }
}
function is_empty_template_literal(template_literal) {
  return template_literal.expressions.length === 0 && template_literal.quasis.length === 1 && template_literal.quasis[0].value.raw === "";
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/Tag.js
function Tag_default(node, renderer, _options) {
  const snippet = node.expression.node;
  renderer.add_expression(
    node.parent && node.parent.type === "Element" && node.parent.name === "style" ? snippet : x`@escape(${snippet})`
  );
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/Text.js
function Text_default(node, renderer, _options) {
  let text2 = node.data;
  if (node.use_space()) {
    text2 = " ";
  } else if (
    // prettier formats one of the type casts incorrectly, moving it outside the parens, therefore disable
    // prettier-ignore
    !node.parent || node.parent.type !== "Element" || /** @type {import('../../nodes/Element.js').default} */
    node.parent.name !== "script" && /** @type {import('../../nodes/Element.js').default} */
    node.parent.name !== "style"
  ) {
    text2 = escape_html(text2);
  }
  renderer.add_string(text2);
}

// node_modules/svelte/src/compiler/compile/render_ssr/handlers/Title.js
function Title_default(node, renderer, options) {
  renderer.push();
  renderer.add_string("<title>");
  renderer.render(node.children, options);
  renderer.add_string("</title>");
  const result = renderer.pop();
  renderer.add_expression(x`$$result.title = ${result}, ""`);
}

// node_modules/svelte/src/compiler/compile/utils/collapse_template_literal.js
function collapse_template_literal(literal2) {
  if (!literal2.quasis.length)
    return;
  const collapsed_quasis = [];
  const collapsed_expressions = [];
  let cur_quasi = literal2.quasis[0];
  for (let i = 0; i < literal2.quasis.length; i++) {
    const expr = literal2.expressions[i];
    const next_quasi = literal2.quasis[i + 1];
    if (next_quasi && expr && expr.type === "Literal" && typeof expr.value === "string") {
      cur_quasi.value.raw += escape_template(expr.value) + next_quasi.value.raw;
    } else {
      if (expr) {
        collapsed_expressions.push(expr);
      }
      collapsed_quasis.push(cur_quasi);
      cur_quasi = next_quasi;
    }
  }
  literal2.quasis = collapsed_quasis;
  literal2.expressions = collapsed_expressions;
}

// node_modules/svelte/src/compiler/compile/render_ssr/Renderer.js
function noop4() {
}
var handlers2 = {
  AwaitBlock: AwaitBlock_default,
  Body: noop4,
  Comment: Comment_default,
  DebugTag: DebugTag_default,
  Document: noop4,
  EachBlock: EachBlock_default,
  Element: Element_default,
  Head: Head_default,
  IfBlock: IfBlock_default,
  InlineComponent: InlineComponent_default,
  KeyBlock: KeyBlock_default,
  MustacheTag: Tag_default,
  Options: noop4,
  RawMustacheTag: HtmlTag_default,
  Slot: Slot_default,
  SlotTemplate: SlotTemplate_default,
  Text: Text_default,
  Title: Title_default,
  Window: noop4
};
var Renderer2 = class {
  constructor({ name: name49 }) {
    __publicField(this, "has_bindings", false);
    /** @type {import('estree').Identifier} */
    __publicField(this, "name");
    /** @type {Array<{ current: { value: string }; literal: import('estree').TemplateLiteral }>} */
    __publicField(this, "stack", []);
    /** @type {{ value: string }} */
    __publicField(this, "current");
    // TODO can it just be `current: string`?
    /** @type {import('estree').TemplateLiteral} */
    __publicField(this, "literal");
    /** @type {import('../../interfaces.js').AppendTarget[]} */
    __publicField(this, "targets", []);
    this.name = name49;
    this.push();
  }
  /** @param {string} str */
  add_string(str) {
    this.current.value += escape_template(str);
  }
  /** @param {import('estree').Expression} node */
  add_expression(node) {
    this.literal.quasis.push({
      type: "TemplateElement",
      value: { raw: this.current.value, cooked: null },
      tail: false
    });
    this.literal.expressions.push(node);
    this.current.value = "";
  }
  push() {
    const current2 = this.current = { value: "" };
    const literal2 = this.literal = {
      type: "TemplateLiteral",
      expressions: [],
      quasis: []
    };
    this.stack.push({ current: current2, literal: literal2 });
  }
  pop() {
    this.literal.quasis.push({
      type: "TemplateElement",
      value: { raw: this.current.value, cooked: null },
      tail: true
    });
    const popped = this.stack.pop();
    const last = this.stack[this.stack.length - 1];
    if (last) {
      this.literal = last.literal;
      this.current = last.current;
    }
    collapse_template_literal(popped.literal);
    return popped.literal;
  }
  /**
   * @param {import('../nodes/interfaces.js').INode[]} nodes
   * @param {import('./private.js').RenderOptions} options
   */
  render(nodes, options) {
    nodes.forEach((node) => {
      const handler = handlers2[node.type];
      if (!handler) {
        throw new Error(`No handler for '${node.type}' nodes`);
      }
      handler(node, this, options);
    });
  }
};

// node_modules/svelte/src/compiler/compile/render_ssr/index.js
function ssr(component, options) {
  const renderer = new Renderer2({
    name: component.name
  });
  const { name: name49 } = component;
  renderer.render(
    trim(component.fragment.children),
    Object.assign(
      {
        locate: component.locate
      },
      options
    )
  );
  const literal2 = renderer.pop();
  const css = options.customElement ? { code: null, map: null } : component.stylesheet.render(options.filename);
  const uses_rest = component.var_lookup.has("$$restProps");
  const props = component.vars.filter((variable) => !variable.module && variable.export_name);
  const rest = uses_rest ? b`let $$restProps = @compute_rest_props($$props, [${props.map((prop) => `"${prop.export_name}"`).join(",")}]);` : null;
  const uses_slots = component.var_lookup.has("$$slots");
  const slots = uses_slots ? b`let $$slots = @compute_slots(#slots);` : null;
  const reactive_stores = component.vars.filter(
    (variable) => variable.name[0] === "$" && variable.name[1] !== "$"
  );
  const reactive_store_subscriptions = reactive_stores.filter((store) => {
    const variable = component.var_lookup.get(store.name.slice(1));
    return !variable || variable.hoistable;
  }).map(({ name: name50 }) => {
    const store_name = name50.slice(1);
    return b`
				${component.compile_options.dev && b`@validate_store(${store_name}, '${store_name}');`}
				${`$$unsubscribe_${store_name}`} = @subscribe(${store_name}, #value => ${name50} = #value)
			`;
  });
  const reactive_store_unsubscriptions = reactive_stores.map(
    ({ name: name50 }) => b`${`$$unsubscribe_${name50.slice(1)}`}()`
  );
  const reactive_store_declarations = reactive_stores.map(({ name: name50 }) => {
    const store_name = name50.slice(1);
    const store = component.var_lookup.get(store_name);
    if (store && store.reassigned) {
      const unsubscribe = `$$unsubscribe_${store_name}`;
      const subscribe = `$$subscribe_${store_name}`;
      return b`let ${name50}, ${unsubscribe} = @noop, ${subscribe} = () => (${unsubscribe}(), ${unsubscribe} = @subscribe(${store_name}, $$value => ${name50} = $$value), ${store_name})`;
    }
    return b`let ${name50}, ${`$$unsubscribe_${store_name}`};`;
  });
  if (component.ast.instance) {
    let scope = component.instance_scope;
    const map = component.instance_scope_map;
    walk(component.ast.instance.content, {
      enter(node) {
        if (map.has(node)) {
          scope = map.get(node);
        }
      },
      leave(node) {
        if (map.has(node)) {
          scope = scope.parent;
        }
        if (node.type === "AssignmentExpression" || node.type === "UpdateExpression") {
          const assignee = node.type === "AssignmentExpression" ? node.left : node.argument;
          const names = new Set(extract_names(
            /** @type {import('estree').Node} */
            assignee
          ));
          const to_invalidate = /* @__PURE__ */ new Set();
          for (const name50 of names) {
            const variable = component.var_lookup.get(name50);
            if (variable && !variable.hoistable && !variable.global && !variable.module && (variable.subscribable || variable.name[0] === "$")) {
              to_invalidate.add(variable.name);
            }
          }
          if (to_invalidate.size) {
            this.replace(
              invalidate(
                /** @type {any} */
                { component },
                scope,
                node,
                to_invalidate,
                true
              )
            );
          }
        }
      }
    });
  }
  component.rewrite_props(({ name: name50, reassigned }) => {
    const value = `$${name50}`;
    let insert = reassigned ? b`${`$$subscribe_${name50}`}()` : b`${`$$unsubscribe_${name50}`} = @subscribe(${name50}, #value => $${value} = #value)`;
    if (component.compile_options.dev) {
      insert = b`@validate_store(${name50}, '${name50}'); ${insert}`;
    }
    return insert;
  });
  const instance_javascript = component.extract_javascript(component.ast.instance);
  const parent_bindings = instance_javascript ? component.vars.filter((variable) => !variable.module && variable.export_name).map((prop) => {
    return b`if ($$props.${prop.export_name} === void 0 && $$bindings.${prop.export_name} && ${prop.name} !== void 0) $$bindings.${prop.export_name}(${prop.name});`;
  }) : [];
  const injected = Array.from(component.injected_reactive_declaration_vars).filter((name50) => {
    const variable = component.var_lookup.get(name50);
    return variable.injected;
  });
  const reactive_declarations = component.reactive_declarations.map((d) => {
    const body = (
      /** @type {import('estree').LabeledStatement} */
      d.node.body
    );
    let statement = b`${body}`;
    if (!d.declaration) {
      statement = b`$: { ${statement} }`;
    }
    return statement;
  });
  const main = renderer.has_bindings ? b`
			let $$settled;
			let $$rendered;
			let #previous_head = $$result.head;

			do {
				$$settled = true;
				// $$result.head is mutated by the literal expression
				// need to reset it if we're looping back to prevent duplication
				$$result.head = #previous_head;

				${reactive_declarations}

				$$rendered = ${literal2};
			} while (!$$settled);

			${reactive_store_unsubscriptions}

			return $$rendered;
		` : b`
			${reactive_declarations}

			${reactive_store_unsubscriptions}

			return ${literal2};`;
  const blocks = [
    ...injected.map((name50) => b`let ${name50};`),
    rest,
    slots,
    ...reactive_store_declarations,
    ...reactive_store_subscriptions,
    instance_javascript,
    ...parent_bindings,
    css.code && b`$$result.css.add(#css);`,
    main
  ].filter(Boolean);
  const css_sourcemap_enabled = check_enable_sourcemap(options.enableSourcemap, "css");
  const js = b`
		${css.code ? b`
		const #css = {
			code: "${css.code}",
			map: ${css_sourcemap_enabled && css.map ? string_literal(css.map.toString()) : "null"}
		};` : null}

		${component.extract_javascript(component.ast.module)}

		${component.fully_hoisted}

		const ${name49} = @create_ssr_component(($$result, $$props, $$bindings, #slots) => {
			${blocks}
		});
	`;
  return { js, css };
}
function trim(nodes) {
  let start = 0;
  for (; start < nodes.length; start += 1) {
    const node = (
      /** @type {import('../nodes/Text.js').default} */
      nodes[start]
    );
    if (node.type !== "Text")
      break;
    node.data = node.data.replace(/^\s+/, "");
    if (node.data)
      break;
  }
  let end = nodes.length;
  for (; end > start; end -= 1) {
    const node = (
      /** @type {import('../nodes/Text.js').default} */
      nodes[end - 1]
    );
    if (node.type !== "Text")
      break;
    node.data = node.data.trimRight();
    if (node.data)
      break;
  }
  return nodes.slice(start, end);
}

// node_modules/svelte/src/compiler/compile/Component.js
var import_trace_mapping = __toESM(require_trace_mapping_umd(), 1);

// node_modules/svelte/src/compiler/utils/globals.js
var globals_default = /* @__PURE__ */ new Set([
  "AbortController",
  "AbortSignal",
  "AbstractRange",
  "ActiveXObject",
  "AggregateError",
  "AnalyserNode",
  "Animation",
  "AnimationEffect",
  "AnimationEvent",
  "AnimationPlaybackEvent",
  "AnimationTimeline",
  "Array",
  "ArrayBuffer",
  "Atomics",
  "Attr",
  "Audio",
  "AudioBuffer",
  "AudioBufferSourceNode",
  "AudioContext",
  "AudioDestinationNode",
  "AudioListener",
  "AudioNode",
  "AudioParam",
  "AudioParamMap",
  "AudioProcessingEvent",
  "AudioScheduledSourceNode",
  "AudioWorklet",
  "AudioWorkletNode",
  "AuthenticatorAssertionResponse",
  "AuthenticatorAttestationResponse",
  "AuthenticatorResponse",
  "BarProp",
  "BaseAudioContext",
  "BeforeUnloadEvent",
  "BigInt",
  "BigInt64Array",
  "BigUint64Array",
  "BiquadFilterNode",
  "Blob",
  "BlobEvent",
  "Boolean",
  "BroadcastChannel",
  "ByteLengthQueuingStrategy",
  "CDATASection",
  "CSS",
  "CSSAnimation",
  "CSSConditionRule",
  "CSSCounterStyleRule",
  "CSSFontFaceRule",
  "CSSGroupingRule",
  "CSSImportRule",
  "CSSKeyframeRule",
  "CSSKeyframesRule",
  "CSSMediaRule",
  "CSSNamespaceRule",
  "CSSPageRule",
  "CSSRule",
  "CSSRuleList",
  "CSSStyleDeclaration",
  "CSSStyleRule",
  "CSSStyleSheet",
  "CSSSupportsRule",
  "CSSTransition",
  "Cache",
  "CacheStorage",
  "CanvasCaptureMediaStreamTrack",
  "CanvasGradient",
  "CanvasPattern",
  "CanvasRenderingContext2D",
  "ChannelMergerNode",
  "ChannelSplitterNode",
  "CharacterData",
  "ClientRect",
  "Clipboard",
  "ClipboardEvent",
  "ClipboardItem",
  "CloseEvent",
  "Comment",
  "CompositionEvent",
  "ConstantSourceNode",
  "ConvolverNode",
  "CountQueuingStrategy",
  "Credential",
  "CredentialsContainer",
  "Crypto",
  "CryptoKey",
  "CustomElementRegistry",
  "CustomEvent",
  "DOMException",
  "DOMImplementation",
  "DOMMatrix",
  "DOMMatrixReadOnly",
  "DOMParser",
  "DOMPoint",
  "DOMPointReadOnly",
  "DOMQuad",
  "DOMRect",
  "DOMRectList",
  "DOMRectReadOnly",
  "DOMStringList",
  "DOMStringMap",
  "DOMTokenList",
  "DataTransfer",
  "DataTransferItem",
  "DataTransferItemList",
  "DataView",
  "Date",
  "DelayNode",
  "DeviceMotionEvent",
  "DeviceOrientationEvent",
  "Document",
  "DocumentFragment",
  "DocumentTimeline",
  "DocumentType",
  "DragEvent",
  "DynamicsCompressorNode",
  "Element",
  "ElementInternals",
  "Enumerator",
  "Error",
  "ErrorEvent",
  "EvalError",
  "Event",
  "EventCounts",
  "EventSource",
  "EventTarget",
  "External",
  "File",
  "FileList",
  "FileReader",
  "FileSystem",
  "FileSystemDirectoryEntry",
  "FileSystemDirectoryHandle",
  "FileSystemDirectoryReader",
  "FileSystemEntry",
  "FileSystemFileEntry",
  "FileSystemFileHandle",
  "FileSystemHandle",
  "FinalizationRegistry",
  "Float32Array",
  "Float64Array",
  "FocusEvent",
  "FontFace",
  "FontFaceSet",
  "FontFaceSetLoadEvent",
  "FormData",
  "FormDataEvent",
  "Function",
  "GainNode",
  "Gamepad",
  "GamepadButton",
  "GamepadEvent",
  "GamepadHapticActuator",
  "Geolocation",
  "GeolocationCoordinates",
  "GeolocationPosition",
  "GeolocationPositionError",
  "HTMLAllCollection",
  "HTMLAnchorElement",
  "HTMLAreaElement",
  "HTMLAudioElement",
  "HTMLBRElement",
  "HTMLBaseElement",
  "HTMLBodyElement",
  "HTMLButtonElement",
  "HTMLCanvasElement",
  "HTMLCollection",
  "HTMLDListElement",
  "HTMLDataElement",
  "HTMLDataListElement",
  "HTMLDetailsElement",
  "HTMLDialogElement",
  "HTMLDirectoryElement",
  "HTMLDivElement",
  "HTMLDocument",
  "HTMLElement",
  "HTMLEmbedElement",
  "HTMLFieldSetElement",
  "HTMLFontElement",
  "HTMLFormControlsCollection",
  "HTMLFormElement",
  "HTMLFrameElement",
  "HTMLFrameSetElement",
  "HTMLHRElement",
  "HTMLHeadElement",
  "HTMLHeadingElement",
  "HTMLHtmlElement",
  "HTMLIFrameElement",
  "HTMLImageElement",
  "HTMLInputElement",
  "HTMLLIElement",
  "HTMLLabelElement",
  "HTMLLegendElement",
  "HTMLLinkElement",
  "HTMLMapElement",
  "HTMLMarqueeElement",
  "HTMLMediaElement",
  "HTMLMenuElement",
  "HTMLMetaElement",
  "HTMLMeterElement",
  "HTMLModElement",
  "HTMLOListElement",
  "HTMLObjectElement",
  "HTMLOptGroupElement",
  "HTMLOptionElement",
  "HTMLOptionsCollection",
  "HTMLOutputElement",
  "HTMLParagraphElement",
  "HTMLParamElement",
  "HTMLPictureElement",
  "HTMLPreElement",
  "HTMLProgressElement",
  "HTMLQuoteElement",
  "HTMLScriptElement",
  "HTMLSelectElement",
  "HTMLSlotElement",
  "HTMLSourceElement",
  "HTMLSpanElement",
  "HTMLStyleElement",
  "HTMLTableCaptionElement",
  "HTMLTableCellElement",
  "HTMLTableColElement",
  "HTMLTableElement",
  "HTMLTableRowElement",
  "HTMLTableSectionElement",
  "HTMLTemplateElement",
  "HTMLTextAreaElement",
  "HTMLTimeElement",
  "HTMLTitleElement",
  "HTMLTrackElement",
  "HTMLUListElement",
  "HTMLUnknownElement",
  "HTMLVideoElement",
  "HashChangeEvent",
  "Headers",
  "History",
  "IDBCursor",
  "IDBCursorWithValue",
  "IDBDatabase",
  "IDBFactory",
  "IDBIndex",
  "IDBKeyRange",
  "IDBObjectStore",
  "IDBOpenDBRequest",
  "IDBRequest",
  "IDBTransaction",
  "IDBVersionChangeEvent",
  "IIRFilterNode",
  "IdleDeadline",
  "Image",
  "ImageBitmap",
  "ImageBitmapRenderingContext",
  "ImageData",
  "Infinity",
  "InputDeviceInfo",
  "InputEvent",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "InternalError",
  "IntersectionObserver",
  "IntersectionObserverEntry",
  "Intl",
  "JSON",
  "KeyboardEvent",
  "KeyframeEffect",
  "Location",
  "Lock",
  "LockManager",
  "Map",
  "Math",
  "MathMLElement",
  "MediaCapabilities",
  "MediaDeviceInfo",
  "MediaDevices",
  "MediaElementAudioSourceNode",
  "MediaEncryptedEvent",
  "MediaError",
  "MediaKeyMessageEvent",
  "MediaKeySession",
  "MediaKeyStatusMap",
  "MediaKeySystemAccess",
  "MediaKeys",
  "MediaList",
  "MediaMetadata",
  "MediaQueryList",
  "MediaQueryListEvent",
  "MediaRecorder",
  "MediaRecorderErrorEvent",
  "MediaSession",
  "MediaSource",
  "MediaStream",
  "MediaStreamAudioDestinationNode",
  "MediaStreamAudioSourceNode",
  "MediaStreamTrack",
  "MediaStreamTrackEvent",
  "MessageChannel",
  "MessageEvent",
  "MessagePort",
  "MimeType",
  "MimeTypeArray",
  "MouseEvent",
  "MutationEvent",
  "MutationObserver",
  "MutationRecord",
  "NaN",
  "NamedNodeMap",
  "NavigationPreloadManager",
  "Navigator",
  "NetworkInformation",
  "Node",
  "NodeFilter",
  "NodeIterator",
  "NodeList",
  "Notification",
  "Number",
  "Object",
  "OfflineAudioCompletionEvent",
  "OfflineAudioContext",
  "Option",
  "OscillatorNode",
  "OverconstrainedError",
  "PageTransitionEvent",
  "PannerNode",
  "Path2D",
  "PaymentAddress",
  "PaymentMethodChangeEvent",
  "PaymentRequest",
  "PaymentRequestUpdateEvent",
  "PaymentResponse",
  "Performance",
  "PerformanceEntry",
  "PerformanceEventTiming",
  "PerformanceMark",
  "PerformanceMeasure",
  "PerformanceNavigation",
  "PerformanceNavigationTiming",
  "PerformanceObserver",
  "PerformanceObserverEntryList",
  "PerformancePaintTiming",
  "PerformanceResourceTiming",
  "PerformanceServerTiming",
  "PerformanceTiming",
  "PeriodicWave",
  "PermissionStatus",
  "Permissions",
  "PictureInPictureWindow",
  "Plugin",
  "PluginArray",
  "PointerEvent",
  "PopStateEvent",
  "ProcessingInstruction",
  "ProgressEvent",
  "Promise",
  "PromiseRejectionEvent",
  "Proxy",
  "PublicKeyCredential",
  "PushManager",
  "PushSubscription",
  "PushSubscriptionOptions",
  "RTCCertificate",
  "RTCDTMFSender",
  "RTCDTMFToneChangeEvent",
  "RTCDataChannel",
  "RTCDataChannelEvent",
  "RTCDtlsTransport",
  "RTCEncodedAudioFrame",
  "RTCEncodedVideoFrame",
  "RTCError",
  "RTCErrorEvent",
  "RTCIceCandidate",
  "RTCIceTransport",
  "RTCPeerConnection",
  "RTCPeerConnectionIceErrorEvent",
  "RTCPeerConnectionIceEvent",
  "RTCRtpReceiver",
  "RTCRtpSender",
  "RTCRtpTransceiver",
  "RTCSctpTransport",
  "RTCSessionDescription",
  "RTCStatsReport",
  "RTCTrackEvent",
  "RadioNodeList",
  "Range",
  "RangeError",
  "ReadableByteStreamController",
  "ReadableStream",
  "ReadableStreamBYOBReader",
  "ReadableStreamBYOBRequest",
  "ReadableStreamDefaultController",
  "ReadableStreamDefaultReader",
  "ReferenceError",
  "Reflect",
  "RegExp",
  "RemotePlayback",
  "Request",
  "ResizeObserver",
  "ResizeObserverEntry",
  "ResizeObserverSize",
  "Response",
  "SVGAElement",
  "SVGAngle",
  "SVGAnimateElement",
  "SVGAnimateMotionElement",
  "SVGAnimateTransformElement",
  "SVGAnimatedAngle",
  "SVGAnimatedBoolean",
  "SVGAnimatedEnumeration",
  "SVGAnimatedInteger",
  "SVGAnimatedLength",
  "SVGAnimatedLengthList",
  "SVGAnimatedNumber",
  "SVGAnimatedNumberList",
  "SVGAnimatedPreserveAspectRatio",
  "SVGAnimatedRect",
  "SVGAnimatedString",
  "SVGAnimatedTransformList",
  "SVGAnimationElement",
  "SVGCircleElement",
  "SVGClipPathElement",
  "SVGComponentTransferFunctionElement",
  "SVGCursorElement",
  "SVGDefsElement",
  "SVGDescElement",
  "SVGElement",
  "SVGEllipseElement",
  "SVGFEBlendElement",
  "SVGFEColorMatrixElement",
  "SVGFEComponentTransferElement",
  "SVGFECompositeElement",
  "SVGFEConvolveMatrixElement",
  "SVGFEDiffuseLightingElement",
  "SVGFEDisplacementMapElement",
  "SVGFEDistantLightElement",
  "SVGFEDropShadowElement",
  "SVGFEFloodElement",
  "SVGFEFuncAElement",
  "SVGFEFuncBElement",
  "SVGFEFuncGElement",
  "SVGFEFuncRElement",
  "SVGFEGaussianBlurElement",
  "SVGFEImageElement",
  "SVGFEMergeElement",
  "SVGFEMergeNodeElement",
  "SVGFEMorphologyElement",
  "SVGFEOffsetElement",
  "SVGFEPointLightElement",
  "SVGFESpecularLightingElement",
  "SVGFESpotLightElement",
  "SVGFETileElement",
  "SVGFETurbulenceElement",
  "SVGFilterElement",
  "SVGForeignObjectElement",
  "SVGGElement",
  "SVGGeometryElement",
  "SVGGradientElement",
  "SVGGraphicsElement",
  "SVGImageElement",
  "SVGLength",
  "SVGLengthList",
  "SVGLineElement",
  "SVGLinearGradientElement",
  "SVGMPathElement",
  "SVGMarkerElement",
  "SVGMaskElement",
  "SVGMatrix",
  "SVGMetadataElement",
  "SVGNumber",
  "SVGNumberList",
  "SVGPathElement",
  "SVGPatternElement",
  "SVGPoint",
  "SVGPointList",
  "SVGPolygonElement",
  "SVGPolylineElement",
  "SVGPreserveAspectRatio",
  "SVGRadialGradientElement",
  "SVGRect",
  "SVGRectElement",
  "SVGSVGElement",
  "SVGScriptElement",
  "SVGSetElement",
  "SVGStopElement",
  "SVGStringList",
  "SVGStyleElement",
  "SVGSwitchElement",
  "SVGSymbolElement",
  "SVGTSpanElement",
  "SVGTextContentElement",
  "SVGTextElement",
  "SVGTextPathElement",
  "SVGTextPositioningElement",
  "SVGTitleElement",
  "SVGTransform",
  "SVGTransformList",
  "SVGUnitTypes",
  "SVGUseElement",
  "SVGViewElement",
  "SafeArray",
  "Screen",
  "ScreenOrientation",
  "ScriptProcessorNode",
  "SecurityPolicyViolationEvent",
  "Selection",
  "ServiceWorker",
  "ServiceWorkerContainer",
  "ServiceWorkerRegistration",
  "Set",
  "ShadowRoot",
  "SharedArrayBuffer",
  "SharedWorker",
  "SourceBuffer",
  "SourceBufferList",
  "SpeechRecognitionAlternative",
  "SpeechRecognitionErrorEvent",
  "SpeechRecognitionResult",
  "SpeechRecognitionResultList",
  "SpeechSynthesis",
  "SpeechSynthesisErrorEvent",
  "SpeechSynthesisEvent",
  "SpeechSynthesisUtterance",
  "SpeechSynthesisVoice",
  "StaticRange",
  "StereoPannerNode",
  "Storage",
  "StorageEvent",
  "StorageManager",
  "String",
  "StyleMedia",
  "StyleSheet",
  "StyleSheetList",
  "SubmitEvent",
  "SubtleCrypto",
  "Symbol",
  "SyntaxError",
  "Text",
  "TextDecoder",
  "TextDecoderStream",
  "TextEncoder",
  "TextEncoderStream",
  "TextMetrics",
  "TextTrack",
  "TextTrackCue",
  "TextTrackCueList",
  "TextTrackList",
  "TimeRanges",
  "Touch",
  "TouchEvent",
  "TouchList",
  "TrackEvent",
  "TransformStream",
  "TransformStreamDefaultController",
  "TransitionEvent",
  "TreeWalker",
  "TypeError",
  "UIEvent",
  "URIError",
  "URL",
  "URLSearchParams",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "VBArray",
  "VTTCue",
  "VTTRegion",
  "ValidityState",
  "VarDate",
  "VideoColorSpace",
  "VideoPlaybackQuality",
  "VisualViewport",
  "WSH",
  "WScript",
  "WaveShaperNode",
  "WeakMap",
  "WeakRef",
  "WeakSet",
  "WebAssembly",
  "WebGL2RenderingContext",
  "WebGLActiveInfo",
  "WebGLBuffer",
  "WebGLContextEvent",
  "WebGLFramebuffer",
  "WebGLProgram",
  "WebGLQuery",
  "WebGLRenderbuffer",
  "WebGLRenderingContext",
  "WebGLSampler",
  "WebGLShader",
  "WebGLShaderPrecisionFormat",
  "WebGLSync",
  "WebGLTexture",
  "WebGLTransformFeedback",
  "WebGLUniformLocation",
  "WebGLVertexArrayObject",
  "WebKitCSSMatrix",
  "WebSocket",
  "WheelEvent",
  "Window",
  "Worker",
  "Worklet",
  "WritableStream",
  "WritableStreamDefaultController",
  "WritableStreamDefaultWriter",
  "XMLDocument",
  "XMLHttpRequest",
  "XMLHttpRequestEventTarget",
  "XMLHttpRequestUpload",
  "XMLSerializer",
  "XPathEvaluator",
  "XPathExpression",
  "XPathResult",
  "XSLTProcessor",
  "addEventListener",
  "alert",
  "atob",
  "blur",
  "btoa",
  "caches",
  "cancelAnimationFrame",
  "cancelIdleCallback",
  "captureEvents",
  "clearInterval",
  "clearTimeout",
  "clientInformation",
  "close",
  "closed",
  "confirm",
  "console",
  "createImageBitmap",
  "crossOriginIsolated",
  "crypto",
  "customElements",
  "decodeURI",
  "decodeURIComponent",
  "devicePixelRatio",
  "dispatchEvent",
  "document",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "eval",
  "event",
  "external",
  "fetch",
  "focus",
  "frameElement",
  "frames",
  "getComputedStyle",
  "getSelection",
  "global",
  "globalThis",
  "history",
  "importScripts",
  "indexedDB",
  "innerHeight",
  "innerWidth",
  "isFinite",
  "isNaN",
  "isSecureContext",
  "length",
  "localStorage",
  "location",
  "locationbar",
  "matchMedia",
  "menubar",
  "moveBy",
  "moveTo",
  "name",
  "navigator",
  "onabort",
  "onafterprint",
  "onanimationcancel",
  "onanimationend",
  "onanimationiteration",
  "onanimationstart",
  "onauxclick",
  "onbeforeprint",
  "onbeforeunload",
  "onblur",
  "oncanplay",
  "oncanplaythrough",
  "onchange",
  "onclick",
  "onclose",
  "oncontextmenu",
  "oncuechange",
  "ondblclick",
  "ondevicemotion",
  "ondeviceorientation",
  "ondrag",
  "ondragend",
  "ondragenter",
  "ondragleave",
  "ondragover",
  "ondragstart",
  "ondrop",
  "ondurationchange",
  "onemptied",
  "onended",
  "onerror",
  "onfocus",
  "onformdata",
  "ongamepadconnected",
  "ongamepaddisconnected",
  "ongotpointercapture",
  "onhashchange",
  "oninput",
  "oninvalid",
  "onkeydown",
  "onkeypress",
  "onkeyup",
  "onlanguagechange",
  "onload",
  "onloadeddata",
  "onloadedmetadata",
  "onloadstart",
  "onlostpointercapture",
  "onmessage",
  "onmessageerror",
  "onmousedown",
  "onmouseenter",
  "onmouseleave",
  "onmousemove",
  "onmouseout",
  "onmouseover",
  "onmouseup",
  "onoffline",
  "ononline",
  "onorientationchange",
  "onpagehide",
  "onpageshow",
  "onpause",
  "onplay",
  "onplaying",
  "onpointercancel",
  "onpointerdown",
  "onpointerenter",
  "onpointerleave",
  "onpointermove",
  "onpointerout",
  "onpointerover",
  "onpointerup",
  "onpopstate",
  "onprogress",
  "onratechange",
  "onrejectionhandled",
  "onreset",
  "onresize",
  "onscroll",
  "onsecuritypolicyviolation",
  "onseeked",
  "onseeking",
  "onselect",
  "onselectionchange",
  "onselectstart",
  "onslotchange",
  "onstalled",
  "onstorage",
  "onsubmit",
  "onsuspend",
  "ontimeupdate",
  "ontoggle",
  "ontouchcancel",
  "ontouchend",
  "ontouchmove",
  "ontouchstart",
  "ontransitioncancel",
  "ontransitionend",
  "ontransitionrun",
  "ontransitionstart",
  "onunhandledrejection",
  "onunload",
  "onvolumechange",
  "onwaiting",
  "onwebkitanimationend",
  "onwebkitanimationiteration",
  "onwebkitanimationstart",
  "onwebkittransitionend",
  "onwheel",
  "open",
  "opener",
  "orientation",
  "origin",
  "outerHeight",
  "outerWidth",
  "pageXOffset",
  "pageYOffset",
  "parent",
  "parseFloat",
  "parseInt",
  "performance",
  "personalbar",
  "postMessage",
  "print",
  "process",
  "prompt",
  "queueMicrotask",
  "releaseEvents",
  "removeEventListener",
  "reportError",
  "requestAnimationFrame",
  "requestIdleCallback",
  "resizeBy",
  "resizeTo",
  "screen",
  "screenLeft",
  "screenTop",
  "screenX",
  "screenY",
  "scroll",
  "scrollBy",
  "scrollTo",
  "scrollX",
  "scrollY",
  "scrollbars",
  "self",
  "sessionStorage",
  "setInterval",
  "setTimeout",
  "speechSynthesis",
  "status",
  "statusbar",
  "stop",
  "structuredClone",
  "toString",
  "toolbar",
  "top",
  "undefined",
  "unescape",
  "visualViewport",
  "webkitURL",
  "window"
]);

// node_modules/svelte/src/compiler/compile/create_module.js
function create_module(program, name49, banner, svelte_path = "svelte", helpers, globals, imports, module_exports, exports_from) {
  const internal_path = `${svelte_path}/internal`;
  helpers.sort((a, b2) => a.name < b2.name ? -1 : 1);
  globals.sort((a, b2) => a.name < b2.name ? -1 : 1);
  return esm(
    program,
    name49,
    banner,
    svelte_path,
    internal_path,
    helpers,
    globals,
    imports,
    module_exports,
    exports_from
  );
}
function edit_source(source, svelte_path) {
  return source === "svelte" || source.startsWith("svelte/") ? source.replace("svelte", svelte_path) : source;
}
function get_internal_globals(globals, helpers) {
  return globals.length > 0 && {
    type: "VariableDeclaration",
    kind: "const",
    declarations: [
      {
        type: "VariableDeclarator",
        id: {
          type: "ObjectPattern",
          properties: globals.map((g) => ({
            type: "Property",
            method: false,
            shorthand: false,
            computed: false,
            key: { type: "Identifier", name: g.name },
            value: g.alias,
            kind: "init"
          }))
        },
        init: helpers.find(({ name: name49 }) => name49 === "globals").alias
      }
    ]
  };
}
function esm(program, name49, banner, svelte_path, internal_path, helpers, globals, imports, module_exports, exports_from) {
  const import_declaration = {
    type: "ImportDeclaration",
    specifiers: helpers.map((h) => ({
      type: "ImportSpecifier",
      local: h.alias,
      imported: { type: "Identifier", name: h.name }
    })),
    source: { type: "Literal", value: internal_path }
  };
  const internal_globals = get_internal_globals(globals, helpers);
  function rewrite_import(node) {
    const value = edit_source(node.source.value, svelte_path);
    if (node.source.value !== value) {
      node.source.value = value;
      node.source.raw = null;
    }
  }
  imports.forEach(rewrite_import);
  exports_from.forEach(rewrite_import);
  const exports = module_exports.length > 0 && {
    type: "ExportNamedDeclaration",
    specifiers: module_exports.map((x2) => ({
      type: "Specifier",
      local: { type: "Identifier", name: x2.name },
      exported: { type: "Identifier", name: x2.as }
    }))
  };
  program.body = b`
		/* ${banner} */

		${import_declaration}
		${internal_globals}
		${imports}
		${exports_from}

		${program.body}

		export default ${name49};
		${exports}
	`;
}

// node_modules/magic-string/dist/magic-string.es.mjs
var import_sourcemap_codec2 = __toESM(require_sourcemap_codec_umd(), 1);
var BitSet = class _BitSet {
  constructor(arg) {
    this.bits = arg instanceof _BitSet ? arg.bits.slice() : [];
  }
  add(n2) {
    this.bits[n2 >> 5] |= 1 << (n2 & 31);
  }
  has(n2) {
    return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));
  }
};
var Chunk = class _Chunk {
  constructor(start, end, content) {
    this.start = start;
    this.end = end;
    this.original = content;
    this.intro = "";
    this.outro = "";
    this.content = content;
    this.storeName = false;
    this.edited = false;
    {
      this.previous = null;
      this.next = null;
    }
  }
  appendLeft(content) {
    this.outro += content;
  }
  appendRight(content) {
    this.intro = this.intro + content;
  }
  clone() {
    const chunk = new _Chunk(this.start, this.end, this.original);
    chunk.intro = this.intro;
    chunk.outro = this.outro;
    chunk.content = this.content;
    chunk.storeName = this.storeName;
    chunk.edited = this.edited;
    return chunk;
  }
  contains(index) {
    return this.start < index && index < this.end;
  }
  eachNext(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.next;
    }
  }
  eachPrevious(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.previous;
    }
  }
  edit(content, storeName, contentOnly) {
    this.content = content;
    if (!contentOnly) {
      this.intro = "";
      this.outro = "";
    }
    this.storeName = storeName;
    this.edited = true;
    return this;
  }
  prependLeft(content) {
    this.outro = content + this.outro;
  }
  prependRight(content) {
    this.intro = content + this.intro;
  }
  reset() {
    this.intro = "";
    this.outro = "";
    if (this.edited) {
      this.content = this.original;
      this.storeName = false;
      this.edited = false;
    }
  }
  split(index) {
    const sliceIndex = index - this.start;
    const originalBefore = this.original.slice(0, sliceIndex);
    const originalAfter = this.original.slice(sliceIndex);
    this.original = originalBefore;
    const newChunk = new _Chunk(index, this.end, originalAfter);
    newChunk.outro = this.outro;
    this.outro = "";
    this.end = index;
    if (this.edited) {
      newChunk.edit("", false);
      this.content = "";
    } else {
      this.content = originalBefore;
    }
    newChunk.next = this.next;
    if (newChunk.next)
      newChunk.next.previous = newChunk;
    newChunk.previous = this;
    this.next = newChunk;
    return newChunk;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(rx) {
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length)
      return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.start + trimmed.length).edit("", void 0, true);
        if (this.edited) {
          this.edit(trimmed, this.storeName, true);
        }
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length)
        return true;
    }
  }
  trimStart(rx) {
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length)
      return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        const newChunk = this.split(this.end - trimmed.length);
        if (this.edited) {
          newChunk.edit(trimmed, this.storeName, true);
        }
        this.edit("", void 0, true);
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length)
        return true;
    }
  }
};
function getBtoa() {
  if (typeof globalThis !== "undefined" && typeof globalThis.btoa === "function") {
    return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
  } else if (typeof Buffer === "function") {
    return (str) => Buffer.from(str, "utf-8").toString("base64");
  } else {
    return () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
  }
}
var btoa2 = getBtoa();
var SourceMap = class {
  constructor(properties3) {
    this.version = 3;
    this.file = properties3.file;
    this.sources = properties3.sources;
    this.sourcesContent = properties3.sourcesContent;
    this.names = properties3.names;
    this.mappings = (0, import_sourcemap_codec2.encode)(properties3.mappings);
    if (typeof properties3.x_google_ignoreList !== "undefined") {
      this.x_google_ignoreList = properties3.x_google_ignoreList;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + btoa2(this.toString());
  }
};
function guessIndent(code2) {
  const lines = code2.split("\n");
  const tabbed = lines.filter((line) => /^\t+/.test(line));
  const spaced = lines.filter((line) => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }
  if (tabbed.length >= spaced.length) {
    return "	";
  }
  const min = spaced.reduce((previous, current2) => {
    const numSpaces = /^ +/.exec(current2)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min + 1).join(" ");
}
function getRelativePath(from, to) {
  const fromParts = from.split(/[/\\]/);
  const toParts = to.split(/[/\\]/);
  fromParts.pop();
  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    let i = fromParts.length;
    while (i--)
      fromParts[i] = "..";
  }
  return fromParts.concat(toParts).join("/");
}
var toString2 = Object.prototype.toString;
function isObject(thing) {
  return toString2.call(thing) === "[object Object]";
}
function getLocator2(source) {
  const originalLines = source.split("\n");
  const lineOffsets = [];
  for (let i = 0, pos = 0; i < originalLines.length; i++) {
    lineOffsets.push(pos);
    pos += originalLines[i].length + 1;
  }
  return function locate2(index) {
    let i = 0;
    let j = lineOffsets.length;
    while (i < j) {
      const m = i + j >> 1;
      if (index < lineOffsets[m]) {
        j = m;
      } else {
        i = m + 1;
      }
    }
    const line = i - 1;
    const column = index - lineOffsets[line];
    return { line, column };
  };
}
var wordRegex = /\w/;
var Mappings = class {
  constructor(hires) {
    this.hires = hires;
    this.generatedCodeLine = 0;
    this.generatedCodeColumn = 0;
    this.raw = [];
    this.rawSegments = this.raw[this.generatedCodeLine] = [];
    this.pending = null;
  }
  addEdit(sourceIndex, content, loc, nameIndex) {
    if (content.length) {
      const contentLengthMinusOne = content.length - 1;
      let contentLineEnd = content.indexOf("\n", 0);
      let previousContentLineEnd = -1;
      while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
        const segment2 = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (nameIndex >= 0) {
          segment2.push(nameIndex);
        }
        this.rawSegments.push(segment2);
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        previousContentLineEnd = contentLineEnd;
        contentLineEnd = content.indexOf("\n", contentLineEnd + 1);
      }
      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
      if (nameIndex >= 0) {
        segment.push(nameIndex);
      }
      this.rawSegments.push(segment);
      this.advance(content.slice(previousContentLineEnd + 1));
    } else if (this.pending) {
      this.rawSegments.push(this.pending);
      this.advance(content);
    }
    this.pending = null;
  }
  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
    let originalCharIndex = chunk.start;
    let first = true;
    let charInHiresBoundary = false;
    while (originalCharIndex < chunk.end) {
      if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
        const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (this.hires === "boundary") {
          if (wordRegex.test(original[originalCharIndex])) {
            if (!charInHiresBoundary) {
              this.rawSegments.push(segment);
              charInHiresBoundary = true;
            }
          } else {
            this.rawSegments.push(segment);
            charInHiresBoundary = false;
          }
        } else {
          this.rawSegments.push(segment);
        }
      }
      if (original[originalCharIndex] === "\n") {
        loc.line += 1;
        loc.column = 0;
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        first = true;
      } else {
        loc.column += 1;
        this.generatedCodeColumn += 1;
        first = false;
      }
      originalCharIndex += 1;
    }
    this.pending = null;
  }
  advance(str) {
    if (!str)
      return;
    const lines = str.split("\n");
    if (lines.length > 1) {
      for (let i = 0; i < lines.length - 1; i++) {
        this.generatedCodeLine++;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
      }
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += lines[lines.length - 1].length;
  }
};
var n = "\n";
var warned = {
  insertLeft: false,
  insertRight: false,
  storeName: false
};
var MagicString = class _MagicString {
  constructor(string, options = {}) {
    const chunk = new Chunk(0, string.length, string);
    Object.defineProperties(this, {
      original: { writable: true, value: string },
      outro: { writable: true, value: "" },
      intro: { writable: true, value: "" },
      firstChunk: { writable: true, value: chunk },
      lastChunk: { writable: true, value: chunk },
      lastSearchedChunk: { writable: true, value: chunk },
      byStart: { writable: true, value: {} },
      byEnd: { writable: true, value: {} },
      filename: { writable: true, value: options.filename },
      indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
      sourcemapLocations: { writable: true, value: new BitSet() },
      storedNames: { writable: true, value: {} },
      indentStr: { writable: true, value: void 0 },
      ignoreList: { writable: true, value: options.ignoreList }
    });
    this.byStart[0] = chunk;
    this.byEnd[string.length] = chunk;
  }
  addSourcemapLocation(char) {
    this.sourcemapLocations.add(char);
  }
  append(content) {
    if (typeof content !== "string")
      throw new TypeError("outro content must be a string");
    this.outro += content;
    return this;
  }
  appendLeft(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.appendLeft(content);
    } else {
      this.intro += content;
    }
    return this;
  }
  appendRight(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.appendRight(content);
    } else {
      this.outro += content;
    }
    return this;
  }
  clone() {
    const cloned = new _MagicString(this.original, { filename: this.filename });
    let originalChunk = this.firstChunk;
    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
    while (originalChunk) {
      cloned.byStart[clonedChunk.start] = clonedChunk;
      cloned.byEnd[clonedChunk.end] = clonedChunk;
      const nextOriginalChunk = originalChunk.next;
      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
      if (nextClonedChunk) {
        clonedChunk.next = nextClonedChunk;
        nextClonedChunk.previous = clonedChunk;
        clonedChunk = nextClonedChunk;
      }
      originalChunk = nextOriginalChunk;
    }
    cloned.lastChunk = clonedChunk;
    if (this.indentExclusionRanges) {
      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
    }
    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
    cloned.intro = this.intro;
    cloned.outro = this.outro;
    return cloned;
  }
  generateDecodedMap(options) {
    options = options || {};
    const sourceIndex = 0;
    const names = Object.keys(this.storedNames);
    const mappings = new Mappings(options.hires);
    const locate2 = getLocator2(this.original);
    if (this.intro) {
      mappings.advance(this.intro);
    }
    this.firstChunk.eachNext((chunk) => {
      const loc = locate2(chunk.start);
      if (chunk.intro.length)
        mappings.advance(chunk.intro);
      if (chunk.edited) {
        mappings.addEdit(
          sourceIndex,
          chunk.content,
          loc,
          chunk.storeName ? names.indexOf(chunk.original) : -1
        );
      } else {
        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
      }
      if (chunk.outro.length)
        mappings.advance(chunk.outro);
    });
    return {
      file: options.file ? options.file.split(/[/\\]/).pop() : void 0,
      sources: [
        options.source ? getRelativePath(options.file || "", options.source) : options.file || ""
      ],
      sourcesContent: options.includeContent ? [this.original] : void 0,
      names,
      mappings: mappings.raw,
      x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0
    };
  }
  generateMap(options) {
    return new SourceMap(this.generateDecodedMap(options));
  }
  _ensureindentStr() {
    if (this.indentStr === void 0) {
      this.indentStr = guessIndent(this.original);
    }
  }
  _getRawIndentString() {
    this._ensureindentStr();
    return this.indentStr;
  }
  getIndentString() {
    this._ensureindentStr();
    return this.indentStr === null ? "	" : this.indentStr;
  }
  indent(indentStr, options) {
    const pattern = /^[^\r\n]/gm;
    if (isObject(indentStr)) {
      options = indentStr;
      indentStr = void 0;
    }
    if (indentStr === void 0) {
      this._ensureindentStr();
      indentStr = this.indentStr || "	";
    }
    if (indentStr === "")
      return this;
    options = options || {};
    const isExcluded = {};
    if (options.exclude) {
      const exclusions = typeof options.exclude[0] === "number" ? [options.exclude] : options.exclude;
      exclusions.forEach((exclusion) => {
        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
          isExcluded[i] = true;
        }
      });
    }
    let shouldIndentNextCharacter = options.indentStart !== false;
    const replacer = (match) => {
      if (shouldIndentNextCharacter)
        return `${indentStr}${match}`;
      shouldIndentNextCharacter = true;
      return match;
    };
    this.intro = this.intro.replace(pattern, replacer);
    let charIndex = 0;
    let chunk = this.firstChunk;
    while (chunk) {
      const end = chunk.end;
      if (chunk.edited) {
        if (!isExcluded[charIndex]) {
          chunk.content = chunk.content.replace(pattern, replacer);
          if (chunk.content.length) {
            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
          }
        }
      } else {
        charIndex = chunk.start;
        while (charIndex < end) {
          if (!isExcluded[charIndex]) {
            const char = this.original[charIndex];
            if (char === "\n") {
              shouldIndentNextCharacter = true;
            } else if (char !== "\r" && shouldIndentNextCharacter) {
              shouldIndentNextCharacter = false;
              if (charIndex === chunk.start) {
                chunk.prependRight(indentStr);
              } else {
                this._splitChunk(chunk, charIndex);
                chunk = chunk.next;
                chunk.prependRight(indentStr);
              }
            }
          }
          charIndex += 1;
        }
      }
      charIndex = chunk.end;
      chunk = chunk.next;
    }
    this.outro = this.outro.replace(pattern, replacer);
    return this;
  }
  insert() {
    throw new Error(
      "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
    );
  }
  insertLeft(index, content) {
    if (!warned.insertLeft) {
      console.warn(
        "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
      );
      warned.insertLeft = true;
    }
    return this.appendLeft(index, content);
  }
  insertRight(index, content) {
    if (!warned.insertRight) {
      console.warn(
        "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
      );
      warned.insertRight = true;
    }
    return this.prependRight(index, content);
  }
  move(start, end, index) {
    if (index >= start && index <= end)
      throw new Error("Cannot move a selection inside itself");
    this._split(start);
    this._split(end);
    this._split(index);
    const first = this.byStart[start];
    const last = this.byEnd[end];
    const oldLeft = first.previous;
    const oldRight = last.next;
    const newRight = this.byStart[index];
    if (!newRight && last === this.lastChunk)
      return this;
    const newLeft = newRight ? newRight.previous : this.lastChunk;
    if (oldLeft)
      oldLeft.next = oldRight;
    if (oldRight)
      oldRight.previous = oldLeft;
    if (newLeft)
      newLeft.next = first;
    if (newRight)
      newRight.previous = last;
    if (!first.previous)
      this.firstChunk = last.next;
    if (!last.next) {
      this.lastChunk = first.previous;
      this.lastChunk.next = null;
    }
    first.previous = newLeft;
    last.next = newRight || null;
    if (!newLeft)
      this.firstChunk = first;
    if (!newRight)
      this.lastChunk = last;
    return this;
  }
  overwrite(start, end, content, options) {
    options = options || {};
    return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });
  }
  update(start, end, content, options) {
    if (typeof content !== "string")
      throw new TypeError("replacement content must be a string");
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (end > this.original.length)
      throw new Error("end is out of bounds");
    if (start === end)
      throw new Error(
        "Cannot overwrite a zero-length range – use appendLeft or prependRight instead"
      );
    this._split(start);
    this._split(end);
    if (options === true) {
      if (!warned.storeName) {
        console.warn(
          "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
        );
        warned.storeName = true;
      }
      options = { storeName: true };
    }
    const storeName = options !== void 0 ? options.storeName : false;
    const overwrite = options !== void 0 ? options.overwrite : false;
    if (storeName) {
      const original = this.original.slice(start, end);
      Object.defineProperty(this.storedNames, original, {
        writable: true,
        value: true,
        enumerable: true
      });
    }
    const first = this.byStart[start];
    const last = this.byEnd[end];
    if (first) {
      let chunk = first;
      while (chunk !== last) {
        if (chunk.next !== this.byStart[chunk.end]) {
          throw new Error("Cannot overwrite across a split point");
        }
        chunk = chunk.next;
        chunk.edit("", false);
      }
      first.edit(content, storeName, !overwrite);
    } else {
      const newChunk = new Chunk(start, end, "").edit(content, storeName);
      last.next = newChunk;
      newChunk.previous = last;
    }
    return this;
  }
  prepend(content) {
    if (typeof content !== "string")
      throw new TypeError("outro content must be a string");
    this.intro = content + this.intro;
    return this;
  }
  prependLeft(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.prependLeft(content);
    } else {
      this.intro = content + this.intro;
    }
    return this;
  }
  prependRight(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.prependRight(content);
    } else {
      this.outro = content + this.outro;
    }
    return this;
  }
  remove(start, end) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (start === end)
      return this;
    if (start < 0 || end > this.original.length)
      throw new Error("Character is out of bounds");
    if (start > end)
      throw new Error("end must be greater than start");
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.intro = "";
      chunk.outro = "";
      chunk.edit("");
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  reset(start, end) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (start === end)
      return this;
    if (start < 0 || end > this.original.length)
      throw new Error("Character is out of bounds");
    if (start > end)
      throw new Error("end must be greater than start");
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.reset();
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  lastChar() {
    if (this.outro.length)
      return this.outro[this.outro.length - 1];
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length)
        return chunk.outro[chunk.outro.length - 1];
      if (chunk.content.length)
        return chunk.content[chunk.content.length - 1];
      if (chunk.intro.length)
        return chunk.intro[chunk.intro.length - 1];
    } while (chunk = chunk.previous);
    if (this.intro.length)
      return this.intro[this.intro.length - 1];
    return "";
  }
  lastLine() {
    let lineIndex = this.outro.lastIndexOf(n);
    if (lineIndex !== -1)
      return this.outro.substr(lineIndex + 1);
    let lineStr = this.outro;
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length > 0) {
        lineIndex = chunk.outro.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.outro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.outro + lineStr;
      }
      if (chunk.content.length > 0) {
        lineIndex = chunk.content.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.content.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.content + lineStr;
      }
      if (chunk.intro.length > 0) {
        lineIndex = chunk.intro.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.intro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.intro + lineStr;
      }
    } while (chunk = chunk.previous);
    lineIndex = this.intro.lastIndexOf(n);
    if (lineIndex !== -1)
      return this.intro.substr(lineIndex + 1) + lineStr;
    return this.intro + lineStr;
  }
  slice(start = 0, end = this.original.length) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    let result = "";
    let chunk = this.firstChunk;
    while (chunk && (chunk.start > start || chunk.end <= start)) {
      if (chunk.start < end && chunk.end >= end) {
        return result;
      }
      chunk = chunk.next;
    }
    if (chunk && chunk.edited && chunk.start !== start)
      throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
    const startChunk = chunk;
    while (chunk) {
      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
        result += chunk.intro;
      }
      const containsEnd = chunk.start < end && chunk.end >= end;
      if (containsEnd && chunk.edited && chunk.end !== end)
        throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
      const sliceStart = startChunk === chunk ? start - chunk.start : 0;
      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
      result += chunk.content.slice(sliceStart, sliceEnd);
      if (chunk.outro && (!containsEnd || chunk.end === end)) {
        result += chunk.outro;
      }
      if (containsEnd) {
        break;
      }
      chunk = chunk.next;
    }
    return result;
  }
  // TODO deprecate this? not really very useful
  snip(start, end) {
    const clone3 = this.clone();
    clone3.remove(0, start);
    clone3.remove(end, clone3.original.length);
    return clone3;
  }
  _split(index) {
    if (this.byStart[index] || this.byEnd[index])
      return;
    let chunk = this.lastSearchedChunk;
    const searchForward = index > chunk.end;
    while (chunk) {
      if (chunk.contains(index))
        return this._splitChunk(chunk, index);
      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
    }
  }
  _splitChunk(chunk, index) {
    if (chunk.edited && chunk.content.length) {
      const loc = getLocator2(this.original)(index);
      throw new Error(
        `Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – "${chunk.original}")`
      );
    }
    const newChunk = chunk.split(index);
    this.byEnd[index] = chunk;
    this.byStart[index] = newChunk;
    this.byEnd[newChunk.end] = newChunk;
    if (chunk === this.lastChunk)
      this.lastChunk = newChunk;
    this.lastSearchedChunk = chunk;
    return true;
  }
  toString() {
    let str = this.intro;
    let chunk = this.firstChunk;
    while (chunk) {
      str += chunk.toString();
      chunk = chunk.next;
    }
    return str + this.outro;
  }
  isEmpty() {
    let chunk = this.firstChunk;
    do {
      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())
        return false;
    } while (chunk = chunk.next);
    return true;
  }
  length() {
    let chunk = this.firstChunk;
    let length2 = 0;
    do {
      length2 += chunk.intro.length + chunk.content.length + chunk.outro.length;
    } while (chunk = chunk.next);
    return length2;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(charType) {
    return this.trimStart(charType).trimEnd(charType);
  }
  trimEndAborted(charType) {
    const rx = new RegExp((charType || "\\s") + "+$");
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length)
      return true;
    let chunk = this.lastChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimEnd(rx);
      if (chunk.end !== end) {
        if (this.lastChunk === chunk) {
          this.lastChunk = chunk.next;
        }
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted)
        return true;
      chunk = chunk.previous;
    } while (chunk);
    return false;
  }
  trimEnd(charType) {
    this.trimEndAborted(charType);
    return this;
  }
  trimStartAborted(charType) {
    const rx = new RegExp("^" + (charType || "\\s") + "+");
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length)
      return true;
    let chunk = this.firstChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimStart(rx);
      if (chunk.end !== end) {
        if (chunk === this.lastChunk)
          this.lastChunk = chunk.next;
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted)
        return true;
      chunk = chunk.next;
    } while (chunk);
    return false;
  }
  trimStart(charType) {
    this.trimStartAborted(charType);
    return this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(searchValue, replacement) {
    function getReplacement(match, str) {
      if (typeof replacement === "string") {
        return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
          if (i === "$")
            return "$";
          if (i === "&")
            return match[0];
          const num = +i;
          if (num < match.length)
            return match[+i];
          return `$${i}`;
        });
      } else {
        return replacement(...match, match.index, str, match.groups);
      }
    }
    function matchAll(re2, str) {
      let match;
      const matches = [];
      while (match = re2.exec(str)) {
        matches.push(match);
      }
      return matches;
    }
    if (searchValue.global) {
      const matches = matchAll(searchValue, this.original);
      matches.forEach((match) => {
        if (match.index != null) {
          const replacement2 = getReplacement(match, this.original);
          if (replacement2 !== match[0]) {
            this.overwrite(
              match.index,
              match.index + match[0].length,
              replacement2
            );
          }
        }
      });
    } else {
      const match = this.original.match(searchValue);
      if (match && match.index != null) {
        const replacement2 = getReplacement(match, this.original);
        if (replacement2 !== match[0]) {
          this.overwrite(
            match.index,
            match.index + match[0].length,
            replacement2
          );
        }
      }
    }
    return this;
  }
  _replaceString(string, replacement) {
    const { original } = this;
    const index = original.indexOf(string);
    if (index !== -1) {
      this.overwrite(index, index + string.length, replacement);
    }
    return this;
  }
  replace(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceString(searchValue, replacement);
    }
    return this._replaceRegexp(searchValue, replacement);
  }
  _replaceAllString(string, replacement) {
    const { original } = this;
    const stringLength = string.length;
    for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) {
      const previous = original.slice(index, index + stringLength);
      if (previous !== replacement)
        this.overwrite(index, index + stringLength, replacement);
    }
    return this;
  }
  replaceAll(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceAllString(searchValue, replacement);
    }
    if (!searchValue.global) {
      throw new TypeError(
        "MagicString.prototype.replaceAll called with a non-global RegExp argument"
      );
    }
    return this._replaceRegexp(searchValue, replacement);
  }
};

// node_modules/svelte/src/compiler/compile/css/gather_possible_values.js
var UNKNOWN = {};
function gather_possible_values(node, set) {
  if (node.type === "Literal") {
    set.add(node.value);
  } else if (node.type === "ConditionalExpression") {
    gather_possible_values(node.consequent, set);
    gather_possible_values(node.alternate, set);
  } else {
    set.add(UNKNOWN);
  }
}

// node_modules/svelte/src/compiler/compile/css/Selector.js
var BlockAppliesToNode = (
  /** @type {const} */
  {
    NotPossible: 0,
    Possible: 1,
    UnknownSelectorType: 2
  }
);
var NodeExist = (
  /** @type {const} */
  {
    Probably: 0,
    Definitely: 1
  }
);
var whitelist_attribute_selector = /* @__PURE__ */ new Map([
  ["details", /* @__PURE__ */ new Set(["open"])],
  ["dialog", /* @__PURE__ */ new Set(["open"])]
]);
var regex_is_single_css_selector = /[^\\],(?!([^([]+[^\\]|[^([\\])[)\]])/;
var Selector = class {
  /**
   * @param {import('./private.js').CssNode} node
   * @param {import('./Stylesheet.js').default} stylesheet
   */
  constructor(node, stylesheet) {
    /** @type {import('./private.js').CssNode} */
    __publicField(this, "node");
    /** @type {import('./Stylesheet.js').default} */
    __publicField(this, "stylesheet");
    /** @type {Block[]} */
    __publicField(this, "blocks");
    /** @type {Block[]} */
    __publicField(this, "local_blocks");
    /** @type {boolean} */
    __publicField(this, "used");
    this.node = node;
    this.stylesheet = stylesheet;
    this.blocks = group_selectors(node);
    let i = this.blocks.length;
    while (i > 0) {
      if (!this.blocks[i - 1].global)
        break;
      i -= 1;
    }
    this.local_blocks = this.blocks.slice(0, i);
    const host_only = this.blocks.length === 1 && this.blocks[0].host;
    const root_only = this.blocks.length === 1 && this.blocks[0].root;
    this.used = this.local_blocks.length === 0 || host_only || root_only;
  }
  /** @param {import('../nodes/Element.js').default} node */
  apply(node) {
    const to_encapsulate = [];
    apply_selector(this.local_blocks.slice(), node, to_encapsulate);
    if (to_encapsulate.length > 0) {
      to_encapsulate.forEach(({ node: node2, block }) => {
        this.stylesheet.nodes_with_css_class.add(node2);
        block.should_encapsulate = true;
      });
      this.used = true;
    }
  }
  /** @param {import('magic-string').default} code */
  minify(code2) {
    let c2 = null;
    this.blocks.forEach((block, i) => {
      if (i > 0) {
        if (block.start - c2 > 1) {
          code2.update(c2, block.start, block.combinator.name || " ");
        }
      }
      c2 = block.end;
    });
  }
  /**
   * @param {import('magic-string').default} code
   * @param {string} attr
   * @param {number} max_amount_class_specificity_increased
   */
  transform(code2, attr, max_amount_class_specificity_increased) {
    const amount_class_specificity_to_increase = max_amount_class_specificity_increased - this.blocks.filter((block) => block.should_encapsulate).length;
    function remove_global_pseudo_class(selector2) {
      const first = selector2.children[0];
      const last = selector2.children[selector2.children.length - 1];
      code2.remove(selector2.start, first.start).remove(last.end, selector2.end);
    }
    function encapsulate_block(block, attr2) {
      for (const selector2 of block.selectors) {
        if (selector2.type === "PseudoClassSelector" && selector2.name === "global") {
          remove_global_pseudo_class(selector2);
        }
      }
      let i = block.selectors.length;
      while (i--) {
        const selector2 = block.selectors[i];
        if (selector2.type === "PseudoElementSelector" || selector2.type === "PseudoClassSelector") {
          if (selector2.name !== "root" && selector2.name !== "host") {
            if (i === 0)
              code2.prependRight(selector2.start, attr2);
          }
          continue;
        }
        if (selector2.type === "TypeSelector" && selector2.name === "*") {
          code2.update(selector2.start, selector2.end, attr2);
        } else {
          code2.appendLeft(selector2.end, attr2);
        }
        break;
      }
    }
    this.blocks.forEach((block, index) => {
      if (block.global) {
        remove_global_pseudo_class(block.selectors[0]);
      }
      if (block.should_encapsulate)
        encapsulate_block(
          block,
          index === this.blocks.length - 1 ? attr.repeat(amount_class_specificity_to_increase + 1) : attr
        );
    });
  }
  /** @param {import('../Component.js').default} component */
  validate(component) {
    let start = 0;
    let end = this.blocks.length;
    for (; start < end; start += 1) {
      if (!this.blocks[start].global)
        break;
    }
    for (; end > start; end -= 1) {
      if (!this.blocks[end - 1].global)
        break;
    }
    for (let i = start; i < end; i += 1) {
      if (this.blocks[i].global) {
        return component.error(this.blocks[i].selectors[0], compiler_errors_default.css_invalid_global);
      }
    }
    this.validate_global_with_multiple_selectors(component);
    this.validate_global_compound_selector(component);
    this.validate_invalid_combinator_without_selector(component);
  }
  /** @param {import('../Component.js').default} component */
  validate_global_with_multiple_selectors(component) {
    if (this.blocks.length === 1 && this.blocks[0].selectors.length === 1) {
      return;
    }
    for (const block of this.blocks) {
      for (const selector2 of block.selectors) {
        if (selector2.type === "PseudoClassSelector" && selector2.name === "global") {
          if (regex_is_single_css_selector.test(selector2.children[0].value)) {
            component.error(selector2, compiler_errors_default.css_invalid_global_selector);
          }
        }
      }
    }
  }
  /** @param {import('../Component.js').default} component */
  validate_invalid_combinator_without_selector(component) {
    for (let i = 0; i < this.blocks.length; i++) {
      const block = this.blocks[i];
      if (block.combinator && block.selectors.length === 0) {
        component.error(
          this.node,
          compiler_errors_default.css_invalid_selector(
            component.source.slice(this.node.start, this.node.end)
          )
        );
      }
      if (!block.combinator && block.selectors.length === 0) {
        component.error(
          this.node,
          compiler_errors_default.css_invalid_selector(
            component.source.slice(this.node.start, this.node.end)
          )
        );
      }
    }
  }
  /** @param {import('../Component.js').default} component */
  validate_global_compound_selector(component) {
    for (const block of this.blocks) {
      for (let index = 0; index < block.selectors.length; index++) {
        const selector2 = block.selectors[index];
        if (selector2.type === "PseudoClassSelector" && selector2.name === "global" && index !== 0 && selector2.children && selector2.children.length > 0 && !/[.:#[\s]/.test(selector2.children[0].value[0])) {
          component.error(selector2, compiler_errors_default.css_invalid_global_selector_position);
        }
      }
    }
  }
  get_amount_class_specificity_increased() {
    let count = 0;
    for (const block of this.blocks) {
      if (block.should_encapsulate) {
        count++;
      }
    }
    return count;
  }
};
function apply_selector(blocks, node, to_encapsulate) {
  const block = blocks.pop();
  if (!block)
    return false;
  if (!node) {
    return block.global && blocks.every((block2) => block2.global) || block.host && blocks.length === 0;
  }
  switch (block_might_apply_to_node(block, node)) {
    case BlockAppliesToNode.NotPossible:
      return false;
    case BlockAppliesToNode.UnknownSelectorType:
      to_encapsulate.push({ node, block });
      return true;
  }
  if (block.combinator) {
    if (block.combinator.type === "Combinator" && block.combinator.name === " ") {
      for (const ancestor_block of blocks) {
        if (ancestor_block.global) {
          continue;
        }
        if (ancestor_block.host) {
          to_encapsulate.push({ node, block });
          return true;
        }
        let parent = node;
        while (parent = get_element_parent(parent)) {
          if (block_might_apply_to_node(ancestor_block, parent) !== BlockAppliesToNode.NotPossible) {
            to_encapsulate.push({ node: parent, block: ancestor_block });
          }
        }
        if (to_encapsulate.length) {
          to_encapsulate.push({ node, block });
          return true;
        }
      }
      if (blocks.every((block2) => block2.global)) {
        to_encapsulate.push({ node, block });
        return true;
      }
      return false;
    } else if (block.combinator.name === ">") {
      const has_global_parent = blocks.every((block2) => block2.global);
      if (has_global_parent || apply_selector(blocks, get_element_parent(node), to_encapsulate)) {
        to_encapsulate.push({ node, block });
        return true;
      }
      return false;
    } else if (block.combinator.name === "+" || block.combinator.name === "~") {
      const [siblings, has_slot_sibling] = get_possible_element_siblings(
        node,
        block.combinator.name === "+"
      );
      let has_match = false;
      const has_global = blocks.some((block2) => block2.global);
      if (has_global) {
        if (siblings.size === 0 && get_element_parent(node) !== null && !has_slot_sibling) {
          return false;
        }
        to_encapsulate.push({ node, block });
        return true;
      }
      for (const possible_sibling of siblings.keys()) {
        if (apply_selector(blocks.slice(), possible_sibling, to_encapsulate)) {
          to_encapsulate.push({ node, block });
          has_match = true;
        }
      }
      return has_match;
    }
    to_encapsulate.push({ node, block });
    return true;
  }
  to_encapsulate.push({ node, block });
  return true;
}
var regex_backslash_and_following_character = /\\(.)/g;
function block_might_apply_to_node(block, node) {
  let i = block.selectors.length;
  while (i--) {
    const selector2 = block.selectors[i];
    const name49 = typeof selector2.name === "string" && selector2.name.replace(regex_backslash_and_following_character, "$1");
    if (selector2.type === "PseudoClassSelector" && (name49 === "host" || name49 === "root")) {
      return BlockAppliesToNode.NotPossible;
    }
    if (block.selectors.length === 1 && selector2.type === "PseudoClassSelector" && name49 === "global") {
      return BlockAppliesToNode.NotPossible;
    }
    if (selector2.type === "PseudoClassSelector" || selector2.type === "PseudoElementSelector") {
      continue;
    }
    if (selector2.type === "ClassSelector") {
      if (!attribute_matches(node, "class", name49, "~=", false) && !node.classes.some((c2) => c2.name === name49))
        return BlockAppliesToNode.NotPossible;
    } else if (selector2.type === "IdSelector") {
      if (!attribute_matches(node, "id", name49, "=", false))
        return BlockAppliesToNode.NotPossible;
    } else if (selector2.type === "AttributeSelector") {
      if (!(whitelist_attribute_selector.has(node.name.toLowerCase()) && whitelist_attribute_selector.get(node.name.toLowerCase()).has(selector2.name.name.toLowerCase())) && !attribute_matches(
        node,
        selector2.name.name,
        selector2.value && unquote(selector2.value),
        selector2.matcher,
        selector2.flags
      )) {
        return BlockAppliesToNode.NotPossible;
      }
    } else if (selector2.type === "TypeSelector") {
      if (node.name.toLowerCase() !== name49.toLowerCase() && name49 !== "*" && !node.is_dynamic_element)
        return BlockAppliesToNode.NotPossible;
    } else {
      return BlockAppliesToNode.UnknownSelectorType;
    }
  }
  return BlockAppliesToNode.Possible;
}
function test_attribute(operator, expected_value, case_insensitive, value) {
  if (case_insensitive) {
    expected_value = expected_value.toLowerCase();
    value = value.toLowerCase();
  }
  switch (operator) {
    case "=":
      return value === expected_value;
    case "~=":
      return value.split(/\s/).includes(expected_value);
    case "|=":
      return `${value}-`.startsWith(`${expected_value}-`);
    case "^=":
      return value.startsWith(expected_value);
    case "$=":
      return value.endsWith(expected_value);
    case "*=":
      return value.includes(expected_value);
    default:
      throw new Error("this shouldn't happen");
  }
}
function attribute_matches(node, name49, expected_value, operator, case_insensitive) {
  const spread = node.attributes.find((attr2) => attr2.type === "Spread");
  if (spread)
    return true;
  if (node.bindings.some((binding) => binding.name === name49))
    return true;
  const attr = node.attributes.find((attr2) => attr2.name === name49);
  if (!attr)
    return false;
  if (attr.is_true)
    return operator === null;
  if (expected_value == null)
    return true;
  if (attr.chunks.length === 1) {
    const value = attr.chunks[0];
    if (!value)
      return false;
    if (value.type === "Text")
      return test_attribute(operator, expected_value, case_insensitive, value.data);
  }
  const possible_values = /* @__PURE__ */ new Set();
  let prev_values = [];
  for (const chunk of attr.chunks) {
    const current_possible_values = /* @__PURE__ */ new Set();
    if (chunk.type === "Text") {
      current_possible_values.add(chunk.data);
    } else {
      gather_possible_values(chunk.node, current_possible_values);
    }
    if (current_possible_values.has(UNKNOWN))
      return true;
    if (prev_values.length > 0) {
      const start_with_space = [];
      const remaining = [];
      current_possible_values.forEach((current_possible_value) => {
        if (regex_starts_with_whitespace.test(current_possible_value)) {
          start_with_space.push(current_possible_value);
        } else {
          remaining.push(current_possible_value);
        }
      });
      if (remaining.length > 0) {
        if (start_with_space.length > 0) {
          prev_values.forEach((prev_value) => possible_values.add(prev_value));
        }
        const combined = [];
        prev_values.forEach((prev_value) => {
          remaining.forEach((value) => {
            combined.push(prev_value + value);
          });
        });
        prev_values = combined;
        start_with_space.forEach((value) => {
          if (regex_ends_with_whitespace.test(value)) {
            possible_values.add(value);
          } else {
            prev_values.push(value);
          }
        });
        continue;
      } else {
        prev_values.forEach((prev_value) => possible_values.add(prev_value));
        prev_values = [];
      }
    }
    current_possible_values.forEach((current_possible_value) => {
      if (regex_ends_with_whitespace.test(current_possible_value)) {
        possible_values.add(current_possible_value);
      } else {
        prev_values.push(current_possible_value);
      }
    });
    if (prev_values.length < current_possible_values.size) {
      prev_values.push(" ");
    }
    if (prev_values.length > 20) {
      return true;
    }
  }
  prev_values.forEach((prev_value) => possible_values.add(prev_value));
  if (possible_values.has(UNKNOWN))
    return true;
  for (const value of possible_values) {
    if (test_attribute(operator, expected_value, case_insensitive, value))
      return true;
  }
  return false;
}
function unquote(value) {
  if (value.type === "Identifier")
    return value.name;
  const str = value.value;
  if (str[0] === str[str.length - 1] && str[0] === "'" || str[0] === '"') {
    return str.slice(1, str.length - 1);
  }
  return str;
}
function get_element_parent(node) {
  let parent = node;
  while ((parent = parent.parent) && parent.type !== "Element")
    ;
  return (
    /** @type {import('../nodes/Element.js').default | null} */
    parent
  );
}
function find_previous_sibling(node) {
  let current_node = node;
  let has_slot_sibling = false;
  do {
    if (current_node.type === "Slot") {
      has_slot_sibling = true;
      const slot_children = current_node.children;
      if (slot_children.length > 0) {
        current_node = slot_children.slice(-1)[0];
        continue;
      }
    }
    while (!current_node.prev && current_node.parent && current_node.parent.type === "Slot") {
      current_node = current_node.parent;
    }
    current_node = current_node.prev;
  } while (current_node && current_node.type === "Slot");
  return [current_node, has_slot_sibling];
}
function get_possible_element_siblings(node, adjacent_only) {
  const result = /* @__PURE__ */ new Map();
  let prev = node;
  let has_slot_sibling = false;
  let slot_sibling_found = false;
  while (([prev, slot_sibling_found] = find_previous_sibling(prev)) && prev) {
    has_slot_sibling = has_slot_sibling || slot_sibling_found;
    if (prev.type === "Element") {
      if (!prev.attributes.find(
        (attr) => attr.type === "Attribute" && attr.name.toLowerCase() === "slot"
      )) {
        result.set(prev, NodeExist.Definitely);
      }
      if (adjacent_only) {
        break;
      }
    } else if (prev.type === "EachBlock" || prev.type === "IfBlock" || prev.type === "AwaitBlock") {
      const possible_last_child = get_possible_last_child(prev, adjacent_only);
      add_to_map(possible_last_child, result);
      if (adjacent_only && has_definite_elements(possible_last_child)) {
        return [result, has_slot_sibling];
      }
    }
  }
  if (!prev || !adjacent_only) {
    let parent = node;
    let skip_each_for_last_child = node.type === "ElseBlock";
    while ((parent = parent.parent) && (parent.type === "EachBlock" || parent.type === "IfBlock" || parent.type === "ElseBlock" || parent.type === "AwaitBlock")) {
      const [possible_siblings, slot_sibling_found2] = get_possible_element_siblings(
        parent,
        adjacent_only
      );
      has_slot_sibling = has_slot_sibling || slot_sibling_found2;
      add_to_map(possible_siblings, result);
      if (parent.type === "EachBlock") {
        if (skip_each_for_last_child) {
          skip_each_for_last_child = false;
        } else {
          add_to_map(get_possible_last_child(parent, adjacent_only), result);
        }
      } else if (parent.type === "ElseBlock") {
        skip_each_for_last_child = true;
        parent = parent.parent;
      }
      if (adjacent_only && has_definite_elements(possible_siblings)) {
        break;
      }
    }
  }
  return [result, has_slot_sibling];
}
function get_possible_last_child(block, adjacent_only) {
  const result = /* @__PURE__ */ new Map();
  if (block.type === "EachBlock") {
    const each_result = loop_child(block.children, adjacent_only);
    const else_result = block.else ? loop_child(block.else.children, adjacent_only) : /* @__PURE__ */ new Map();
    const not_exhaustive = !has_definite_elements(else_result);
    if (not_exhaustive) {
      mark_as_probably(each_result);
      mark_as_probably(else_result);
    }
    add_to_map(each_result, result);
    add_to_map(else_result, result);
  } else if (block.type === "IfBlock") {
    const if_result = loop_child(block.children, adjacent_only);
    const else_result = block.else ? loop_child(block.else.children, adjacent_only) : /* @__PURE__ */ new Map();
    const not_exhaustive = !has_definite_elements(if_result) || !has_definite_elements(else_result);
    if (not_exhaustive) {
      mark_as_probably(if_result);
      mark_as_probably(else_result);
    }
    add_to_map(if_result, result);
    add_to_map(else_result, result);
  } else if (block.type === "AwaitBlock") {
    const pending_result = block.pending ? loop_child(block.pending.children, adjacent_only) : /* @__PURE__ */ new Map();
    const then_result = block.then ? loop_child(block.then.children, adjacent_only) : /* @__PURE__ */ new Map();
    const catch_result = block.catch ? loop_child(block.catch.children, adjacent_only) : /* @__PURE__ */ new Map();
    const not_exhaustive = !has_definite_elements(pending_result) || !has_definite_elements(then_result) || !has_definite_elements(catch_result);
    if (not_exhaustive) {
      mark_as_probably(pending_result);
      mark_as_probably(then_result);
      mark_as_probably(catch_result);
    }
    add_to_map(pending_result, result);
    add_to_map(then_result, result);
    add_to_map(catch_result, result);
  }
  return result;
}
function has_definite_elements(result) {
  if (result.size === 0)
    return false;
  for (const exist of result.values()) {
    if (exist === NodeExist.Definitely) {
      return true;
    }
  }
  return false;
}
function add_to_map(from, to) {
  from.forEach((exist, element) => {
    to.set(element, higher_existence(exist, to.get(element)));
  });
}
function higher_existence(exist1, exist2) {
  if (exist1 === void 0 || exist2 === void 0)
    return exist1 || exist2;
  return exist1 > exist2 ? exist1 : exist2;
}
function mark_as_probably(result) {
  for (const key of result.keys()) {
    result.set(key, NodeExist.Probably);
  }
}
function loop_child(children, adjacent_only) {
  const result = /* @__PURE__ */ new Map();
  for (let i = children.length - 1; i >= 0; i--) {
    const child = children[i];
    if (child.type === "Element") {
      result.set(child, NodeExist.Definitely);
      if (adjacent_only) {
        break;
      }
    } else if (child.type === "EachBlock" || child.type === "IfBlock" || child.type === "AwaitBlock") {
      const child_result = get_possible_last_child(child, adjacent_only);
      add_to_map(child_result, result);
      if (adjacent_only && has_definite_elements(child_result)) {
        break;
      }
    }
  }
  return result;
}
var Block2 = class {
  /** @param {import('./private.js').CssNode} combinator */
  constructor(combinator) {
    /** @type {boolean} */
    __publicField(this, "host");
    /** @type {boolean} */
    __publicField(this, "root");
    /** @type {import('./private.js').CssNode} */
    __publicField(this, "combinator");
    /** @type {import('./private.js').CssNode[]} */
    __publicField(this, "selectors");
    /** @type {number} */
    __publicField(this, "start");
    /** @type {number} */
    __publicField(this, "end");
    /** @type {boolean} */
    __publicField(this, "should_encapsulate");
    this.combinator = combinator;
    this.host = false;
    this.root = false;
    this.selectors = [];
    this.start = null;
    this.end = null;
    this.should_encapsulate = false;
  }
  /** @param {import('./private.js').CssNode} selector */
  add(selector2) {
    if (this.selectors.length === 0) {
      this.start = selector2.start;
      this.host = selector2.type === "PseudoClassSelector" && selector2.name === "host";
    }
    this.root = this.root || selector2.type === "PseudoClassSelector" && selector2.name === "root";
    this.selectors.push(selector2);
    this.end = selector2.end;
  }
  get global() {
    return this.selectors.length >= 1 && this.selectors[0].type === "PseudoClassSelector" && this.selectors[0].name === "global" && this.selectors.every(
      (selector2) => selector2.type === "PseudoClassSelector" || selector2.type === "PseudoElementSelector"
    );
  }
};
function group_selectors(selector2) {
  let block = new Block2(null);
  const blocks = [block];
  selector2.children.forEach((child) => {
    if (child.type === "WhiteSpace" || child.type === "Combinator") {
      block = new Block2(child);
      blocks.push(block);
    } else {
      block.add(child);
    }
  });
  return blocks;
}

// node_modules/svelte/src/compiler/compile/css/Stylesheet.js
var regex_css_browser_prefix = /^-((webkit)|(moz)|(o)|(ms))-/;
function remove_css_prefix(name49) {
  return name49.replace(regex_css_browser_prefix, "");
}
var is_keyframes_node = (node) => remove_css_prefix(node.name) === "keyframes";
var at_rule_has_declaration = ({ block }) => block && block.children && block.children.find((node) => node.type === "Declaration");
function minify_declarations(code2, start, declarations) {
  let c2 = start;
  declarations.forEach((declaration, i) => {
    const separator = i > 0 ? ";" : "";
    if (declaration.node.start - c2 > separator.length) {
      code2.update(c2, declaration.node.start, separator);
    }
    declaration.minify(code2);
    c2 = declaration.node.end;
  });
  return c2;
}
var Rule = class {
  /**
   * @param {import('./private.js').CssNode} node
   * @param {any} stylesheet
   * @param {Atrule} [parent]
   */
  constructor(node, stylesheet, parent) {
    /** @type {import('./Selector.js').default[]} */
    __publicField(this, "selectors");
    /** @type {Declaration[]} */
    __publicField(this, "declarations");
    /** @type {import('./private.js').CssNode} */
    __publicField(this, "node");
    /** @type {Atrule} */
    __publicField(this, "parent");
    this.node = node;
    this.parent = parent;
    this.selectors = node.prelude.children.map((node2) => new Selector(node2, stylesheet));
    this.declarations = node.block.children.map((node2) => new Declaration(node2));
  }
  /** @param {import('../nodes/Element.js').default} node */
  apply(node) {
    this.selectors.forEach((selector2) => selector2.apply(node));
  }
  /** @param {boolean} dev */
  is_used(dev) {
    if (this.parent && this.parent.node.type === "Atrule" && is_keyframes_node(this.parent.node))
      return true;
    if (this.declarations.length === 0)
      return dev;
    return this.selectors.some((s) => s.used);
  }
  /**
   * @param {import('magic-string').default} code
   * @param {boolean} _dev
   */
  minify(code2, _dev) {
    let c2 = this.node.start;
    let started = false;
    this.selectors.forEach((selector2) => {
      if (selector2.used) {
        const separator = started ? "," : "";
        if (selector2.node.start - c2 > separator.length) {
          code2.update(c2, selector2.node.start, separator);
        }
        selector2.minify(code2);
        c2 = selector2.node.end;
        started = true;
      }
    });
    code2.remove(c2, this.node.block.start);
    c2 = this.node.block.start + 1;
    c2 = minify_declarations(code2, c2, this.declarations);
    code2.remove(c2, this.node.block.end - 1);
  }
  /**
   * @param {import('magic-string').default} code
   * @param {string} id
   * @param {Map<string, string>} keyframes
   * @param {number} max_amount_class_specificity_increased
   */
  transform(code2, id2, keyframes, max_amount_class_specificity_increased) {
    if (this.parent && this.parent.node.type === "Atrule" && is_keyframes_node(this.parent.node))
      return true;
    const attr = `.${id2}`;
    this.selectors.forEach(
      (selector2) => selector2.transform(code2, attr, max_amount_class_specificity_increased)
    );
    this.declarations.forEach((declaration) => declaration.transform(code2, keyframes));
  }
  /** @param {import('../Component.js').default} component */
  validate(component) {
    this.selectors.forEach((selector2) => {
      selector2.validate(component);
    });
  }
  /** @param {(selector: import('./Selector.js').default) => void} handler */
  warn_on_unused_selector(handler) {
    this.selectors.forEach((selector2) => {
      if (!selector2.used)
        handler(selector2);
    });
  }
  get_max_amount_class_specificity_increased() {
    return Math.max(
      ...this.selectors.map((selector2) => selector2.get_amount_class_specificity_increased())
    );
  }
};
var Declaration = class {
  /** @param {import('./private.js').CssNode} node */
  constructor(node) {
    /** @type {import('./private.js').CssNode} */
    __publicField(this, "node");
    this.node = node;
  }
  /**
   * @param {import('magic-string').default} code
   * @param {Map<string, string>} keyframes
   */
  transform(code2, keyframes) {
    const property2 = this.node.property && remove_css_prefix(this.node.property.toLowerCase());
    if (property2 === "animation" || property2 === "animation-name") {
      this.node.value.children.forEach((block) => {
        if (block.type === "Identifier") {
          const name49 = block.name;
          if (keyframes.has(name49)) {
            code2.update(block.start, block.end, keyframes.get(name49));
          }
        }
      });
    }
  }
  /** @param {import('magic-string').default} code */
  minify(code2) {
    if (!this.node.property)
      return;
    const c2 = this.node.start + this.node.property.length;
    const first = this.node.value.children ? this.node.value.children[0] : this.node.value;
    if (first.type === "Raw" && regex_only_whitespaces.test(first.value))
      return;
    let start = first.start;
    while (regex_whitespace.test(code2.original[start]))
      start += 1;
    if (start - c2 > 1) {
      code2.update(c2, start, ":");
    }
  }
};
var Atrule = class {
  /** @param {import('./private.js').CssNode} node */
  constructor(node) {
    /** @type {import('./private.js').CssNode} */
    __publicField(this, "node");
    /** @type {Array<Atrule | Rule>} */
    __publicField(this, "children");
    /** @type {Declaration[]} */
    __publicField(this, "declarations");
    this.node = node;
    this.children = [];
    this.declarations = [];
  }
  /** @param {import('../nodes/Element.js').default} node */
  apply(node) {
    if (this.node.name === "container" || this.node.name === "media" || this.node.name === "supports" || this.node.name === "layer") {
      this.children.forEach((child) => {
        child.apply(node);
      });
    } else if (is_keyframes_node(this.node)) {
      this.children.forEach((rule) => {
        rule.selectors.forEach((selector2) => {
          selector2.used = true;
        });
      });
    }
  }
  /** @param {boolean} _dev */
  is_used(_dev) {
    return true;
  }
  /**
   * @param {import('magic-string').default} code
   * @param {boolean} dev
   */
  minify(code2, dev) {
    if (this.node.name === "media") {
      const expression_char = code2.original[this.node.prelude.start];
      let c2 = this.node.start + (expression_char === "(" ? 6 : 7);
      if (this.node.prelude.start > c2)
        code2.remove(c2, this.node.prelude.start);
      this.node.prelude.children.forEach((query) => {
        c2 = query.end;
      });
      code2.remove(c2, this.node.block.start);
    } else if (this.node.name === "supports") {
      let c2 = this.node.start + 9;
      if (this.node.prelude.start - c2 > 1)
        code2.update(c2, this.node.prelude.start, " ");
      this.node.prelude.children.forEach((query) => {
        c2 = query.end;
      });
      code2.remove(c2, this.node.block.start);
    } else {
      let c2 = this.node.start + this.node.name.length + 1;
      if (this.node.prelude) {
        if (this.node.prelude.start - c2 > 1)
          code2.update(c2, this.node.prelude.start, " ");
        c2 = this.node.prelude.end;
      }
      if (this.node.block && this.node.block.start - c2 > 0) {
        code2.remove(c2, this.node.block.start);
      }
    }
    if (this.node.block) {
      let c2 = this.node.block.start + 1;
      if (this.declarations.length) {
        c2 = minify_declarations(code2, c2, this.declarations);
        if (this.children.length)
          c2++;
      }
      this.children.forEach((child) => {
        if (child.is_used(dev)) {
          code2.remove(c2, child.node.start);
          child.minify(code2, dev);
          c2 = child.node.end;
        }
      });
      code2.remove(c2, this.node.block.end - 1);
    }
  }
  /**
   * @param {import('magic-string').default} code
   * @param {string} id
   * @param {Map<string, string>} keyframes
   * @param {number} max_amount_class_specificity_increased
   */
  transform(code2, id2, keyframes, max_amount_class_specificity_increased) {
    if (is_keyframes_node(this.node)) {
      this.node.prelude.children.forEach(({ type, name: name49, start, end }) => {
        if (type === "Identifier") {
          if (name49.startsWith("-global-")) {
            code2.remove(start, start + 8);
            this.children.forEach((rule) => {
              rule.selectors.forEach((selector2) => {
                selector2.used = true;
              });
            });
          } else {
            code2.update(start, end, keyframes.get(name49));
          }
        }
      });
    }
    this.children.forEach((child) => {
      child.transform(code2, id2, keyframes, max_amount_class_specificity_increased);
    });
  }
  /** @param {import('../Component.js').default} component */
  validate(component) {
    this.children.forEach((child) => {
      child.validate(component);
    });
  }
  /** @param {(selector: import('./Selector.js').default) => void} handler */
  warn_on_unused_selector(handler) {
    if (this.node.name !== "media")
      return;
    this.children.forEach((child) => {
      child.warn_on_unused_selector(handler);
    });
  }
  get_max_amount_class_specificity_increased() {
    return Math.max(
      ...this.children.map((rule) => rule.get_max_amount_class_specificity_increased())
    );
  }
};
var get_default_css_hash = ({ css, hash: hash2 }) => {
  return `svelte-${hash2(css)}`;
};
var Stylesheet = class {
  /**
   * @param {{
   * 		source: string;
   * 		ast: import('../../interfaces.js').Ast;
   * 		filename: string | undefined;
   * 		component_name: string | undefined;
   * 		dev: boolean;
   * 		get_css_hash: import('../../interfaces.js').CssHashGetter;
   * 	}} params
   */
  constructor({ source, ast, component_name, filename, dev, get_css_hash = get_default_css_hash }) {
    /** @type {string} */
    __publicField(this, "source");
    /** @type {import('../../interfaces.js').Ast} */
    __publicField(this, "ast");
    /** @type {string} */
    __publicField(this, "filename");
    /** @type {boolean} */
    __publicField(this, "dev");
    /** @type {boolean} */
    __publicField(this, "has_styles");
    /** @type {string} */
    __publicField(this, "id");
    /** @type {Array<Rule | Atrule>} */
    __publicField(this, "children", []);
    /** @type {Map<string, string>} */
    __publicField(this, "keyframes", /* @__PURE__ */ new Map());
    /** @type {Set<import('./private.js').CssNode>} */
    __publicField(this, "nodes_with_css_class", /* @__PURE__ */ new Set());
    this.source = source;
    this.ast = ast;
    this.filename = filename;
    this.dev = dev;
    if (ast.css && ast.css.children.length) {
      this.id = get_css_hash({
        filename,
        name: component_name,
        css: ast.css.content.styles,
        hash
      });
      this.has_styles = true;
      const stack = [];
      let depth = 0;
      let current_atrule = null;
      walk(
        /** @type {any} */
        ast.css,
        {
          enter: (node) => {
            if (node.type === "Atrule") {
              const atrule = new Atrule(node);
              stack.push(atrule);
              if (current_atrule) {
                current_atrule.children.push(atrule);
              } else if (depth <= 1) {
                this.children.push(atrule);
              }
              if (is_keyframes_node(node)) {
                node.prelude.children.forEach((expression) => {
                  if (expression.type === "Identifier" && !expression.name.startsWith("-global-")) {
                    this.keyframes.set(expression.name, `${this.id}-${expression.name}`);
                  }
                });
              } else if (at_rule_has_declaration(node)) {
                const at_rule_declarations = node.block.children.filter((node2) => node2.type === "Declaration").map((node2) => new Declaration(node2));
                push_array2(atrule.declarations, at_rule_declarations);
              }
              current_atrule = atrule;
            }
            if (node.type === "Rule") {
              const rule = new Rule(node, this, current_atrule);
              if (current_atrule) {
                current_atrule.children.push(rule);
              } else if (depth <= 1) {
                this.children.push(rule);
              }
            }
            depth += 1;
          },
          leave: (node) => {
            if (node.type === "Atrule") {
              stack.pop();
              current_atrule = stack[stack.length - 1];
            }
            depth -= 1;
          }
        }
      );
    } else {
      this.has_styles = false;
    }
  }
  /** @param {import('../nodes/Element.js').default} node */
  apply(node) {
    if (!this.has_styles)
      return;
    for (let i = 0; i < this.children.length; i += 1) {
      const child = this.children[i];
      child.apply(node);
    }
  }
  reify() {
    this.nodes_with_css_class.forEach((node) => {
      node.add_css_class();
    });
  }
  /** @param {string} file */
  render(file) {
    if (!this.has_styles) {
      return { code: null, map: null };
    }
    const code2 = new MagicString(this.source);
    walk(
      /** @type {any} */
      this.ast.css,
      {
        enter: (node) => {
          code2.addSourcemapLocation(node.start);
          code2.addSourcemapLocation(node.end);
        }
      }
    );
    const max = Math.max(
      ...this.children.map((rule) => rule.get_max_amount_class_specificity_increased())
    );
    this.children.forEach((child) => {
      child.transform(code2, this.id, this.keyframes, max);
    });
    let c2 = 0;
    this.children.forEach((child) => {
      if (child.is_used(this.dev)) {
        code2.remove(c2, child.node.start);
        child.minify(code2, this.dev);
        c2 = child.node.end;
      }
    });
    code2.remove(c2, this.source.length);
    return {
      code: code2.toString(),
      map: code2.generateMap({
        includeContent: true,
        source: this.filename,
        file
      })
    };
  }
  /** @param {import('../Component.js').default} component */
  validate(component) {
    this.children.forEach((child) => {
      child.validate(component);
    });
  }
  /** @param {import('../Component.js').default} component */
  warn_on_unused_selectors(component) {
    const ignores = !this.ast.css ? [] : extract_ignores_above_position(this.ast.css.start, this.ast.html.children);
    component.push_ignores(ignores);
    this.children.forEach((child) => {
      child.warn_on_unused_selector((selector2) => {
        component.warn(
          selector2.node,
          compiler_warnings_default.css_unused_selector(
            this.source.slice(selector2.node.start, selector2.node.end)
          )
        );
      });
    });
    component.pop_ignores();
  }
};

// node_modules/svelte/src/compiler/compile/nodes/shared/TemplateScope.js
var TemplateScope = class _TemplateScope {
  /** @param {TemplateScope} [parent]  undefined */
  constructor(parent) {
    /**
     * @typedef {import('../EachBlock').default
     * 	| import('../ThenBlock').default
     * 	| import('../CatchBlock').default
     * 	| import('../InlineComponent').default
     * 	| import('../Element').default
     * 	| import('../SlotTemplate').default
     * 	| import('../ConstTag').default} NodeWithScope
     */
    /** @type {Set<string>} */
    __publicField(this, "names");
    /** @type {Map<string, Set<string>>} */
    __publicField(this, "dependencies_for_name");
    /** @type {Map<string, NodeWithScope>} */
    __publicField(this, "owners", /* @__PURE__ */ new Map());
    /** @type {TemplateScope} */
    __publicField(this, "parent");
    this.parent = parent;
    this.names = new Set(parent ? parent.names : []);
    this.dependencies_for_name = new Map(parent ? parent.dependencies_for_name : []);
  }
  /**
   * @param {any} name
   * @param {Set<string>} dependencies
   * @param {any} owner
   */
  add(name49, dependencies, owner) {
    this.names.add(name49);
    this.dependencies_for_name.set(name49, dependencies);
    this.owners.set(name49, owner);
    return this;
  }
  child() {
    const child = new _TemplateScope(this);
    return child;
  }
  /** @param {string} name */
  is_top_level(name49) {
    return !this.parent || !this.names.has(name49) && this.parent.is_top_level(name49);
  }
  /**
   * @param {string} name
   * @returns {NodeWithScope}
   */
  get_owner(name49) {
    return this.owners.get(name49) || this.parent && this.parent.get_owner(name49);
  }
  /** @param {string} name */
  is_let(name49) {
    const owner = this.get_owner(name49);
    return owner && (owner.type === "Element" || owner.type === "InlineComponent" || owner.type === "SlotTemplate");
  }
  /** @param {string} name */
  is_await(name49) {
    const owner = this.get_owner(name49);
    return owner && (owner.type === "ThenBlock" || owner.type === "CatchBlock");
  }
  /** @param {string} name */
  is_const(name49) {
    const owner = this.get_owner(name49);
    return owner && owner.type === "ConstTag";
  }
};

// node_modules/svelte/src/compiler/compile/nodes/Fragment.js
var Fragment = class extends Node3 {
  /**
   * @param {import('../Component.js').default} component
   * @param {import('../../interfaces.js').TemplateNode} info
   */
  constructor(component, info) {
    const scope = new TemplateScope();
    super(component, null, scope, info);
    /** @type {import('../render_dom/Block.js').default} */
    __publicField(this, "block");
    /** @type {import('./interfaces.js').INode[]} */
    __publicField(this, "children");
    /** @type {import('./shared/TemplateScope.js').default} */
    __publicField(this, "scope");
    this.scope = scope;
    this.children = map_children(component, this, scope, info.children);
  }
};

// node_modules/svelte/src/compiler/compile/internal_exports.js
var internal_exports_default = /* @__PURE__ */ new Set(["HtmlTag", "HtmlTagHydration", "ResizeObserverSingleton", "SvelteComponent", "SvelteComponentDev", "SvelteComponentTyped", "SvelteElement", "action_destroyer", "add_attribute", "add_classes", "add_flush_callback", "add_iframe_resize_listener", "add_location", "add_render_callback", "add_styles", "add_transform", "afterUpdate", "append", "append_dev", "append_empty_stylesheet", "append_hydration", "append_hydration_dev", "append_styles", "assign", "attr", "attr_dev", "attribute_to_object", "beforeUpdate", "bind", "binding_callbacks", "blank_object", "bubble", "check_outros", "children", "claim_comment", "claim_component", "claim_element", "claim_html_tag", "claim_space", "claim_svg_element", "claim_text", "clear_loops", "comment", "component_subscribe", "compute_rest_props", "compute_slots", "construct_svelte_component", "construct_svelte_component_dev", "contenteditable_truthy_values", "createEventDispatcher", "create_animation", "create_bidirectional_transition", "create_component", "create_custom_element", "create_in_transition", "create_out_transition", "create_slot", "create_ssr_component", "current_component", "custom_event", "dataset_dev", "debug", "destroy_block", "destroy_component", "destroy_each", "detach", "detach_after_dev", "detach_before_dev", "detach_between_dev", "detach_dev", "dirty_components", "dispatch_dev", "each", "element", "element_is", "empty", "end_hydrating", "ensure_array_like", "ensure_array_like_dev", "escape", "escape_attribute_value", "escape_object", "exclude_internal_props", "fix_and_destroy_block", "fix_and_outro_and_destroy_block", "fix_position", "flush", "flush_render_callbacks", "getAllContexts", "getContext", "get_all_dirty_from_scope", "get_binding_group_value", "get_current_component", "get_custom_elements_slots", "get_root_for_style", "get_slot_changes", "get_spread_object", "get_spread_update", "get_store_value", "get_svelte_dataset", "globals", "group_outros", "handle_promise", "hasContext", "has_prop", "head_selector", "identity", "init", "init_binding_group", "init_binding_group_dynamic", "insert", "insert_dev", "insert_hydration", "insert_hydration_dev", "intros", "invalid_attribute_name_character", "is_client", "is_crossorigin", "is_empty", "is_function", "is_promise", "is_void", "listen", "listen_dev", "loop", "loop_guard", "merge_ssr_styles", "missing_component", "mount_component", "noop", "not_equal", "now", "null_to_empty", "object_without_properties", "onDestroy", "onMount", "once", "outro_and_destroy_block", "prevent_default", "prop_dev", "query_selector_all", "raf", "resize_observer_border_box", "resize_observer_content_box", "resize_observer_device_pixel_content_box", "run", "run_all", "safe_not_equal", "schedule_update", "select_multiple_value", "select_option", "select_options", "select_value", "self", "setContext", "set_attributes", "set_current_component", "set_custom_element_data", "set_custom_element_data_map", "set_data", "set_data_contenteditable", "set_data_contenteditable_dev", "set_data_dev", "set_data_maybe_contenteditable", "set_data_maybe_contenteditable_dev", "set_dynamic_element_data", "set_input_type", "set_input_value", "set_now", "set_raf", "set_store_value", "set_style", "set_svg_attributes", "space", "split_css_unit", "spread", "src_url_equal", "srcset_url_equal", "start_hydrating", "stop_immediate_propagation", "stop_propagation", "stringify_spread", "subscribe", "svg_element", "text", "tick", "time_ranges_to_array", "to_number", "toggle_class", "transition_in", "transition_out", "trusted", "update_await_block_branch", "update_keyed_each", "update_slot", "update_slot_base", "validate_component", "validate_dynamic_element", "validate_each_keys", "validate_slots", "validate_store", "validate_void_dynamic_element", "xlink_attr"]);

// node_modules/svelte/src/compiler/compile/utils/is_used_as_reference.js
function is_used_as_reference(node, parent) {
  if (!is_reference(
    /** @type {import('is-reference').NodeWithPropertyDefinition} */
    node,
    /** @type {import('is-reference').NodeWithPropertyDefinition} */
    parent
  )) {
    return false;
  }
  if (!parent) {
    return true;
  }
  switch (parent.type) {
    case "VariableDeclarator":
      return node !== parent.id;
    case "FunctionDeclaration":
    case "ImportSpecifier":
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ExportSpecifier":
      return false;
    default:
      return true;
  }
}

// node_modules/svelte/src/compiler/compile/Component.js
var regex_leading_directory_separator = /^[/\\]/;
var regex_starts_with_term_export = /^Export/;
var regex_contains_term_function = /Function/;
var Component = class {
  /**
   * @param {import('../interfaces.js').Ast} ast
   * @param {string} source
   * @param {string} name
   * @param {import('../interfaces.js').CompileOptions} compile_options
   * @param {import('../Stats.js').default} stats
   * @param {import('../interfaces.js').Warning[]} warnings
   */
  constructor(ast, source, name49, compile_options, stats, warnings) {
    /** @type {import('../Stats.js').default} */
    __publicField(this, "stats");
    /** @type {import('../interfaces.js').Warning[]} */
    __publicField(this, "warnings");
    /** @type {Set<string>} */
    __publicField(this, "ignores");
    /** @type {Array<Set<string>>} */
    __publicField(this, "ignore_stack", []);
    /** @type {import('../interfaces.js').Ast} */
    __publicField(this, "ast");
    /** @type {import('../interfaces.js').Ast} */
    __publicField(this, "original_ast");
    /** @type {string} */
    __publicField(this, "source");
    /** @type {import('estree').Identifier} */
    __publicField(this, "name");
    /** @type {import('../interfaces.js').CompileOptions} */
    __publicField(this, "compile_options");
    /** @type {import('./nodes/Fragment.js').default} */
    __publicField(this, "fragment");
    /** @type {import('./utils/scope.js').Scope} */
    __publicField(this, "module_scope");
    /** @type {import('./utils/scope.js').Scope} */
    __publicField(this, "instance_scope");
    /** @type {WeakMap<import('estree').Node, import('./utils/scope.js').Scope>} */
    __publicField(this, "instance_scope_map");
    /** @type {ComponentOptions} */
    __publicField(this, "component_options");
    /** @type {string} */
    __publicField(this, "namespace");
    /** @type {string} */
    __publicField(this, "tag");
    /** @type {boolean} */
    __publicField(this, "accessors");
    /** @type {import('../interfaces.js').Var[]} */
    __publicField(this, "vars", []);
    /** @type {Map<string, import('../interfaces.js').Var>} */
    __publicField(this, "var_lookup", /* @__PURE__ */ new Map());
    /** @type {import('estree').ImportDeclaration[]} */
    __publicField(this, "imports", []);
    /** @type {import('estree').ExportNamedDeclaration[]} */
    __publicField(this, "exports_from", []);
    /** @type {import('estree').ExportNamedDeclaration[]} */
    __publicField(this, "instance_exports_from", []);
    /** @type {Set<import('estree').Node>} */
    __publicField(this, "hoistable_nodes", /* @__PURE__ */ new Set());
    /** @type {Map<string, import('estree').Node>} */
    __publicField(this, "node_for_declaration", /* @__PURE__ */ new Map());
    /** @type {Array<import('estree').Node | import('estree').Node[]>} */
    __publicField(this, "partly_hoisted", []);
    /** @type {Array<import('estree').Node | import('estree').Node[]>} */
    __publicField(this, "fully_hoisted", []);
    /**
     * @type {Array<{
     * 		assignees: Set<string>;
     * 		dependencies: Set<string>;
     * 		node: import('estree').Node;
     * 		declaration: import('estree').Node;
     * 	}>}
     */
    __publicField(this, "reactive_declarations", []);
    /** @type {Set<import('estree').Node>} */
    __publicField(this, "reactive_declaration_nodes", /* @__PURE__ */ new Set());
    /** */
    __publicField(this, "has_reactive_assignments", false);
    /** @type {Set<string>} */
    __publicField(this, "injected_reactive_declaration_vars", /* @__PURE__ */ new Set());
    /** @type {Map<string, import('estree').Identifier>} */
    __publicField(this, "helpers", /* @__PURE__ */ new Map());
    /** @type {Map<string, import('estree').Identifier>} */
    __publicField(this, "globals", /* @__PURE__ */ new Map());
    /** @type {Map<string, Set<string>>} */
    __publicField(this, "indirect_dependencies", /* @__PURE__ */ new Map());
    /** @type {string} */
    __publicField(this, "file");
    /**
     * Use this for stack traces. It is 1-based and acts on pre-processed sources.
     * Use `meta_locate` for metadata on DOM elements.
     * @type {(c: number) => { line: number; column: number }}
     */
    __publicField(this, "locate");
    /**
     * Use this for metadata on DOM elements. It is 1-based and acts on sources that have not been pre-processed.
     * Use `locate` for source mappings.
     * @type {(c: number) => { line: number; column: number }}
     */
    __publicField(this, "meta_locate");
    /** @type {import('./nodes/Element.js').default[]} */
    __publicField(this, "elements", []);
    /** @type {import('./css/Stylesheet.js').default} */
    __publicField(this, "stylesheet");
    /** @type {Map<string, import('estree').Identifier>} */
    __publicField(this, "aliases", /* @__PURE__ */ new Map());
    /** @type {Set<string>} */
    __publicField(this, "used_names", /* @__PURE__ */ new Set());
    /** @type {Set<string>} */
    __publicField(this, "globally_used_names", /* @__PURE__ */ new Set());
    /** @type {Map<string, import('./nodes/Slot.js').default>} */
    __publicField(this, "slots", /* @__PURE__ */ new Map());
    /** @type {Set<string>} */
    __publicField(this, "slot_outlets", /* @__PURE__ */ new Set());
    /** @type {import('./nodes/shared/Tag.js').default[]} */
    __publicField(this, "tags", []);
    var _a;
    this.name = { type: "Identifier", name: name49 };
    this.stats = stats;
    this.warnings = warnings;
    this.ast = ast;
    this.source = source;
    this.compile_options = compile_options;
    this.original_ast = clone2({
      html: ast.html,
      css: ast.css,
      instance: ast.instance,
      module: ast.module
    });
    this.file = compile_options.filename && (typeof process !== "undefined" ? compile_options.filename.replace(process.cwd(), "").replace(regex_leading_directory_separator, "") : compile_options.filename);
    this.locate = getLocator(this.source, { offsetLine: 1 });
    let tracer;
    this.meta_locate = (c2) => {
      let location = this.locate(c2);
      if (tracer === void 0) {
        tracer = compile_options.sourcemap ? new import_trace_mapping.TraceMap(compile_options.sourcemap) : null;
      }
      if (tracer) {
        location = (0, import_trace_mapping.originalPositionFor)(tracer, location);
      }
      return location;
    };
    this.stylesheet = new Stylesheet({
      source,
      ast,
      filename: compile_options.filename,
      component_name: name49,
      dev: compile_options.dev,
      get_css_hash: compile_options.cssHash
    });
    this.stylesheet.validate(this);
    this.component_options = process_component_options(this, this.ast.html.children);
    this.namespace = namespaces[this.component_options.namespace] || this.component_options.namespace;
    if (compile_options.customElement) {
      this.tag = ((_a = this.component_options.customElement) == null ? void 0 : _a.tag) || compile_options.tag || this.name.name;
    } else {
      this.tag = this.name.name;
    }
    this.walk_module_js();
    this.push_ignores(
      this.ast.instance ? extract_ignores_above_position(this.ast.instance.start, this.ast.html.children) : []
    );
    this.walk_instance_js_pre_template();
    this.pop_ignores();
    this.fragment = new Fragment(this, ast.html);
    this.name = this.get_unique_name(name49);
    this.push_ignores(
      this.ast.instance ? extract_ignores_above_position(this.ast.instance.start, this.ast.html.children) : []
    );
    this.walk_instance_js_post_template();
    this.pop_ignores();
    this.elements.forEach((element) => this.stylesheet.apply(element));
    this.stylesheet.reify();
    this.stylesheet.warn_on_unused_selectors(this);
  }
  /**
   * @param {import('estree').Node} node
   * @param {import('../interfaces.js').Var} variable
   * @param {any} add_to_lookup
   */
  add_var(node, variable, add_to_lookup = true) {
    this.vars.push(variable);
    if (add_to_lookup) {
      if (this.var_lookup.has(variable.name)) {
        const exists_var = this.var_lookup.get(variable.name);
        if (exists_var.module && exists_var.imported) {
          this.error(
            /** @type {any} */
            node,
            compiler_errors_default.illegal_variable_declaration
          );
        }
      }
      this.var_lookup.set(variable.name, variable);
    }
  }
  /**
   * @param {import('estree').Node} node
   * @param {string} name
   */
  add_reference(node, name49) {
    const variable = this.var_lookup.get(name49);
    if (variable) {
      variable.referenced = true;
    } else if (is_reserved_keyword(name49)) {
      this.add_var(node, {
        name: name49,
        injected: true,
        referenced: true
      });
    } else if (name49[0] === "$") {
      this.add_var(node, {
        name: name49,
        injected: true,
        referenced: true,
        mutated: true,
        writable: true
      });
      const subscribable_name = name49.slice(1);
      const variable2 = this.var_lookup.get(subscribable_name);
      if (variable2) {
        variable2.referenced = true;
        variable2.subscribable = true;
      }
    } else {
      if (this.compile_options.varsReport === "full") {
        this.add_var(node, { name: name49, referenced: true }, false);
      }
      this.used_names.add(name49);
    }
  }
  /** @param {string} name */
  alias(name49) {
    if (!this.aliases.has(name49)) {
      this.aliases.set(name49, this.get_unique_name(name49));
    }
    return this.aliases.get(name49);
  }
  /** @param {import('./nodes/Element.js').default} element */
  apply_stylesheet(element) {
    this.elements.push(element);
  }
  /** @param {string} name */
  global(name49) {
    const alias = this.alias(name49);
    this.globals.set(name49, alias);
    return alias;
  }
  /**
   * @param {{ js: import('estree').Node[]; css: import('../interfaces.js').CssResult }} [result]
   * @returns {import('../interfaces.js').CompileResult}
   */
  generate(result) {
    let js = null;
    let css = null;
    if (result) {
      const { compile_options, name: name49 } = this;
      const banner = `${this.file ? `${this.file} ` : ""}generated by Svelte v${VERSION}`;
      const program = { type: "Program", body: result.js };
      walk(program, {
        enter: (
          /**
          * @param {import('estree').Node} node
          * @param {import('estree').Node} parent
          * @param {any} key
          */
          (node, parent, key) => {
            if (node.type === "Identifier") {
              if (node.name[0] === "@") {
                if (node.name[1] === "_") {
                  const alias = this.global(node.name.slice(2));
                  node.name = alias.name;
                } else {
                  let name50 = node.name.slice(1);
                  if (compile_options.hydratable) {
                    if (internal_exports_default.has(`${name50}_hydration`)) {
                      name50 += "_hydration";
                    } else if (internal_exports_default.has(`${name50}Hydration`)) {
                      name50 += "Hydration";
                    }
                  }
                  if (compile_options.dev) {
                    if (internal_exports_default.has(`${name50}_dev`)) {
                      name50 += "_dev";
                    } else if (internal_exports_default.has(`${name50}Dev`)) {
                      name50 += "Dev";
                    }
                  }
                  const alias = this.alias(name50);
                  this.helpers.set(name50, alias);
                  node.name = alias.name;
                }
              } else if (node.name[0] !== "#" && !is_valid(node.name)) {
                const literal2 = { type: "Literal", value: node.name };
                if (parent.type === "Property" && key === "key") {
                  parent.key = literal2;
                } else if (parent.type === "MemberExpression" && key === "property") {
                  parent.property = literal2;
                  parent.computed = true;
                }
              }
            }
          }
        )
      });
      const referenced_globals = Array.from(
        this.globals,
        ([name50, alias]) => name50 !== alias.name && { name: name50, alias }
      ).filter(Boolean);
      if (referenced_globals.length) {
        this.helpers.set("globals", this.alias("globals"));
      }
      const imported_helpers = Array.from(this.helpers, ([name50, alias]) => ({
        name: name50,
        alias
      }));
      create_module(
        program,
        name49,
        banner,
        compile_options.sveltePath,
        imported_helpers,
        referenced_globals,
        this.imports,
        this.vars.filter((variable) => variable.module && variable.export_name).map((variable) => ({
          name: variable.name,
          as: variable.export_name
        })),
        this.exports_from
      );
      css = compile_options.customElement ? { code: null, map: null } : result.css;
      const js_sourcemap_enabled = check_enable_sourcemap(compile_options.enableSourcemap, "js");
      if (!js_sourcemap_enabled) {
        js = print(program);
        js.map = null;
      } else {
        const sourcemap_source_filename = get_sourcemap_source_filename(compile_options);
        js = print(program, {
          sourceMapSource: sourcemap_source_filename
        });
        js.map.sources = [sourcemap_source_filename];
        js.map.sourcesContent = [this.source];
        js.map = apply_preprocessor_sourcemap(
          sourcemap_source_filename,
          js.map,
          /** @type {string | import('@ampproject/remapping').RawSourceMap | import('@ampproject/remapping').DecodedSourceMap} */
          compile_options.sourcemap
        );
      }
    }
    return {
      js,
      css,
      ast: this.original_ast,
      warnings: this.warnings,
      vars: this.get_vars_report(),
      stats: this.stats.render()
    };
  }
  /**
   * @param {string} name
   * @param {import('./utils/scope.js').Scope} [scope]
   * @returns {import('estree').Identifier}
   */
  get_unique_name(name49, scope) {
    let alias = name49;
    for (let i = 1; reserved.has(alias) || this.var_lookup.has(alias) || this.used_names.has(alias) || this.globally_used_names.has(alias) || scope && scope.has(alias); ) {
      alias = `${name49}_${i++}`;
    }
    this.used_names.add(alias);
    return { type: "Identifier", name: alias };
  }
  get_unique_name_maker() {
    const local_used_names = /* @__PURE__ */ new Set();
    function add(name49) {
      local_used_names.add(name49);
    }
    reserved.forEach(add);
    internal_exports_default.forEach(add);
    this.var_lookup.forEach((_value, key) => add(key));
    return (name49) => {
      let alias = name49;
      for (let i = 1; this.used_names.has(alias) || local_used_names.has(alias); alias = `${name49}_${i++}`)
        ;
      local_used_names.add(alias);
      this.globally_used_names.add(alias);
      return {
        type: "Identifier",
        name: alias
      };
    };
  }
  /** @returns {import('../interfaces.js').Var[]} */
  get_vars_report() {
    const { compile_options, vars } = this;
    const vars_report = compile_options.varsReport === false ? [] : compile_options.varsReport === "full" ? vars : vars.filter((v) => !v.global && !v.internal);
    return vars_report.map((v) => ({
      name: v.name,
      export_name: v.export_name || null,
      injected: v.injected || false,
      module: v.module || false,
      mutated: v.mutated || false,
      reassigned: v.reassigned || false,
      referenced: v.referenced || false,
      writable: v.writable || false,
      referenced_from_script: v.referenced_from_script || false
    }));
  }
  /**
   * @param {{
   * 			start: number;
   * 			end: number;
   * 		}} pos
   * @param {{
   * 			code: string;
   * 			message: string;
   * 		}} e
   */
  error(pos, e) {
    if (this.compile_options.errorMode === "warn") {
      this.warn(pos, e);
    } else {
      error(e.message, {
        name: "ValidationError",
        code: e.code,
        source: this.source,
        start: pos.start,
        end: pos.end,
        filename: this.compile_options.filename
      });
    }
  }
  /**
   * @param {{
   * 			start: number;
   * 			end: number;
   * 		}} pos
   * @param {{
   * 			code: string;
   * 			message: string;
   * 		}} warning
   */
  warn(pos, warning) {
    if (this.ignores && this.ignores.has(warning.code)) {
      return;
    }
    const start = this.locate(pos.start);
    const end = this.locate(pos.end);
    const frame = get_code_frame(this.source, start.line - 1, start.column);
    this.warnings.push({
      code: warning.code,
      message: warning.message,
      frame,
      start,
      end,
      pos: pos.start,
      filename: this.compile_options.filename,
      toString: () => `${warning.message} (${start.line}:${start.column})
${frame}`
    });
  }
  /** @param {any} node */
  extract_imports(node) {
    this.imports.push(node);
  }
  /**
   * @param {any} node
   * @param {any} module_script
   */
  extract_exports(node, module_script = false) {
    const ignores = extract_svelte_ignore_from_comments(node);
    if (ignores.length)
      this.push_ignores(ignores);
    const result = this._extract_exports(node, module_script);
    if (ignores.length)
      this.pop_ignores();
    return result;
  }
  /**
   * @private
   * @param {import('estree').ExportDefaultDeclaration | import('estree').ExportNamedDeclaration | import('estree').ExportAllDeclaration} node
   * @param {boolean} module_script
   */
  _extract_exports(node, module_script) {
    if (node.type === "ExportDefaultDeclaration") {
      return this.error(
        /** @type {any} */
        node,
        compiler_errors_default.default_export
      );
    }
    if (node.type === "ExportNamedDeclaration") {
      if (node.source) {
        if (module_script) {
          this.exports_from.push(node);
        } else {
          this.instance_exports_from.push(node);
        }
        return null;
      }
      if (node.declaration) {
        if (node.declaration.type === "VariableDeclaration") {
          node.declaration.declarations.forEach((declarator) => {
            extract_names(declarator.id).forEach((name49) => {
              var _a;
              const variable = this.var_lookup.get(name49);
              variable.export_name = name49;
              if (((_a = declarator.init) == null ? void 0 : _a.type) === "Literal" && typeof declarator.init.value === "boolean") {
                variable.is_boolean = true;
              }
              if (!module_script && variable.writable && !(variable.referenced || variable.referenced_from_script || variable.subscribable)) {
                this.warn(
                  /** @type {any} */
                  declarator,
                  compiler_warnings_default.unused_export_let(this.name.name, name49)
                );
              }
            });
          });
        } else {
          const { name: name49 } = node.declaration.id;
          const variable = this.var_lookup.get(name49);
          variable.export_name = name49;
        }
        return node.declaration;
      } else {
        node.specifiers.forEach((specifier) => {
          const variable = this.var_lookup.get(specifier.local.name);
          if (variable) {
            variable.export_name = specifier.exported.name;
            if (!module_script && variable.writable && !(variable.referenced || variable.referenced_from_script || variable.subscribable)) {
              this.warn(
                /** @type {any} */
                specifier,
                compiler_warnings_default.unused_export_let(this.name.name, specifier.exported.name)
              );
            }
          }
        });
        return null;
      }
    }
  }
  /** @param {any} script */
  extract_javascript(script) {
    if (!script)
      return null;
    return script.content.body.filter((node) => {
      if (!node)
        return false;
      if (this.hoistable_nodes.has(node))
        return false;
      if (this.reactive_declaration_nodes.has(node))
        return false;
      if (node.type === "ImportDeclaration")
        return false;
      if (node.type === "ExportDeclaration" && node.specifiers.length > 0)
        return false;
      return true;
    });
  }
  walk_module_js() {
    const component = this;
    const script = this.ast.module;
    if (!script)
      return;
    walk(script.content, {
      /** @param {import('estree').Node} node */
      enter(node) {
        if (node.type === "LabeledStatement" && node.label.name === "$") {
          component.warn(
            /** @type {any} */
            node,
            compiler_warnings_default.module_script_reactive_declaration
          );
        }
      }
    });
    const { scope, globals } = create_scopes(script.content);
    this.module_scope = scope;
    scope.declarations.forEach((node, name49) => {
      if (name49[0] === "$") {
        return this.error(
          /** @type {any} */
          node,
          compiler_errors_default.illegal_declaration
        );
      }
      const writable = node.type === "VariableDeclaration" && (node.kind === "var" || node.kind === "let");
      const imported = node.type.startsWith("Import");
      this.add_var(node, {
        name: name49,
        module: true,
        hoistable: true,
        writable,
        imported
      });
    });
    globals.forEach((node, name49) => {
      if (name49[0] === "$") {
        return this.error(
          /** @type {any} */
          node,
          compiler_errors_default.illegal_subscription
        );
      } else {
        this.add_var(node, {
          name: name49,
          global: true,
          hoistable: true
        });
      }
    });
    const { body } = script.content;
    let i = body.length;
    while (--i >= 0) {
      const node = body[i];
      if (node.type === "ImportDeclaration") {
        this.extract_imports(node);
        body.splice(i, 1);
      }
      if (regex_starts_with_term_export.test(node.type)) {
        const replacement = this.extract_exports(node, true);
        if (replacement) {
          body[i] = replacement;
        } else {
          body.splice(i, 1);
        }
      }
    }
  }
  walk_instance_js_pre_template() {
    const script = this.ast.instance;
    if (!script)
      return;
    script.content.body.forEach((node) => {
      if (node.type !== "LabeledStatement")
        return;
      if (node.body.type !== "ExpressionStatement")
        return;
      const { expression } = node.body;
      if (expression.type !== "AssignmentExpression")
        return;
      if (expression.left.type === "MemberExpression")
        return;
      extract_names(expression.left).forEach((name49) => {
        if (!this.var_lookup.has(name49) && name49[0] !== "$") {
          this.injected_reactive_declaration_vars.add(name49);
        }
      });
    });
    const { scope: instance_scope, map, globals } = create_scopes(script.content);
    this.instance_scope = instance_scope;
    this.instance_scope_map = map;
    instance_scope.declarations.forEach((node, name49) => {
      if (name49[0] === "$") {
        return this.error(
          /** @type {any} */
          node,
          compiler_errors_default.illegal_declaration
        );
      }
      const { type } = node;
      this.add_var(node, {
        name: name49,
        initialised: instance_scope.initialised_declarations.has(name49),
        imported: type.startsWith("Import"),
        writable: type === "VariableDeclaration" && (node.kind === "var" || node.kind === "let")
      });
      this.node_for_declaration.set(name49, node);
    });
    const global_keys = Array.from(globals.keys());
    const sorted_globals = [
      ...global_keys.filter((key) => key[0] !== "$"),
      ...global_keys.filter((key) => key[0] === "$")
    ];
    sorted_globals.forEach((name49) => {
      if (this.var_lookup.has(name49))
        return;
      const node = globals.get(name49);
      if (this.injected_reactive_declaration_vars.has(name49)) {
        this.add_var(node, {
          name: name49,
          injected: true,
          writable: true,
          reassigned: true,
          initialised: true
        });
      } else if (is_reserved_keyword(name49)) {
        this.add_var(node, {
          name: name49,
          injected: true
        });
      } else if (name49[0] === "$") {
        if (name49 === "$" || name49[1] === "$") {
          return this.error(
            /** @type {any} */
            node,
            compiler_errors_default.illegal_global(name49)
          );
        }
        this.add_var(node, {
          name: name49,
          injected: true,
          mutated: true,
          writable: true
        });
        this.add_reference(node, name49.slice(1));
        const variable = this.var_lookup.get(name49.slice(1));
        if (variable) {
          variable.subscribable = true;
          variable.referenced_from_script = true;
        }
      } else {
        this.add_var(node, {
          name: name49,
          global: true,
          hoistable: true
        });
      }
    });
    this.track_references_and_mutations();
  }
  walk_instance_js_post_template() {
    const script = this.ast.instance;
    if (!script)
      return;
    this.post_template_walk();
    this.hoist_instance_declarations();
    this.extract_reactive_declarations();
    this.check_if_tags_content_dynamic();
  }
  post_template_walk() {
    const script = this.ast.instance;
    if (!script)
      return;
    const component = this;
    const { content } = script;
    const { instance_scope, instance_scope_map: map } = this;
    let scope = instance_scope;
    const to_remove = [];
    const remove = (parent, prop, index) => {
      to_remove.unshift([parent, prop, index]);
    };
    let scope_updated = false;
    const current_function_stack = [];
    let current_function = null;
    walk(content, {
      /** @type {import('estree-walker').SyncHandler} */
      enter(node, parent, prop, index) {
        if (node.type === "FunctionDeclaration" || node.type === "FunctionExpression") {
          current_function_stack.push(current_function = node);
        }
        if (map.has(node)) {
          scope = map.get(node);
        }
        let deep = false;
        let names = [];
        if (node.type === "AssignmentExpression") {
          if (node.left.type === "ArrayPattern") {
            walk(node.left, {
              /**
               * @param {import('estree').Node} node
               * @param {import('estree').Node} parent
               */
              enter(node2, parent2) {
                if (node2.type === "Identifier" && parent2.type !== "MemberExpression" && (parent2.type !== "AssignmentPattern" || parent2.right !== node2)) {
                  names.push(node2.name);
                }
              }
            });
          } else {
            deep = node.left.type === "MemberExpression";
            names = deep ? [get_object(node.left).name] : extract_names(node.left);
          }
        } else if (node.type === "UpdateExpression") {
          deep = node.argument.type === "MemberExpression";
          const { name: name49 } = get_object(node.argument);
          names.push(name49);
        }
        if (names.length > 0) {
          names.forEach((name49) => {
            let current_scope = scope;
            let declaration;
            while (current_scope) {
              if (current_scope.declarations.has(name49)) {
                declaration = current_scope.declarations.get(name49);
                break;
              }
              current_scope = current_scope.parent;
            }
            if (declaration && /** @type {import('estree').VariableDeclaration} */
            declaration.kind === "const" && !deep) {
              component.error(
                /** @type {any} */
                node,
                {
                  code: "assignment-to-const",
                  message: "You are assigning to a const"
                }
              );
            }
          });
        }
        if (node.type === "ImportDeclaration") {
          component.extract_imports(node);
          remove(parent, prop, index);
          return this.skip();
        }
        if (regex_starts_with_term_export.test(node.type)) {
          const replacement = component.extract_exports(node);
          if (replacement) {
            this.replace(replacement);
          } else {
            remove(parent, prop, index);
          }
          return this.skip();
        }
        component.warn_on_undefined_store_value_references(node, parent, prop, scope);
      },
      /** @param {import('estree').Node} node */
      leave(node) {
        if (node.type === "FunctionDeclaration" || node.type === "FunctionExpression") {
          current_function_stack.pop();
          current_function = current_function_stack[current_function_stack.length - 1];
        }
        if (component.compile_options.dev && component.compile_options.loopGuardTimeout > 0 && (!current_function || !current_function.generator && !current_function.async)) {
          const to_replace_for_loop_protect = component.loop_protect(
            node,
            scope,
            component.compile_options.loopGuardTimeout
          );
          if (to_replace_for_loop_protect) {
            this.replace(to_replace_for_loop_protect);
            scope_updated = true;
          }
        }
        if (map.has(node)) {
          scope = scope.parent;
        }
      }
    });
    for (const [parent, prop, index] of to_remove) {
      if (parent) {
        if (index !== null) {
          parent[prop].splice(index, 1);
        } else {
          delete parent[prop];
        }
      }
    }
    if (scope_updated) {
      const { scope: scope2, map: map2 } = create_scopes(script.content);
      this.instance_scope = scope2;
      this.instance_scope_map = map2;
    }
  }
  track_references_and_mutations() {
    const script = this.ast.instance;
    if (!script)
      return;
    const component = this;
    const { content } = script;
    const { instance_scope, module_scope, instance_scope_map: map } = this;
    let scope = instance_scope;
    walk(content, {
      /**
       * @param {import('estree').Node} node
       * @param {import('estree').Node} parent
       */
      enter(node, parent) {
        if (map.has(node)) {
          scope = map.get(node);
        }
        if (node.type === "AssignmentExpression" || node.type === "UpdateExpression") {
          const assignee = node.type === "AssignmentExpression" ? node.left : node.argument;
          const names = extract_names(
            /** @type {import('estree').Node} */
            assignee
          );
          const deep = assignee.type === "MemberExpression";
          names.forEach((name49) => {
            const scope_owner = scope.find_owner(name49);
            if (scope_owner !== null ? scope_owner === instance_scope : module_scope && module_scope.has(name49)) {
              const variable = component.var_lookup.get(name49);
              variable[deep ? "mutated" : "reassigned"] = true;
            }
          });
        }
        if (is_used_as_reference(node, parent)) {
          const object = get_object(node);
          if (scope.find_owner(object.name) === instance_scope) {
            const variable = component.var_lookup.get(object.name);
            variable.referenced_from_script = true;
          }
        }
      },
      /** @param {import('estree').Node} node */
      leave(node) {
        if (map.has(node)) {
          scope = scope.parent;
        }
      }
    });
  }
  /**
   * @param {import('estree').Node} node
   * @param {import('estree').Node} parent
   * @param {string | number | symbol} prop
   * @param {import('./utils/scope.js').Scope} scope
   */
  warn_on_undefined_store_value_references(node, parent, prop, scope) {
    if (node.type === "LabeledStatement" && node.label.name === "$" && parent.type !== "Program") {
      this.warn(
        /** @type {any} */
        node,
        compiler_warnings_default.non_top_level_reactive_declaration
      );
    }
    if (is_reference(
      /** @type {import('is-reference').NodeWithPropertyDefinition} */
      node,
      /** @type {import('is-reference').NodeWithPropertyDefinition} */
      parent
    )) {
      const object = get_object(node);
      const { name: name49 } = object;
      if (name49[0] === "$") {
        if (!scope.has(name49)) {
          this.warn_if_undefined(name49, object, null);
        }
        if (name49[1] !== "$" && scope.has(name49.slice(1)) && scope.find_owner(name49.slice(1)) !== this.instance_scope) {
          if (!(regex_contains_term_function.test(parent.type) && prop === "params" || parent.type === "VariableDeclarator" && prop === "id")) {
            return this.error(
              /** @type {any} */
              node,
              compiler_errors_default.contextual_store
            );
          }
        }
      }
    }
  }
  /**
   * @param {any} node
   * @param {import('./utils/scope.js').Scope} scope
   * @param {number} timeout
   * @returns {import('estree').Node}
   */
  loop_protect(node, scope, timeout) {
    if (node.type === "WhileStatement" || node.type === "ForStatement" || node.type === "DoWhileStatement") {
      const guard = this.get_unique_name("guard", scope);
      this.used_names.add(guard.name);
      const before = b`const ${guard} = @loop_guard(${timeout})`;
      const inside = b`${guard}();`;
      if (node.body.type !== "BlockStatement") {
        node.body = {
          type: "BlockStatement",
          body: [node.body]
        };
      }
      node.body.body.push(inside[0]);
      return {
        type: "BlockStatement",
        body: [before[0], node]
      };
    }
    return null;
  }
  /** @param {(variable: import('../interfaces.js').Var) => import('estree').Node[]} get_insert */
  rewrite_props(get_insert) {
    if (!this.ast.instance)
      return;
    const component = this;
    const { instance_scope, instance_scope_map: map } = this;
    let scope = instance_scope;
    walk(this.ast.instance.content, {
      /** @param {import('estree').Node} node */
      enter(node) {
        if (regex_contains_term_function.test(node.type)) {
          return this.skip();
        }
        if (map.has(node)) {
          scope = map.get(node);
        }
        if (node.type === "ExportNamedDeclaration" && node.declaration) {
          return this.replace(node.declaration);
        }
        if (node.type === "VariableDeclaration") {
          if (node.kind === "var" || scope === instance_scope) {
            let add_new_props = function(exported, local, default_value) {
              props.push({
                type: "Property",
                method: false,
                shorthand: false,
                computed: false,
                kind: "init",
                key: exported,
                value: default_value ? {
                  type: "AssignmentPattern",
                  left: local,
                  right: default_value
                } : local
              });
            };
            const inserts = [];
            const props = [];
            for (let index = 0; index < node.declarations.length; index++) {
              const declarator = node.declarations[index];
              if (declarator.id.type !== "Identifier") {
                let get_new_name = function(local) {
                  const variable = component.var_lookup.get(local.name);
                  if (variable.subscribable) {
                    inserts.push(get_insert(variable));
                  }
                  if (variable.export_name && variable.writable) {
                    const alias_name = component.get_unique_name(local.name);
                    add_new_props(
                      { type: "Identifier", name: variable.export_name },
                      local,
                      alias_name
                    );
                    return alias_name;
                  }
                  return local;
                }, rename_identifiers = function(param) {
                  switch (param.type) {
                    case "ObjectPattern": {
                      const handle_prop = (prop) => {
                        if (prop.type === "RestElement") {
                          rename_identifiers(prop);
                        } else if (prop.value.type === "Identifier") {
                          prop.value = get_new_name(prop.value);
                        } else {
                          rename_identifiers(
                            /** @type {import('estree').Pattern} */
                            prop.value
                          );
                        }
                      };
                      param.properties.forEach(handle_prop);
                      break;
                    }
                    case "ArrayPattern": {
                      const handle_element = (element, index2, array) => {
                        if (element) {
                          if (element.type === "Identifier") {
                            array[index2] = get_new_name(element);
                          } else {
                            rename_identifiers(element);
                          }
                        }
                      };
                      param.elements.forEach(handle_element);
                      break;
                    }
                    case "RestElement":
                      if (param.argument.type === "Identifier") {
                        param.argument = get_new_name(param.argument);
                      } else {
                        rename_identifiers(param.argument);
                      }
                      break;
                    case "AssignmentPattern":
                      if (param.left.type === "Identifier") {
                        param.left = get_new_name(param.left);
                      } else {
                        rename_identifiers(param.left);
                      }
                      break;
                  }
                };
                rename_identifiers(declarator.id);
              } else {
                const { name: name49 } = declarator.id;
                const variable = component.var_lookup.get(name49);
                const is_props = variable.export_name && variable.writable;
                if (is_props) {
                  add_new_props(
                    { type: "Identifier", name: variable.export_name },
                    declarator.id,
                    declarator.init
                  );
                  node.declarations.splice(index--, 1);
                }
                if (variable.subscribable && (is_props || declarator.init)) {
                  inserts.push(get_insert(variable));
                }
              }
            }
            this.replace(
              /** @type {any} */
              b`
							${node.declarations.length ? node : null}
							${props.length > 0 && b`let { ${props} } = $$props;`}
							${inserts}
						`
            );
            return this.skip();
          }
        }
      },
      /** @param {import('estree').Node} node */
      leave(node) {
        if (map.has(node)) {
          scope = scope.parent;
        }
      }
    });
  }
  hoist_instance_declarations() {
    const { hoistable_nodes, var_lookup, injected_reactive_declaration_vars, imports } = this;
    const top_level_function_declarations = /* @__PURE__ */ new Map();
    const { body } = this.ast.instance.content;
    for (let i = 0; i < body.length; i += 1) {
      const node = body[i];
      if (node.type === "VariableDeclaration") {
        const all_hoistable = node.declarations.every((d) => {
          if (!d.init)
            return false;
          if (d.init.type !== "Literal")
            return false;
          if (node.kind !== "const" && this.compile_options.dev)
            return false;
          for (const name49 of extract_names(d.id)) {
            const v = this.var_lookup.get(name49);
            if (v.reassigned)
              return false;
            if (v.export_name)
              return false;
            if (this.vars.find((variable) => variable.name === name49 && variable.module)) {
              return false;
            }
          }
          return true;
        });
        if (all_hoistable) {
          node.declarations.forEach((d) => {
            for (const name49 of extract_names(d.id)) {
              this.var_lookup.get(name49).hoistable = true;
            }
          });
          hoistable_nodes.add(node);
          body.splice(i--, 1);
          this.fully_hoisted.push(node);
        }
      }
      if (node.type === "ExportNamedDeclaration" && node.declaration && node.declaration.type === "FunctionDeclaration") {
        top_level_function_declarations.set(node.declaration.id.name, node);
      }
      if (node.type === "FunctionDeclaration") {
        top_level_function_declarations.set(node.id.name, node);
      }
    }
    const checked = /* @__PURE__ */ new Set();
    const walking = /* @__PURE__ */ new Set();
    const is_hoistable = (fn_declaration) => {
      if (fn_declaration.type === "ExportNamedDeclaration") {
        fn_declaration = fn_declaration.declaration;
      }
      const instance_scope = this.instance_scope;
      let scope = this.instance_scope;
      const map = this.instance_scope_map;
      let hoistable = true;
      walking.add(fn_declaration);
      walk(fn_declaration, {
        /** @type {import('estree-walker').SyncHandler} */
        enter(node, parent) {
          if (!hoistable)
            return this.skip();
          if (map.has(node)) {
            scope = map.get(node);
          }
          if (is_reference(
            /** @type {import('is-reference').NodeWithPropertyDefinition} */
            node,
            /** @type {import('is-reference').NodeWithPropertyDefinition} */
            parent
          )) {
            const { name: name49 } = flatten_reference(node);
            const owner = scope.find_owner(name49);
            if (injected_reactive_declaration_vars.has(name49)) {
              hoistable = false;
            } else if (name49[0] === "$" && !owner) {
              hoistable = false;
            } else if (owner === instance_scope) {
              const variable = var_lookup.get(name49);
              if (variable.reassigned || variable.mutated)
                hoistable = false;
              if (name49 === fn_declaration.id.name)
                return;
              if (variable.hoistable)
                return;
              if (top_level_function_declarations.has(name49)) {
                const other_declaration = top_level_function_declarations.get(name49);
                if (walking.has(other_declaration)) {
                  hoistable = false;
                } else if (other_declaration.type === "ExportNamedDeclaration" && walking.has(other_declaration.declaration)) {
                  hoistable = false;
                } else if (!is_hoistable(other_declaration)) {
                  hoistable = false;
                }
              } else {
                hoistable = false;
              }
            }
            this.skip();
          }
        },
        /** @param {import('estree').Node} node */
        leave(node) {
          if (map.has(node)) {
            scope = scope.parent;
          }
        }
      });
      checked.add(fn_declaration);
      walking.delete(fn_declaration);
      return hoistable;
    };
    for (const [name49, node] of top_level_function_declarations) {
      if (is_hoistable(node)) {
        const variable = this.var_lookup.get(name49);
        variable.hoistable = true;
        hoistable_nodes.add(node);
        const i = body.indexOf(node);
        body.splice(i, 1);
        this.fully_hoisted.push(node);
      }
    }
    for (const { specifiers } of imports) {
      for (const specifier of specifiers) {
        const variable = var_lookup.get(specifier.local.name);
        if (!variable.mutated || variable.subscribable) {
          variable.hoistable = true;
        }
      }
    }
  }
  extract_reactive_declarations() {
    const component = this;
    const unsorted_reactive_declarations = [];
    this.ast.instance.content.body.forEach((node) => {
      const ignores = extract_svelte_ignore_from_comments(node);
      if (ignores.length)
        this.push_ignores(ignores);
      if (node.type === "LabeledStatement" && node.label.name === "$") {
        this.reactive_declaration_nodes.add(node);
        const assignees = /* @__PURE__ */ new Set();
        const assignee_nodes = /* @__PURE__ */ new Set();
        const dependencies = /* @__PURE__ */ new Set();
        const module_dependencies = /* @__PURE__ */ new Set();
        let scope = this.instance_scope;
        const { declarations: outset_scope_decalarations } = this.instance_scope;
        const map = this.instance_scope_map;
        walk(node.body, {
          /** @type {import('estree-walker').SyncHandler} */
          enter(node2, parent) {
            if (node2.type === "VariableDeclaration" && node2.kind === "var") {
              const is_var_in_outset = node2.declarations.some(
                /** @param {import('estree').VariableDeclarator} declaration */
                (declaration2) => {
                  const names = extract_names(declaration2.id);
                  return !!names.find(
                    /** @param {string} name */
                    (name49) => {
                      const var_node = outset_scope_decalarations.get(name49);
                      return var_node === node2;
                    }
                  );
                }
              );
              if (is_var_in_outset) {
                return component.error(
                  /** @type {any} */
                  node2,
                  compiler_errors_default.invalid_var_declaration
                );
              }
            }
            if (map.has(node2)) {
              scope = map.get(node2);
            }
            if (node2.type === "AssignmentExpression") {
              const left = get_object(node2.left);
              extract_identifiers(left).forEach((node3) => {
                assignee_nodes.add(node3);
                assignees.add(node3.name);
              });
              if (node2.operator !== "=") {
                dependencies.add(left.name);
              }
            } else if (node2.type === "UpdateExpression") {
              const identifier = get_object(node2.argument);
              assignees.add(identifier.name);
            } else if (is_reference(
              /** @type {import('is-reference').NodeWithPropertyDefinition} */
              node2,
              /** @type {import('is-reference').NodeWithPropertyDefinition} */
              parent
            )) {
              const identifier = get_object(node2);
              if (!assignee_nodes.has(identifier)) {
                const { name: name49 } = identifier;
                const owner = scope.find_owner(name49);
                const variable = component.var_lookup.get(name49);
                let should_add_as_dependency = true;
                if (variable) {
                  variable.is_reactive_dependency = true;
                  if (variable.module && variable.writable) {
                    should_add_as_dependency = false;
                    module_dependencies.add(name49);
                  }
                }
                const is_writable_or_mutated = variable && (variable.writable || variable.mutated);
                if (should_add_as_dependency && (!owner || owner === component.instance_scope) && (name49[0] === "$" || is_writable_or_mutated)) {
                  dependencies.add(name49);
                }
              }
              this.skip();
            }
          },
          /** @param {import('estree').Node} node */
          leave(node2) {
            if (map.has(node2)) {
              scope = scope.parent;
            }
          }
        });
        if (module_dependencies.size > 0 && dependencies.size === 0) {
          component.warn(
            /** @type {any} */
            node.body,
            compiler_warnings_default.module_script_variable_reactive_declaration(
              Array.from(module_dependencies)
            )
          );
        }
        const { expression } = (
          /** @type {import('estree').ExpressionStatement} */
          node.body
        );
        const declaration = expression && /** @type {import('estree').AssignmentExpression} */
        expression.left;
        unsorted_reactive_declarations.push({
          assignees,
          dependencies,
          node,
          declaration
        });
      }
      if (ignores.length)
        this.pop_ignores();
    });
    const lookup = /* @__PURE__ */ new Map();
    unsorted_reactive_declarations.forEach((declaration) => {
      declaration.assignees.forEach((name49) => {
        if (!lookup.has(name49)) {
          lookup.set(name49, []);
        }
        lookup.get(name49).push(declaration);
      });
    });
    const cycle = check_graph_for_cycles(
      unsorted_reactive_declarations.reduce((acc, declaration) => {
        declaration.assignees.forEach((v) => {
          declaration.dependencies.forEach((w) => {
            if (!declaration.assignees.has(w)) {
              acc.push([v, w]);
            }
          });
        });
        return acc;
      }, [])
    );
    if (cycle && cycle.length) {
      const declaration_list = lookup.get(cycle[0]);
      const declaration = declaration_list[0];
      return this.error(declaration.node, compiler_errors_default.cyclical_reactive_declaration(cycle));
    }
    const add_declaration = (declaration) => {
      if (this.reactive_declarations.includes(declaration))
        return;
      declaration.dependencies.forEach((name49) => {
        if (declaration.assignees.has(name49))
          return;
        const earlier_declarations = lookup.get(name49);
        if (earlier_declarations) {
          earlier_declarations.forEach(add_declaration);
        }
      });
      this.reactive_declarations.push(declaration);
    };
    unsorted_reactive_declarations.forEach(add_declaration);
  }
  check_if_tags_content_dynamic() {
    this.tags.forEach((tag2) => {
      tag2.check_if_content_dynamic();
    });
  }
  /**
   * @param {string} name
   * @param {any} node
   * @param {import('./nodes/shared/TemplateScope.js').default} template_scope
   * @param {import("./nodes/shared/Node.js").default} [owner]
   */
  warn_if_undefined(name49, node, template_scope, owner) {
    if (name49[0] === "$") {
      if (name49 === "$" || name49[1] === "$" && !is_reserved_keyword(name49)) {
        return this.error(node, compiler_errors_default.illegal_global(name49));
      }
      this.has_reactive_assignments = true;
      if (is_reserved_keyword(name49))
        return;
      name49 = name49.slice(1);
    }
    if (this.var_lookup.has(name49) && !this.var_lookup.get(name49).global)
      return;
    if (template_scope && template_scope.names.has(name49))
      return;
    if (globals_default.has(name49) && node.type !== "InlineComponent")
      return;
    function has_out_of_scope_let() {
      for (let parent = owner.parent; parent; parent = parent.parent) {
        if (parent.type === "InlineComponent") {
          const { let_attributes } = parent;
          for (const attr of let_attributes) {
            if (
              // @ts-expect-error
              // TODO extract_names only considers patterns but let attributes return expressions
              attr.expression && extract_names(attr.expression).includes(name49) || attr.name === name49
            )
              return true;
          }
        }
      }
      return false;
    }
    if (owner && has_out_of_scope_let()) {
      return this.warn(node, {
        code: "missing-declaration",
        message: `let:${name49} declared on parent component cannot be used inside named slot`
      });
    }
    this.warn(node, compiler_warnings_default.missing_declaration(name49, !!this.ast.instance));
  }
  /** @param {any} ignores */
  push_ignores(ignores) {
    this.ignores = new Set(this.ignores || []);
    add_to_set(this.ignores, ignores);
    this.ignore_stack.push(this.ignores);
  }
  pop_ignores() {
    this.ignore_stack.pop();
    this.ignores = this.ignore_stack[this.ignore_stack.length - 1];
  }
};
var regex_valid_tag_name = /^[a-zA-Z][a-zA-Z0-9]*-[a-zA-Z0-9-]+$/;
function process_component_options(component, nodes) {
  const component_options = {
    immutable: component.compile_options.immutable || false,
    accessors: "accessors" in component.compile_options ? component.compile_options.accessors : !!component.compile_options.customElement,
    preserveWhitespace: !!component.compile_options.preserveWhitespace,
    namespace: component.compile_options.namespace
  };
  const node = nodes.find((node2) => node2.name === "svelte:options");
  function get_value2(attribute, { code: code2, message }) {
    const { value } = attribute;
    const chunk = value[0];
    if (!chunk)
      return true;
    if (value.length > 1) {
      return component.error(attribute, { code: code2, message });
    }
    if (chunk.type === "Text")
      return chunk.data;
    if (chunk.expression.type !== "Literal") {
      return component.error(attribute, { code: code2, message });
    }
    return chunk.expression.value;
  }
  if (node) {
    node.attributes.forEach((attribute) => {
      var _a, _b, _c, _d;
      if (attribute.type === "Attribute") {
        let parse_tag = function(attribute2, tag2) {
          if (typeof tag2 !== "string" && tag2 !== null) {
            return component.error(attribute2, compiler_errors_default.invalid_tag_attribute);
          }
          if (tag2 && !regex_valid_tag_name.test(tag2)) {
            return component.error(attribute2, compiler_errors_default.invalid_tag_property);
          }
          if (tag2 && !component.compile_options.customElement) {
            component.warn(attribute2, compiler_warnings_default.missing_custom_element_compile_options);
          }
          component_options.customElement = component_options.customElement || /** @type {any} */
          {};
          component_options.customElement.tag = tag2;
        };
        const { name: name49 } = attribute;
        switch (name49) {
          case "tag": {
            component.warn(attribute, compiler_warnings_default.tag_option_deprecated);
            parse_tag(attribute, get_value2(attribute, compiler_errors_default.invalid_tag_attribute));
            break;
          }
          case "customElement": {
            component_options.customElement = component_options.customElement || /** @type {any} */
            {};
            const { value } = attribute;
            if (value[0].type === "MustacheTag" && ((_a = value[0].expression) == null ? void 0 : _a.value) === null) {
              component_options.customElement.tag = null;
              break;
            } else if (value[0].type === "Text") {
              parse_tag(attribute, get_value2(attribute, compiler_errors_default.invalid_tag_attribute));
              break;
            } else if (value[0].expression.type !== "ObjectExpression") {
              return component.error(attribute, compiler_errors_default.invalid_customElement_attribute);
            }
            const tag2 = value[0].expression.properties.find((prop) => prop.key.name === "tag");
            if (tag2) {
              parse_tag(tag2, (_b = tag2.value) == null ? void 0 : _b.value);
            } else {
              return component.error(attribute, compiler_errors_default.invalid_customElement_attribute);
            }
            const props = value[0].expression.properties.find((prop) => prop.key.name === "props");
            if (props) {
              const error2 = () => component.error(attribute, compiler_errors_default.invalid_props_attribute);
              if (((_c = props.value) == null ? void 0 : _c.type) !== "ObjectExpression") {
                return error2();
              }
              component_options.customElement.props = {};
              for (
                const property2 of
                /** @type {import('estree').ObjectExpression} */
                props.value.properties
              ) {
                if (property2.type !== "Property" || property2.computed || property2.key.type !== "Identifier" || property2.value.type !== "ObjectExpression") {
                  return error2();
                }
                component_options.customElement.props[property2.key.name] = {};
                for (const prop of property2.value.properties) {
                  if (prop.type !== "Property" || prop.computed || prop.key.type !== "Identifier" || prop.value.type !== "Literal") {
                    return error2();
                  }
                  if (["reflect", "attribute", "type"].indexOf(prop.key.name) === -1 || prop.key.name === "type" && ["String", "Number", "Boolean", "Array", "Object"].indexOf(
                    /** @type {string} */
                    prop.value.value
                  ) === -1 || prop.key.name === "reflect" && typeof prop.value.value !== "boolean" || prop.key.name === "attribute" && typeof prop.value.value !== "string") {
                    return error2();
                  }
                  component_options.customElement.props[property2.key.name][prop.key.name] = prop.value.value;
                }
              }
            }
            const shadow = value[0].expression.properties.find(
              (prop) => prop.key.name === "shadow"
            );
            if (shadow) {
              const shadowdom = (_d = shadow.value) == null ? void 0 : _d.value;
              if (shadowdom !== "open" && shadowdom !== "none") {
                return component.error(shadow, compiler_errors_default.invalid_shadow_attribute);
              }
              component_options.customElement.shadow = shadowdom;
            }
            const extend2 = value[0].expression.properties.find(
              (prop) => prop.key.name === "extend"
            );
            if (extend2 == null ? void 0 : extend2.value) {
              component_options.customElement.extend = extend2.value;
            }
            break;
          }
          case "namespace": {
            const ns = get_value2(attribute, compiler_errors_default.invalid_namespace_attribute);
            if (typeof ns !== "string") {
              return component.error(attribute, compiler_errors_default.invalid_namespace_attribute);
            }
            if (valid_namespaces.indexOf(ns) === -1) {
              const match = fuzzymatch(ns, valid_namespaces);
              return component.error(
                attribute,
                compiler_errors_default.invalid_namespace_property(ns, match)
              );
            }
            component_options.namespace = ns;
            break;
          }
          case "accessors":
          case "immutable":
          case "preserveWhitespace": {
            const value = get_value2(attribute, compiler_errors_default.invalid_attribute_value(name49));
            if (typeof value !== "boolean") {
              return component.error(attribute, compiler_errors_default.invalid_attribute_value(name49));
            }
            component_options[name49] = value;
            break;
          }
          default:
            return component.error(
              attribute,
              compiler_errors_default.invalid_options_attribute_unknown(name49)
            );
        }
      } else {
        return component.error(attribute, compiler_errors_default.invalid_options_attribute);
      }
    });
  }
  return component_options;
}
function get_relative_path(from, to) {
  const from_parts = from.split(/[/\\]/);
  const to_parts = to.split(/[/\\]/);
  from_parts.pop();
  while (from_parts[0] === to_parts[0]) {
    from_parts.shift();
    to_parts.shift();
  }
  if (from_parts.length) {
    let i = from_parts.length;
    while (i--)
      from_parts[i] = "..";
  }
  return from_parts.concat(to_parts).join("/");
}
function get_basename(filename) {
  return filename.split(/[/\\]/).pop();
}
function get_sourcemap_source_filename(compile_options) {
  if (!compile_options.filename)
    return null;
  return compile_options.outputFilename ? get_relative_path(compile_options.outputFilename, compile_options.filename) : get_basename(compile_options.filename);
}

// node_modules/svelte/src/compiler/compile/utils/get_name_from_filename.js
var regex_percentage_characters = /%/g;
var regex_file_ending = /\.[^.]+$/;
var regex_repeated_invalid_variable_identifier_characters = /[^a-zA-Z_$0-9]+/g;
var regex_starts_with_digit = /^(\d)/;
var regex_may_starts_or_ends_with_underscore = /^_?(.+?)_?$/;
function get_name_from_filename(filename) {
  if (!filename)
    return null;
  const parts = filename.split(/[/\\]/).map(encodeURI);
  if (parts.length > 1) {
    const index_match = parts[parts.length - 1].match(/^index(\.\w+)/);
    if (index_match) {
      parts.pop();
      parts[parts.length - 1] += index_match[1];
    }
  }
  const base = parts.pop().replace(regex_percentage_characters, "u").replace(regex_file_ending, "").replace(regex_repeated_invalid_variable_identifier_characters, "_").replace(regex_may_starts_or_ends_with_underscore, "$1").replace(regex_starts_with_digit, "_$1");
  if (!base) {
    throw new Error(`Could not derive component name from file ${filename}`);
  }
  return base[0].toUpperCase() + base.slice(1);
}

// node_modules/svelte/src/compiler/compile/index.js
var valid_options = [
  "name",
  "filename",
  "sourcemap",
  "enableSourcemap",
  "generate",
  "errorMode",
  "varsReport",
  "outputFilename",
  "cssOutputFilename",
  "sveltePath",
  "dev",
  "accessors",
  "immutable",
  "hydratable",
  "legacy",
  "customElement",
  "namespace",
  "tag",
  "css",
  "loopGuardTimeout",
  "preserveComments",
  "preserveWhitespace",
  "cssHash",
  "discloseVersion"
];
var valid_css_values = [true, false, "injected", "external", "none"];
var regex_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
var regex_starts_with_lowercase_character = /^[a-z]/;
var warned_of_format = false;
var warned_boolean_css = false;
function validate_options(options, warnings) {
  if (
    /** @type {any} */
    options.format
  ) {
    if (!warned_of_format) {
      warned_of_format = true;
      console.warn(
        'The format option has been removed in Svelte 4, the compiler only outputs ESM now. Remove "format" from your compiler options. If you did not set this yourself, bump the version of your bundler plugin (vite-plugin-svelte/rollup-plugin-svelte/svelte-loader)'
      );
    }
    delete /** @type {any} */
    options.format;
  }
  const { name: name49, filename, loopGuardTimeout, dev, namespace, css } = options;
  Object.keys(options).forEach((key) => {
    if (!valid_options.includes(key)) {
      const match = fuzzymatch(key, valid_options);
      let message = `Unrecognized option '${key}'`;
      if (match)
        message += ` (did you mean '${match}'?)`;
      throw new Error(message);
    }
  });
  if (name49 && !regex_valid_identifier.test(name49)) {
    throw new Error(`options.name must be a valid identifier (got '${name49}')`);
  }
  if (name49 && regex_starts_with_lowercase_character.test(name49)) {
    const message = "options.name should be capitalised";
    warnings.push({
      code: "options-lowercase-name",
      message,
      filename,
      toString: () => message
    });
  }
  if (loopGuardTimeout && !dev) {
    const message = "options.loopGuardTimeout is for options.dev = true only";
    warnings.push({
      code: "options-loop-guard-timeout",
      message,
      filename,
      toString: () => message
    });
  }
  if (css === true || css === false) {
    options.css = css === true ? "injected" : "external";
    if (!warned_boolean_css) {
      console.warn(
        `compilerOptions.css as a boolean is deprecated. Use '${options.css}' instead of ${css}.`
      );
      warned_boolean_css = true;
    }
  }
  if (!valid_css_values.includes(options.css)) {
    throw new Error(
      `compilerOptions.css must be 'injected', 'external' or 'none' (got '${options.css}').`
    );
  }
  if (namespace && valid_namespaces.indexOf(namespace) === -1) {
    const match = fuzzymatch(namespace, valid_namespaces);
    if (match) {
      throw new Error(`Invalid namespace '${namespace}' (did you mean '${match}'?)`);
    } else {
      throw new Error(`Invalid namespace '${namespace}'`);
    }
  }
  if (options.discloseVersion == void 0) {
    options.discloseVersion = true;
  }
}
function compile(source, options = {}) {
  options = Object.assign(
    { generate: "dom", dev: false, enableSourcemap: true, css: "injected" },
    options
  );
  const stats = new Stats();
  const warnings = [];
  validate_options(options, warnings);
  stats.start("parse");
  const ast = parse57(source, options);
  stats.stop("parse");
  stats.start("create component");
  const component = new Component(
    ast,
    source,
    options.name || get_name_from_filename(options.filename) || "Component",
    options,
    stats,
    warnings
  );
  stats.stop("create component");
  const result = options.generate === false ? null : options.generate === "ssr" ? ssr(component, options) : dom(component, options);
  return component.generate(result);
}

// node_modules/svelte/src/compiler/preprocess/decode_sourcemap.js
var import_sourcemap_codec3 = __toESM(require_sourcemap_codec_umd(), 1);
function decoded_sourcemap_from_generator(generator) {
  let previous_generated_line = 1;
  const converted_mappings = [[]];
  let result_line;
  let result_segment;
  let mapping;
  const source_idx = generator._sources.toArray().reduce((acc, val, idx) => (acc[val] = idx, acc), {});
  const name_idx = generator._names.toArray().reduce((acc, val, idx) => (acc[val] = idx, acc), {});
  const mappings = generator._mappings.toArray();
  result_line = converted_mappings[0];
  for (let i = 0, len = mappings.length; i < len; i++) {
    mapping = mappings[i];
    if (mapping.generatedLine > previous_generated_line) {
      while (mapping.generatedLine > previous_generated_line) {
        converted_mappings.push([]);
        previous_generated_line++;
      }
      result_line = converted_mappings[mapping.generatedLine - 1];
    } else if (i > 0) {
      const previous_mapping = mappings[i - 1];
      if (
        // sorted by selectivity
        mapping.generatedColumn === previous_mapping.generatedColumn && mapping.originalColumn === previous_mapping.originalColumn && mapping.name === previous_mapping.name && mapping.generatedLine === previous_mapping.generatedLine && mapping.originalLine === previous_mapping.originalLine && mapping.source === previous_mapping.source
      ) {
        continue;
      }
    }
    result_line.push([mapping.generatedColumn]);
    result_segment = result_line[result_line.length - 1];
    if (mapping.source != null) {
      result_segment.push(
        ...[source_idx[mapping.source], mapping.originalLine - 1, mapping.originalColumn]
      );
      if (mapping.name != null) {
        result_segment.push(name_idx[mapping.name]);
      }
    }
  }
  const map = {
    version: generator._version,
    sources: generator._sources.toArray(),
    names: generator._names.toArray(),
    mappings: converted_mappings
  };
  if (generator._file != null) {
    map.file = generator._file;
  }
  return map;
}
function decode_map(processed) {
  let decoded_map = typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map;
  if (typeof decoded_map.mappings === "string") {
    decoded_map.mappings = (0, import_sourcemap_codec3.decode)(decoded_map.mappings);
  }
  if (decoded_map._mappings && decoded_map.constructor.name === "SourceMapGenerator") {
    decoded_map = decoded_sourcemap_from_generator(decoded_map);
  }
  return decoded_map;
}

// node_modules/svelte/src/compiler/preprocess/replace_in_code.js
function slice_source(code_slice, offset2, { file_basename, filename, get_location }) {
  return {
    source: code_slice,
    get_location: (index) => get_location(index + offset2),
    file_basename,
    filename
  };
}
function calculate_replacements(re2, get_replacement, source) {
  const replacements = [];
  source.replace(re2, (...match) => {
    replacements.push(
      get_replacement(...match).then((replacement) => {
        const matched_string = match[0];
        const offset2 = match[match.length - 2];
        return { offset: offset2, length: matched_string.length, replacement };
      })
    );
    return "";
  });
  return Promise.all(replacements);
}
function perform_replacements(replacements, source) {
  const out = new MappedCode();
  let last_end = 0;
  for (const { offset: offset2, length: length2, replacement } of replacements) {
    const unchanged_prefix = MappedCode.from_source(
      slice_source(source.source.slice(last_end, offset2), last_end, source)
    );
    out.concat(unchanged_prefix).concat(replacement);
    last_end = offset2 + length2;
  }
  const unchanged_suffix = MappedCode.from_source(
    slice_source(source.source.slice(last_end), last_end, source)
  );
  return out.concat(unchanged_suffix);
}
async function replace_in_code(regex, get_replacement, location) {
  const replacements = await calculate_replacements(regex, get_replacement, location.source);
  return perform_replacements(replacements, location);
}

// node_modules/svelte/src/compiler/preprocess/index.js
var regex_filepath_separator = /[/\\]/;
function get_file_basename(filename) {
  return filename.split(regex_filepath_separator).pop();
}
var PreprocessResult = class {
  /**
   *
   * @param {string} source
   * @param {string} [filename]
   */
  constructor(source, filename) {
    /** @type {string} */
    __publicField(this, "source");
    /** @type {string | undefined} */
    __publicField(this, "filename");
    // sourcemap_list is sorted in reverse order from last map (index 0) to first map (index -1)
    // so we use sourcemap_list.unshift() to add new maps
    // https://github.com/ampproject/remapping#multiple-transformations-of-a-file
    /**
     * @default []
     * @type {Array<import('@ampproject/remapping').DecodedSourceMap | import('@ampproject/remapping').RawSourceMap>}
     */
    __publicField(this, "sourcemap_list", []);
    /**
     * @default []
     * @type {string[]}
     */
    __publicField(this, "dependencies", []);
    /**
     * @type {string}
     */
    __publicField(this, "file_basename");
    /**
     * @type {ReturnType<typeof getLocator>}
     */
    __publicField(this, "get_location");
    this.source = source;
    this.filename = filename;
    this.update_source({ string: source });
    this.file_basename = filename == null ? null : get_file_basename(filename);
  }
  /**
   * @param {import('./private.js').SourceUpdate} opts
   */
  update_source({ string: source, map, dependencies }) {
    if (source != null) {
      this.source = source;
      this.get_location = getLocator(source);
    }
    if (map) {
      this.sourcemap_list.unshift(map);
    }
    if (dependencies) {
      this.dependencies.push(...dependencies);
    }
  }
  /**
   * @returns {import('./public.js').Processed}
   */
  to_processed() {
    const map = combine_sourcemaps(this.file_basename, this.sourcemap_list);
    return {
      // TODO return separated output, in future version where svelte.compile supports it:
      // style: { code: styleCode, map: styleMap },
      // script { code: scriptCode, map: scriptMap },
      // markup { code: markupCode, map: markupMap },
      code: this.source,
      dependencies: [...new Set(this.dependencies)],
      map,
      toString: () => this.source
    };
  }
};
function processed_content_to_code(processed, location, file_basename) {
  let decoded_map;
  if (processed.map) {
    decoded_map = decode_map(processed);
    if (decoded_map.sources) {
      const source_index = decoded_map.sources.indexOf(file_basename);
      if (source_index !== -1) {
        sourcemap_add_offset(decoded_map, location, source_index);
      }
    }
  }
  return MappedCode.from_processed(processed.code, decoded_map);
}
function processed_tag_to_code(processed, tag_name, original_attributes, generated_attributes, source) {
  const { file_basename, get_location } = source;
  const build_mapped_code = (code2, offset2) => MappedCode.from_source(slice_source(code2, offset2, source));
  const original_tag_open = `<${tag_name}${original_attributes}>`;
  const tag_open = `<${tag_name}${generated_attributes}>`;
  let tag_open_code;
  if (original_tag_open.length !== tag_open.length) {
    const mappings = [
      [
        // start of tag
        [0, 0, 0, 0],
        // end of tag start
        [`<${tag_name}`.length, 0, 0, `<${tag_name}`.length]
      ]
    ];
    const line = tag_open.split("\n").length - 1;
    const column = tag_open.length - (line === 0 ? 0 : tag_open.lastIndexOf("\n")) - 1;
    while (mappings.length <= line) {
      mappings.push([[0, 0, 0, `<${tag_name}`.length]]);
    }
    mappings[line].push([
      column,
      0,
      original_tag_open.split("\n").length - 1,
      original_tag_open.length - original_tag_open.lastIndexOf("\n") - 1
    ]);
    const map = {
      version: 3,
      names: [],
      sources: [file_basename],
      mappings
    };
    sourcemap_add_offset(map, get_location(0), 0);
    tag_open_code = MappedCode.from_processed(tag_open, map);
  } else {
    tag_open_code = build_mapped_code(tag_open, 0);
  }
  const tag_close = `</${tag_name}>`;
  const tag_close_code = build_mapped_code(
    tag_close,
    original_tag_open.length + source.source.length
  );
  parse_attached_sourcemap(processed, tag_name);
  const content_code = processed_content_to_code(
    processed,
    get_location(original_tag_open.length),
    file_basename
  );
  return tag_open_code.concat(content_code).concat(tag_close_code);
}
var attribute_pattern = /([\w-$]+\b)(?:=(?:"([^"]*)"|'([^']*)'|(\S+)))?/g;
function parse_tag_attributes(str) {
  const attrs = {};
  let match;
  while ((match = attribute_pattern.exec(str)) !== null) {
    const name49 = match[1];
    const value = match[2] || match[3] || match[4];
    attrs[name49] = !value || value;
  }
  return attrs;
}
function stringify_tag_attributes(attributes) {
  if (!attributes)
    return;
  let value = Object.entries(attributes).map(([key, value2]) => value2 === true ? key : `${key}="${value2}"`).join(" ");
  if (value) {
    value = " " + value;
  }
  return value;
}
var regex_style_tags = /<!--[^]*?-->|<style((?:\s+[^=>'"\/]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"\/]+)*\s*)(?:\/>|>([\S\s]*?)<\/style>)/g;
var regex_script_tags = /<!--[^]*?-->|<script((?:\s+[^=>'"\/]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"\/]+)*\s*)(?:\/>|>([\S\s]*?)<\/script>)/g;
async function process_tag(tag_name, preprocessor, source) {
  const { filename, source: markup } = source;
  const tag_regex = tag_name === "style" ? regex_style_tags : regex_script_tags;
  const dependencies = [];
  async function process_single_tag(tag_with_content, attributes = "", content = "", tag_offset) {
    const no_change = () => MappedCode.from_source(slice_source(tag_with_content, tag_offset, source));
    if (!attributes && !content)
      return no_change();
    const processed = await preprocessor({
      content: content || "",
      attributes: parse_tag_attributes(attributes || ""),
      markup,
      filename
    });
    if (!processed)
      return no_change();
    if (processed.dependencies)
      dependencies.push(...processed.dependencies);
    if (!processed.map && processed.code === content)
      return no_change();
    return processed_tag_to_code(
      processed,
      tag_name,
      attributes,
      stringify_tag_attributes(processed.attributes) ?? attributes,
      slice_source(content, tag_offset, source)
    );
  }
  const { string, map } = await replace_in_code(tag_regex, process_single_tag, source);
  return { string, map, dependencies };
}
async function process_markup(process2, source) {
  const processed = await process2({
    content: source.source,
    filename: source.filename
  });
  if (processed) {
    return {
      string: processed.code,
      map: processed.map ? (
        // TODO: can we use decode_sourcemap?
        typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map
      ) : void 0,
      dependencies: processed.dependencies
    };
  } else {
    return {};
  }
}
async function preprocess(source, preprocessor, options) {
  const filename = options && options.filename || /** @type {any} */
  preprocessor.filename;
  const preprocessors = preprocessor ? Array.isArray(preprocessor) ? preprocessor : [preprocessor] : [];
  const result = new PreprocessResult(source, filename);
  for (const preprocessor2 of preprocessors) {
    if (preprocessor2.markup) {
      result.update_source(await process_markup(preprocessor2.markup, result));
    }
    if (preprocessor2.script) {
      result.update_source(await process_tag("script", preprocessor2.script, result));
    }
    if (preprocessor2.style) {
      result.update_source(await process_tag("style", preprocessor2.style, result));
    }
  }
  return result.to_processed();
}
export {
  VERSION,
  compile,
  parse57 as parse,
  preprocess,
  walk
};
//# sourceMappingURL=svelte_compiler.js.map
